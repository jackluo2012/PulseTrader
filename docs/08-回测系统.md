# 回测系统文档

## 回测系统概述

回测系统是量化交易的核心组成部分，它通过历史数据验证交易策略的有效性。一个完整的回测系统能够模拟真实的交易环境，评估策略的历史表现，为策略优化提供依据。

### 回测的重要性

1. **策略验证**: 检验策略在历史数据上的表现
2. **参数优化**: 找到最优的策略参数组合
3. **风险评估**: 评估策略的风险收益特征
4. **性能评估**: 计算各种性能指标
5. **鲁棒性测试**: 验证策略在不同市场环境下的表现

### 回测类型

1. **向量回测**: 基于向量化计算，速度快但简化了交易逻辑
2. **事件回测**: 逐笔处理交易事件，更真实但速度较慢
3. **tick级回测**: 最高精度，模拟每一笔交易
4. **实时模拟**: 模拟实时交易环境

## 回测引擎架构

### 1. 回测引擎基类

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Union, Tuple
from dataclasses import dataclass, field
from enum import Enum
import pandas as pd
import numpy as np
from datetime import datetime, timedelta

class BacktestMode(Enum):
    """回测模式"""
    VECTOR = "vector"      # 向量回测
    EVENT = "event"        # 事件回测
    TICK = "tick"          # tick回测

class OrderType(Enum):
    """订单类型"""
    MARKET = "market"      # 市价单
    LIMIT = "limit"        # 限价单
    STOP = "stop"          # 止损单

class OrderSide(Enum):
    """订单方向"""
    BUY = "buy"
    SELL = "sell"

@dataclass
class Order:
    """订单"""
    symbol: str
    side: OrderSide
    order_type: OrderType
    quantity: int
    price: Optional[float] = None
    timestamp: Optional[datetime] = None
    order_id: Optional[str] = None
    status: str = "pending"
    filled_quantity: int = 0
    avg_fill_price: float = 0.0

@dataclass
class Trade:
    """成交记录"""
    symbol: str
    side: OrderSide
    quantity: int
    price: float
    timestamp: datetime
    trade_id: str
    order_id: str
    commission: float = 0.0

@dataclass
class PortfolioSnapshot:
    """组合快照"""
    timestamp: datetime
    cash: float
    positions: Dict[str, int]
    portfolio_value: float
    daily_return: float = 0.0

class BacktestEngine(ABC):
    """回测引擎基类"""

    def __init__(self, initial_capital: float = 1000000,
                 commission: float = 0.001,
                 slippage: float = 0.001,
                 mode: BacktestMode = BacktestMode.VECTOR):
        self.initial_capital = initial_capital
        self.commission = commission
        self.slippage = slippage
        self.mode = mode

        # 回测状态
        self.current_capital = initial_capital
        self.positions = {}  # {symbol: quantity}
        self.pending_orders = []
        self.trade_history = []
        self.portfolio_history = []

        # 回测结果
        self.results = {}

    @abstractmethod
    def run_backtest(self, data: Dict[str, pd.DataFrame], signals: Dict[str, pd.DataFrame]) -> Dict:
        """运行回测"""
        pass

    @abstractmethod
    def process_orders(self, timestamp: datetime, market_data: Dict[str, pd.Series]) -> List[Trade]:
        """处理订单"""
        pass

    def reset(self):
        """重置回测状态"""
        self.current_capital = self.initial_capital
        self.positions = {}
        self.pending_orders = []
        self.trade_history = []
        self.portfolio_history = []
        self.results = {}

    def place_order(self, order: Order):
        """下单"""
        order.order_id = f"order_{len(self.pending_orders)}"
        order.timestamp = datetime.now()
        self.pending_orders.append(order)

    def cancel_order(self, order_id: str):
        """撤单"""
        self.pending_orders = [order for order in self.pending_orders if order.order_id != order_id]

    def get_position(self, symbol: str) -> int:
        """获取持仓"""
        return self.positions.get(symbol, 0)

    def update_position(self, symbol: str, quantity_change: int):
        """更新持仓"""
        self.positions[symbol] = self.positions.get(symbol, 0) + quantity_change
        if self.positions[symbol] == 0:
            del self.positions[symbol]

    def calculate_portfolio_value(self, market_data: Dict[str, pd.Series]) -> float:
        """计算组合价值"""
        portfolio_value = self.current_capital

        for symbol, quantity in self.positions.items():
            if symbol in market_data and quantity > 0:
                price = market_data[symbol].get('close', 0)
                portfolio_value += quantity * price

        return portfolio_value

    def take_portfolio_snapshot(self, timestamp: datetime, market_data: Dict[str, pd.Series],
                              previous_value: float = None):
        """记录组合快照"""
        current_value = self.calculate_portfolio_value(market_data)

        daily_return = 0.0
        if previous_value is not None and previous_value > 0:
            daily_return = (current_value - previous_value) / previous_value

        snapshot = PortfolioSnapshot(
            timestamp=timestamp,
            cash=self.current_capital,
            positions=self.positions.copy(),
            portfolio_value=current_value,
            daily_return=daily_return
        )

        self.portfolio_history.append(snapshot)
        return current_value
```

### 2. 向量回测引擎

```python
class VectorBacktestEngine(BacktestEngine):
    """向量回测引擎"""

    def __init__(self, **kwargs):
        super().__init__(mode=BacktestMode.VECTOR, **kwargs)

    def run_backtest(self, data: Dict[str, pd.DataFrame], signals: Dict[str, pd.DataFrame]) -> Dict:
        """运行向量回测"""
        self.reset()

        # 获取所有交易日期
        all_dates = set()
        for symbol_data in data.values():
            all_dates.update(symbol_data.index)
        for symbol_signals in signals.values():
            all_dates.update(symbol_signals.index)

        trading_dates = sorted(list(all_dates))

        # 初始化
        portfolio_values = []
        previous_value = self.initial_capital

        print(f"开始向量回测，共 {len(trading_dates)} 个交易日")

        for i, date in enumerate(trading_dates):
            # 获取当日市场数据
            daily_market_data = {}
            for symbol, price_data in data.items():
                if date in price_data.index:
                    daily_market_data[symbol] = price_data.loc[date]

            # 获取当日信号
            daily_signals = {}
            for symbol, signal_data in signals.items():
                if date in signal_data.index:
                    daily_signals[symbol] = signal_data.loc[date]

            # 执行交易
            self._execute_vector_trades(date, daily_market_data, daily_signals)

            # 记录组合快照
            current_value = self.take_portfolio_snapshot(date, daily_market_data, previous_value)
            portfolio_values.append(current_value)
            previous_value = current_value

            # 进度显示
            if (i + 1) % 100 == 0:
                print(f"已处理 {i + 1}/{len(trading_dates)} 个交易日")

        # 计算回测结果
        self.results = self._calculate_vector_results(portfolio_values, trading_dates)
        return self.results

    def _execute_vector_trades(self, date: datetime, market_data: Dict, signals: Dict):
        """执行向量交易"""
        for symbol, signal in signals.items():
            if symbol not in market_data:
                continue

            price = market_data[symbol].get('close', 0)
            if price <= 0:
                continue

            signal_value = signal.get('signal', 0)
            current_position = self.get_position(symbol)

            # 计算目标仓位
            if signal_value != 0:
                # 简单的仓位管理：使用信号的相反数作为仓位比例
                target_position_ratio = abs(signal_value) * 0.1  # 最大10%仓位
                target_value = self.current_capital * target_position_ratio
                target_quantity = int(target_value / price / 100) * 100  # 整手

                if signal_value > 0 and current_position < target_quantity:
                    # 买入
                    quantity_to_buy = target_quantity - current_position
                    self._execute_buy(symbol, quantity_to_buy, price, date)
                elif signal_value < 0 and current_position > 0:
                    # 卖出
                    quantity_to_sell = min(current_position, target_quantity)
                    self._execute_sell(symbol, quantity_to_sell, price, date)

    def _execute_buy(self, symbol: str, quantity: int, price: float, date: datetime):
        """执行买入"""
        if quantity <= 0:
            return

        # 计算交易成本
        commission = quantity * price * self.commission
        slippage_cost = quantity * price * self.slippage
        total_cost = quantity * price + commission + slippage_cost

        # 检查资金是否足够
        if total_cost <= self.current_capital:
            self.current_capital -= total_cost
            self.update_position(symbol, quantity)

            # 记录交易
            trade = Trade(
                symbol=symbol,
                side=OrderSide.BUY,
                quantity=quantity,
                price=price,
                timestamp=date,
                trade_id=f"buy_{len(self.trade_history)}",
                order_id=f"order_{len(self.trade_history)}",
                commission=commission
            )
            self.trade_history.append(trade)

    def _execute_sell(self, symbol: str, quantity: int, price: float, date: datetime):
        """执行卖出"""
        if quantity <= 0:
            return

        current_position = self.get_position(symbol)
        quantity_to_sell = min(quantity, current_position)

        if quantity_to_sell > 0:
            # 计算交易收入（扣除成本）
            gross_proceeds = quantity_to_sell * price
            commission = gross_proceeds * self.commission
            slippage_cost = gross_proceeds * self.slippage
            net_proceeds = gross_proceeds - commission - slippage_cost

            self.current_capital += net_proceeds
            self.update_position(symbol, -quantity_to_sell)

            # 记录交易
            trade = Trade(
                symbol=symbol,
                side=OrderSide.SELL,
                quantity=quantity_to_sell,
                price=price,
                timestamp=date,
                trade_id=f"sell_{len(self.trade_history)}",
                order_id=f"order_{len(self.trade_history)}",
                commission=commission
            )
            self.trade_history.append(trade)

    def _calculate_vector_results(self, portfolio_values: List[float], trading_dates: List[datetime]) -> Dict:
        """计算向量回测结果"""
        if not portfolio_values:
            return {}

        # 基础计算
        returns = pd.Series(portfolio_values).pct_change().dropna()
        total_return = (portfolio_values[-1] / portfolio_values[0]) - 1

        # 年化收益率
        days = len(portfolio_values)
        annual_return = (1 + total_return) ** (252 / days) - 1

        # 波动率
        volatility = returns.std() * np.sqrt(252)

        # 夏普比率
        sharpe_ratio = annual_return / volatility if volatility > 0 else 0

        # 最大回撤
        cumulative = pd.Series(portfolio_values) / portfolio_values[0]
        running_max = cumulative.expanding().max()
        drawdown = (cumulative - running_max) / running_max
        max_drawdown = drawdown.min()

        # 胜率
        winning_trades = sum(1 for trade in self.trade_history if trade.side == OrderSide.SELL)
        total_trades = len(self.trade_history)
        win_rate = winning_trades / total_trades if total_trades > 0 else 0

        return {
            'total_return': total_return,
            'annual_return': annual_return,
            'volatility': volatility,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown': max_drawdown,
            'win_rate': win_rate,
            'total_trades': total_trades,
            'portfolio_values': pd.Series(portfolio_values, index=trading_dates),
            'returns': returns,
            'trade_history': self.trade_history
        }

    def process_orders(self, timestamp: datetime, market_data: Dict[str, pd.Series]) -> List[Trade]:
        """向量回测中不使用订单系统"""
        return []
```

### 3. 事件回测引擎

```python
class EventBacktestEngine(BacktestEngine):
    """事件回测引擎"""

    def __init__(self, **kwargs):
        super().__init__(mode=BacktestMode.EVENT, **kwargs)

    def run_backtest(self, data: Dict[str, pd.DataFrame], signals: Dict[str, pd.DataFrame]) -> Dict:
        """运行事件回测"""
        self.reset()

        # 创建事件队列
        events = self._create_event_queue(data, signals)

        # 初始化
        portfolio_values = []
        previous_value = self.initial_capital

        print(f"开始事件回测，共 {len(events)} 个事件")

        for i, event in enumerate(events):
            if event['type'] == 'market_data':
                # 处理市场数据事件
                self._handle_market_data_event(event)
            elif event['type'] == 'signal':
                # 处理交易信号事件
                self._handle_signal_event(event, data)

            # 处理待成交订单
            market_data = {event['symbol']: data[event['symbol']].loc[event['timestamp']]
                          for event in [event] if event['type'] == 'market_data'}

            trades = self.process_orders(event['timestamp'], market_data)
            for trade in trades:
                self.trade_history.append(trade)

            # 记录组合快照
            if event['type'] == 'market_data':
                current_value = self.take_portfolio_snapshot(event['timestamp'], market_data, previous_value)
                portfolio_values.append(current_value)
                previous_value = current_value

            # 进度显示
            if (i + 1) % 1000 == 0:
                print(f"已处理 {i + 1}/{len(events)} 个事件")

        # 计算回测结果
        self.results = self._calculate_event_results(portfolio_values)
        return self.results

    def _create_event_queue(self, data: Dict[str, pd.DataFrame], signals: Dict[str, pd.DataFrame]) -> List[Dict]:
        """创建事件队列"""
        events = []

        # 添加市场数据事件
        for symbol, price_data in data.items():
            for timestamp in price_data.index:
                events.append({
                    'type': 'market_data',
                    'timestamp': timestamp,
                    'symbol': symbol,
                    'data': price_data.loc[timestamp]
                })

        # 添加信号事件
        for symbol, signal_data in signals.items():
            for timestamp in signal_data.index:
                signal_value = signal_data.loc[timestamp].get('signal', 0)
                if signal_value != 0:
                    events.append({
                        'type': 'signal',
                        'timestamp': timestamp,
                        'symbol': symbol,
                        'signal': signal_value
                    })

        # 按时间排序
        events.sort(key=lambda x: x['timestamp'])
        return events

    def _handle_market_data_event(self, event: Dict):
        """处理市场数据事件"""
        # 在事件回测中，主要用于更新组合价值和检查订单
        pass

    def _handle_signal_event(self, event: Dict, data: Dict[str, pd.DataFrame]):
        """处理信号事件"""
        symbol = event['symbol']
        signal_value = event['signal']

        # 获取当前价格
        if symbol in data and event['timestamp'] in data[symbol].index:
            price = data[symbol].loc[event['timestamp'], 'close']

            if signal_value > 0:
                # 买入信号
                quantity = self._calculate_order_quantity(symbol, price, signal_value)
                if quantity > 0:
                    order = Order(
                        symbol=symbol,
                        side=OrderSide.BUY,
                        order_type=OrderType.MARKET,
                        quantity=quantity,
                        price=price
                    )
                    self.place_order(order)

            elif signal_value < 0:
                # 卖出信号
                current_position = self.get_position(symbol)
                if current_position > 0:
                    quantity = min(current_position, abs(int(current_position * abs(signal_value))))
                    order = Order(
                        symbol=symbol,
                        side=OrderSide.SELL,
                        order_type=OrderType.MARKET,
                        quantity=quantity,
                        price=price
                    )
                    self.place_order(order)

    def _calculate_order_quantity(self, symbol: str, price: float, signal_strength: float) -> int:
        """计算订单数量"""
        # 基于信号强度和可用资金计算
        available_capital = self.current_capital * abs(signal_strength) * 0.1  # 最多使用10%资金
        quantity = int(available_capital / price / 100) * 100  # 整手
        return quantity

    def process_orders(self, timestamp: datetime, market_data: Dict[str, pd.Series]) -> List[Trade]:
        """处理订单"""
        executed_trades = []

        for order in self.pending_orders[:]:
            if order.symbol in market_data:
                price = market_data[order.symbol].get('close', 0)
                if price > 0:
                    # 执行订单
                    trade = self._execute_order(order, price, timestamp)
                    if trade:
                        executed_trades.append(trade)
                        self.pending_orders.remove(order)

        return executed_trades

    def _execute_order(self, order: Order, market_price: float, timestamp: datetime) -> Optional[Trade]:
        """执行订单"""
        # 计算实际成交价格（考虑滑点）
        if order.side == OrderSide.BUY:
            fill_price = market_price * (1 + self.slippage)
        else:
            fill_price = market_price * (1 - self.slippage)

        # 计算手续费
        commission = order.quantity * fill_price * self.commission

        # 更新资金和持仓
        if order.side == OrderSide.BUY:
            total_cost = order.quantity * fill_price + commission
            if total_cost <= self.current_capital:
                self.current_capital -= total_cost
                self.update_position(order.symbol, order.quantity)
            else:
                return None
        else:
            # 卖出
            current_position = self.get_position(order.symbol)
            if order.quantity <= current_position:
                proceeds = order.quantity * fill_price - commission
                self.current_capital += proceeds
                self.update_position(order.symbol, -order.quantity)
            else:
                return None

        # 创建交易记录
        trade = Trade(
            symbol=order.symbol,
            side=order.side,
            quantity=order.quantity,
            price=fill_price,
            timestamp=timestamp,
            trade_id=f"trade_{len(self.trade_history)}",
            order_id=order.order_id,
            commission=commission
        )

        return trade

    def _calculate_event_results(self, portfolio_values: List[float]) -> Dict:
        """计算事件回测结果"""
        # 与向量回测结果计算相同
        return self._calculate_vector_results(portfolio_values,
                                            [snap.timestamp for snap in self.portfolio_history])
```

## 回测分析器

### 1. 性能分析器

```python
class BacktestAnalyzer:
    """回测分析器"""

    def __init__(self, results: Dict):
        self.results = results
        self.returns = results.get('returns', pd.Series())
        self.portfolio_values = results.get('portfolio_values', pd.Series())
        self.trade_history = results.get('trade_history', [])

    def calculate_performance_metrics(self) -> Dict[str, float]:
        """计算性能指标"""
        if self.returns.empty:
            return {}

        # 基础指标
        total_return = self.results.get('total_return', 0)
        annual_return = self.results.get('annual_return', 0)
        volatility = self.results.get('volatility', 0)
        sharpe_ratio = self.results.get('sharpe_ratio', 0)
        max_drawdown = self.results.get('max_drawdown', 0)

        # 高级指标
        sortino_ratio = self._calculate_sortino_ratio()
        calmar_ratio = self._calculate_calmar_ratio()
        var_95 = self.returns.quantile(0.05)
        skewness = self.returns.skew()
        kurtosis = self.returns.kurtosis()

        # 交易相关指标
        win_rate = self.results.get('win_rate', 0)
        profit_factor = self._calculate_profit_factor()
        avg_trade_return = self._calculate_average_trade_return()

        return {
            'total_return': total_return,
            'annual_return': annual_return,
            'volatility': volatility,
            'sharpe_ratio': sharpe_ratio,
            'sortino_ratio': sortino_ratio,
            'calmar_ratio': calmar_ratio,
            'max_drawdown': max_drawdown,
            'var_95': var_95,
            'skewness': skewness,
            'kurtosis': kurtosis,
            'win_rate': win_rate,
            'profit_factor': profit_factor,
            'avg_trade_return': avg_trade_return,
            'total_trades': len(self.trade_history)
        }

    def _calculate_sortino_ratio(self) -> float:
        """计算Sortino比率"""
        if self.returns.empty:
            return 0.0

        downside_returns = self.returns[self.returns < 0]
        if len(downside_returns) == 0:
            return float('inf') if self.returns.mean() > 0 else 0.0

        downside_std = downside_returns.std() * np.sqrt(252)
        annual_return = self.results.get('annual_return', 0)

        return annual_return / downside_std if downside_std > 0 else 0.0

    def _calculate_calmar_ratio(self) -> float:
        """计算Calmar比率"""
        annual_return = self.results.get('annual_return', 0)
        max_drawdown = abs(self.results.get('max_drawdown', 0))

        return annual_return / max_drawdown if max_drawdown > 0 else 0.0

    def _calculate_profit_factor(self) -> float:
        """计算盈亏比"""
        if not self.trade_history:
            return 0.0

        buy_trades = [t for t in self.trade_history if t.side == OrderSide.BUY]
        sell_trades = [t for t in self.trade_history if t.side == OrderSide.SELL]

        if len(buy_trades) != len(sell_trades):
            return 0.0

        # 计算每对买卖交易的盈亏
        total_profit = 0.0
        total_loss = 0.0

        for i, sell_trade in enumerate(sell_trades):
            if i < len(buy_trades):
                buy_trade = buy_trades[i]
                pnl = (sell_trade.price - buy_trade.price) * sell_trade.quantity
                pnl -= (buy_trade.commission + sell_trade.commission)

                if pnl > 0:
                    total_profit += pnl
                else:
                    total_loss += abs(pnl)

        return total_profit / total_loss if total_loss > 0 else float('inf')

    def _calculate_average_trade_return(self) -> float:
        """计算平均交易收益"""
        if not self.trade_history:
            return 0.0

        buy_trades = [t for t in self.trade_history if t.side == OrderSide.BUY]
        sell_trades = [t for t in self.trade_history if t.side == OrderSide.SELL]

        if len(buy_trades) != len(sell_trades) or len(buy_trades) == 0:
            return 0.0

        total_return = 0.0
        for i, sell_trade in enumerate(sell_trades):
            if i < len(buy_trades):
                buy_trade = buy_trades[i]
                trade_return = (sell_trade.price - buy_trade.price) / buy_trade.price
                total_return += trade_return

        return total_return / len(buy_trades)

    def calculate_monthly_returns(self) -> pd.Series:
        """计算月度收益"""
        if self.portfolio_values.empty:
            return pd.Series()

        monthly_values = self.portfolio_values.resample('M').last()
        monthly_returns = monthly_values.pct_change().dropna()

        return monthly_returns

    def calculate_rolling_metrics(self, window: int = 252) -> pd.DataFrame:
        """计算滚动指标"""
        if self.returns.empty:
            return pd.DataFrame()

        rolling_sharpe = self.returns.rolling(window).mean() / self.returns.rolling(window).std() * np.sqrt(252)
        rolling_volatility = self.returns.rolling(window).std() * np.sqrt(252)

        # 滚动最大回撤
        cumulative = (1 + self.returns).cumprod()
        rolling_max = cumulative.rolling(window).max()
        rolling_drawdown = (cumulative - rolling_max) / rolling_max

        return pd.DataFrame({
            'rolling_sharpe': rolling_sharpe,
            'rolling_volatility': rolling_volatility,
            'rolling_drawdown': rolling_drawdown
        })

    def generate_performance_report(self) -> str:
        """生成性能报告"""
        metrics = self.calculate_performance_metrics()

        report = f"""
回测性能报告
============
基础指标:
总收益率: {metrics.get('total_return', 0):.2%}
年化收益率: {metrics.get('annual_return', 0):.2%}
年化波动率: {metrics.get('volatility', 0):.2%}
夏普比率: {metrics.get('sharpe_ratio', 0):.2f}
Sortino比率: {metrics.get('sortino_ratio', 0):.2f}
Calmar比率: {metrics.get('calmar_ratio', 0):.2f}

风险指标:
最大回撤: {metrics.get('max_drawdown', 0):.2%}
VaR(95%): {metrics.get('var_95', 0):.2%}
偏度: {metrics.get('skewness', 0):.2f}
峰度: {metrics.get('kurtosis', 0):.2f}

交易指标:
总交易次数: {metrics.get('total_trades', 0)}
胜率: {metrics.get('win_rate', 0):.2%}
盈亏比: {metrics.get('profit_factor', 0):.2f}
平均交易收益: {metrics.get('avg_trade_return', 0):.2%}
        """
        return report
```

### 2. 回测可视化

```python
import matplotlib.pyplot as plt
import seaborn as sns

class BacktestVisualizer:
    """回测可视化"""

    def __init__(self, results: Dict):
        self.results = results
        self.analyzer = BacktestAnalyzer(results)

    def plot_equity_curve(self, figsize: Tuple[int, int] = (12, 8)):
        """绘制净值曲线"""
        if self.analyzer.portfolio_values.empty:
            print("没有净值数据可以绘制")
            return

        plt.figure(figsize=figsize)

        # 净值曲线
        plt.subplot(2, 1, 1)
        normalized_values = self.analyzer.portfolio_values / self.analyzer.portfolio_values.iloc[0]
        plt.plot(normalized_values.index, normalized_values.values, linewidth=2, label='策略净值')
        plt.axhline(y=1, color='r', linestyle='--', alpha=0.7, label='初始净值')
        plt.title('策略净值曲线')
        plt.ylabel('归一化净值')
        plt.legend()
        plt.grid(True, alpha=0.3)

        # 回撤曲线
        plt.subplot(2, 1, 2)
        cumulative = normalized_values
        running_max = cumulative.expanding().max()
        drawdown = (cumulative - running_max) / running_max

        plt.fill_between(drawdown.index, drawdown.values, 0, alpha=0.3, color='red', label='回撤')
        plt.plot(drawdown.index, drawdown.values, color='red', linewidth=1)
        plt.title('策略回撤')
        plt.ylabel('回撤比例')
        plt.xlabel('日期')
        plt.legend()
        plt.grid(True, alpha=0.3)

        plt.tight_layout()
        plt.show()

    def plot_returns_distribution(self, figsize: Tuple[int, int] = (15, 10)):
        """绘制收益率分布"""
        if self.analyzer.returns.empty:
            print("没有收益率数据可以绘制")
            return

        fig, axes = plt.subplots(2, 2, figsize=figsize)

        # 收益率时间序列
        axes[0, 0].plot(self.analyzer.returns.index, self.analyzer.returns.values, alpha=0.7)
        axes[0, 0].axhline(y=0, color='r', linestyle='--', alpha=0.5)
        axes[0, 0].set_title('日收益率时间序列')
        axes[0, 0].set_ylabel('收益率')
        axes[0, 0].grid(True, alpha=0.3)

        # 收益率直方图
        axes[0, 1].hist(self.analyzer.returns.values, bins=50, alpha=0.7, edgecolor='black')
        axes[0, 1].axvline(x=0, color='r', linestyle='--', alpha=0.7)
        axes[0, 1].set_title('收益率分布直方图')
        axes[0, 1].set_xlabel('收益率')
        axes[0, 1].set_ylabel('频次')
        axes[0, 1].grid(True, alpha=0.3)

        # Q-Q图
        from scipy import stats
        stats.probplot(self.analyzer.returns.dropna(), dist="norm", plot=axes[1, 0])
        axes[1, 0].set_title('Q-Q图（正态性检验）')
        axes[1, 0].grid(True, alpha=0.3)

        # 累积收益率
        cumulative_returns = (1 + self.analyzer.returns).cumprod()
        axes[1, 1].plot(cumulative_returns.index, cumulative_returns.values, linewidth=2)
        axes[1, 1].set_title('累积收益率')
        axes[1, 1].set_ylabel('累积收益率')
        axes[1, 1].grid(True, alpha=0.3)

        plt.tight_layout()
        plt.show()

    def plot_rolling_metrics(self, window: int = 252, figsize: Tuple[int, int] = (15, 10)):
        """绘制滚动指标"""
        rolling_metrics = self.analyzer.calculate_rolling_metrics(window)

        if rolling_metrics.empty:
            print("没有足够数据计算滚动指标")
            return

        fig, axes = plt.subplots(3, 1, figsize=figsize)

        # 滚动夏普比率
        axes[0].plot(rolling_metrics.index, rolling_metrics['rolling_sharpe'], linewidth=2)
        axes[0].axhline(y=0, color='r', linestyle='--', alpha=0.7)
        axes[0].set_title(f'滚动夏普比率（{window}日）')
        axes[0].set_ylabel('夏普比率')
        axes[0].grid(True, alpha=0.3)

        # 滚动波动率
        axes[1].plot(rolling_metrics.index, rolling_metrics['rolling_volatility'], linewidth=2, color='orange')
        axes[1].set_title(f'滚动波动率（{window}日）')
        axes[1].set_ylabel('年化波动率')
        axes[1].grid(True, alpha=0.3)

        # 滚动回撤
        axes[2].fill_between(rolling_metrics.index, rolling_metrics['rolling_drawdown'], 0,
                            alpha=0.3, color='red')
        axes[2].plot(rolling_metrics.index, rolling_metrics['rolling_drawdown'], color='red', linewidth=1)
        axes[2].set_title(f'滚动最大回撤（{window}日）')
        axes[2].set_ylabel('回撤比例')
        axes[2].set_xlabel('日期')
        axes[2].grid(True, alpha=0.3)

        plt.tight_layout()
        plt.show()

    def plot_monthly_returns_heatmap(self, figsize: Tuple[int, int] = (12, 8)):
        """绘制月度收益热力图"""
        monthly_returns = self.analyzer.calculate_monthly_returns()

        if monthly_returns.empty:
            print("没有足够数据绘制月度收益热力图")
            return

        # 创建年月矩阵
        monthly_returns.index = pd.to_datetime(monthly_returns.index)
        monthly_returns_pivot = monthly_returns.to_frame('returns')
        monthly_returns_pivot['year'] = monthly_returns_pivot.index.year
        monthly_returns_pivot['month'] = monthly_returns_pivot.index.month

        pivot_table = monthly_returns_pivot.pivot_table(
            index='year', columns='month', values='returns'
        )

        # 设置月份标签
        month_labels = ['1月', '2月', '3月', '4月', '5月', '6月',
                       '7月', '8月', '9月', '10月', '11月', '12月']
        pivot_table.columns = [month_labels[i-1] for i in pivot_table.columns]

        plt.figure(figsize=figsize)
        sns.heatmap(pivot_table, annot=True, fmt='.2%', cmap='RdYlGn', center=0)
        plt.title('月度收益率热力图')
        plt.ylabel('年份')
        plt.xlabel('月份')
        plt.tight_layout()
        plt.show()

    def plot_trade_analysis(self, figsize: Tuple[int, int] = (15, 10)):
        """绘制交易分析"""
        if not self.analyzer.trade_history:
            print("没有交易记录可以分析")
            return

        fig, axes = plt.subplots(2, 2, figsize=figsize)

        # 交易时间分布
        trade_dates = [trade.timestamp for trade in self.analyzer.trade_history]
        trade_counts = pd.Series(trade_dates).dt.to_period('M').value_counts().sort_index()

        axes[0, 0].bar(range(len(trade_counts)), trade_counts.values)
        axes[0, 0].set_title('月度交易次数')
        axes[0, 0].set_ylabel('交易次数')
        axes[0, 0].set_xticks(range(len(trade_counts)))
        axes[0, 0].set_xticklabels([str(period) for period in trade_counts.index], rotation=45)
        axes[0, 0].grid(True, alpha=0.3)

        # 交易收益分布
        trade_returns = self._calculate_trade_returns()
        if trade_returns:
            axes[0, 1].hist(trade_returns, bins=30, alpha=0.7, edgecolor='black')
            axes[0, 1].axvline(x=0, color='r', linestyle='--', alpha=0.7)
            axes[0, 1].set_title('交易收益分布')
            axes[0, 1].set_xlabel('收益率')
            axes[0, 1].set_ylabel('频次')
            axes[0, 1].grid(True, alpha=0.3)

        # 累积交易收益
        if trade_returns:
            cumulative_trade_returns = pd.Series(trade_returns).cumsum()
            axes[1, 0].plot(range(len(cumulative_trade_returns)), cumulative_trade_returns.values)
            axes[1, 0].axhline(y=0, color='r', linestyle='--', alpha=0.7)
            axes[1, 0].set_title('累积交易收益')
            axes[1, 0].set_ylabel('累积收益')
            axes[1, 0].set_xlabel('交易序号')
            axes[1, 0].grid(True, alpha=0.3)

        # 交易品种分布
        symbol_counts = pd.Series([trade.symbol for trade in self.analyzer.trade_history]).value_counts()
        axes[1, 1].bar(range(len(symbol_counts)), symbol_counts.values)
        axes[1, 1].set_title('交易品种分布')
        axes[1, 1].set_ylabel('交易次数')
        axes[1, 1].set_xticks(range(len(symbol_counts)))
        axes[1, 1].set_xticklabels(symbol_counts.index, rotation=45)
        axes[1, 1].grid(True, alpha=0.3)

        plt.tight_layout()
        plt.show()

    def _calculate_trade_returns(self) -> List[float]:
        """计算每笔交易的收益"""
        if not self.analyzer.trade_history:
            return []

        buy_trades = [t for t in self.analyzer.trade_history if t.side == OrderSide.BUY]
        sell_trades = [t for t in self.analyzer.trade_history if t.side == OrderSide.SELL]

        trade_returns = []
        for i, sell_trade in enumerate(sell_trades):
            if i < len(buy_trades):
                buy_trade = buy_trades[i]
                trade_return = (sell_trade.price - buy_trade.price) / buy_trade.price
                trade_returns.append(trade_return)

        return trade_returns
```

## 使用示例

### 1. 完整回测示例

```python
def comprehensive_backtest_example():
    """完整回测示例"""
    # 准备数据和策略
    from data_fetcher import DataManager
    from strategies import MACrossStrategy

    # 获取数据
    data_manager = DataManager(AkshareDataFetcher())
    symbol = "000001.SZ"
    end_date = datetime.now().strftime('%Y-%m-%d')
    start_date = (datetime.now() - timedelta(days=365)).strftime('%Y-%m-%d')

    price_data = data_manager.get_stock_data(symbol, start_date, end_date)
    if price_data.empty:
        print("获取数据失败")
        return

    # 生成策略信号
    strategy = MACrossStrategy(short_window=5, long_window=20)
    signals = strategy.generate_signals(price_data)

    # 运行回测
    print("开始向量回测...")
    vector_engine = VectorBacktestEngine(initial_capital=1000000, commission=0.001)
    vector_results = vector_engine.run_backtest({symbol: price_data}, {symbol: signals})

    print("开始事件回测...")
    event_engine = EventBacktestEngine(initial_capital=1000000, commission=0.001)
    event_results = event_engine.run_backtest({symbol: price_data}, {symbol: signals})

    # 分析结果
    vector_analyzer = BacktestAnalyzer(vector_results)
    event_analyzer = BacktestAnalyzer(event_results)

    print("\n向量回测结果:")
    print(vector_analyzer.generate_performance_report())

    print("\n事件回测结果:")
    print(event_analyzer.generate_performance_report())

    # 可视化
    vector_visualizer = BacktestVisualizer(vector_results)
    vector_visualizer.plot_equity_curve()
    vector_visualizer.plot_returns_distribution()
    vector_visualizer.plot_monthly_returns_heatmap()

if __name__ == "__main__":
    comprehensive_backtest_example()
```

## 最佳实践

### 1. 回测设计原则
- **避免前视偏差**: 确保只能使用历史信息
- **考虑交易成本**: 包含手续费、滑点、税费
- **样本外测试**: 保留部分数据用于验证
- **参数稳定性**: 测试参数在不同时期的稳定性

### 2. 回测注意事项
- **数据质量**: 确保历史数据的准确性和完整性
- **生存偏差**: 注意已退市股票的数据缺失
- **流动性假设**: 考虑实际交易的流动性限制
- **市场冲击**: 大额交易对价格的影响

### 3. 结果解释
- **过拟合警告**: 谨慎解释过于完美的回测结果
- **样本局限性**: 历史表现不代表未来结果
- **市场环境**: 考虑不同市场环境下的表现
- **统计显著性**: 使用统计方法验证结果可靠性

## 下一步

掌握回测系统后，您可以：
1. 学习[实盘交易](09-实盘交易.md)
2. 深入[性能优化](10-性能优化.md)
3. 探索[策略优化](11-策略优化.md)