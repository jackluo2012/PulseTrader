# 数据获取指南

## 数据源概述

PulseTrader支持多个数据源，以确保证据数据的可靠性和完整性：

### 主要数据源
1. **AKShare**: 免费开源的金融数据接口库
2. **Tushare**: 专业金融数据服务（需要token）
3. **Yahoo Finance**: 国际市场数据
4. **本地数据文件**: CSV、Excel等格式

### 数据类型
- 股票日线、分钟线数据
- 指数数据
- 板块数据
- 财务数据
- 宏观经济数据

## AKShare数据获取

### 1. AKShare安装与配置

```bash
# 安装AKShare
pip install akshare

# 验证安装
import akshare as ak
print(ak.__version__)
```

### 2. 股票基础数据获取

```python
import akshare as ak
import pandas as pd
from datetime import datetime, timedelta

class AkshareDataFetcher:
    """AKShare数据获取器"""

    def __init__(self):
        self.name = "akshare"

    def get_stock_info(self, symbol: str) -> pd.DataFrame:
        """获取股票基本信息"""
        try:
            # 获取股票基本信息
            stock_info = ak.stock_individual_info_em(symbol=symbol)
            return stock_info
        except Exception as e:
            print(f"获取股票信息失败: {e}")
            return pd.DataFrame()

    def get_stock_daily(self, symbol: str, start_date: str, end_date: str) -> pd.DataFrame:
        """获取股票日线数据"""
        try:
            # AKShare需要调整股票代码格式
            if symbol.endswith('.SH'):
                ak_symbol = symbol.replace('.SH', '') + '.SH'
            elif symbol.endswith('.SZ'):
                ak_symbol = symbol.replace('.SZ', '') + '.SZ'
            else:
                ak_symbol = symbol

            # 获取历史数据
            stock_data = ak.stock_zh_a_hist(
                symbol=ak_symbol,
                period="daily",
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', ''),
                adjust="qfq"  # 前复权
            )

            # 重命名列以保持一致性
            stock_data = stock_data.rename(columns={
                '日期': 'date',
                '开盘': 'open',
                '收盘': 'close',
                '最高': 'high',
                '最低': 'low',
                '成交量': 'volume',
                '成交额': 'amount',
                '振幅': 'amplitude',
                '涨跌幅': 'pct_change',
                '涨跌额': 'change',
                '换手率': 'turnover'
            })

            # 设置日期索引
            stock_data['date'] = pd.to_datetime(stock_data['date'])
            stock_data.set_index('date', inplace=True)

            return stock_data

        except Exception as e:
            print(f"获取股票数据失败: {e}")
            return pd.DataFrame()

    def get_index_data(self, index_code: str, start_date: str, end_date: str) -> pd.DataFrame:
        """获取指数数据"""
        try:
            index_data = ak.stock_zh_index_daily(
                symbol=index_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )

            # 重命名列
            index_data = index_data.rename(columns={
                'date': 'date',
                'open': 'open',
                'close': 'close',
                'high': 'high',
                'low': 'low',
                'volume': 'volume'
            })

            index_data['date'] = pd.to_datetime(index_data['date'])
            index_data.set_index('date', inplace=True)

            return index_data

        except Exception as e:
            print(f"获取指数数据失败: {e}")
            return pd.DataFrame()

    def get_stock_list(self) -> pd.DataFrame:
        """获取股票列表"""
        try:
            stock_list = ak.stock_zh_a_spot_em()
            return stock_list[['代码', '名称', '最新价', '涨跌幅', '换手率']]
        except Exception as e:
            print(f"获取股票列表失败: {e}")
            return pd.DataFrame()
```

### 3. AKShare使用示例

```python
# 示例：获取平安银行数据
def demo_akshare():
    fetcher = AkshareDataFetcher()

    # 获取股票日线数据
    symbol = "000001.SZ"  # 平安银行
    end_date = datetime.now().strftime('%Y-%m-%d')
    start_date = (datetime.now() - timedelta(days=365)).strftime('%Y-%m-%d')

    stock_data = fetcher.get_stock_daily(symbol, start_date, end_date)
    print(f"获取到 {len(stock_data)} 条数据")
    print(stock_data.head())

    # 获取股票信息
    stock_info = fetcher.get_stock_info(symbol)
    print("\n股票基本信息:")
    print(stock_info)
```

## Tushare数据获取

### 1. Tushare配置

```python
import tushare as ts
import pandas as pd
from datetime import datetime, timedelta

class TushareDataFetcher:
    """Tushare数据获取器"""

    def __init__(self, token: str):
        self.name = "tushare"
        ts.set_token(token)
        self.pro = ts.pro_api()

    def get_stock_daily(self, symbol: str, start_date: str, end_date: str) -> pd.DataFrame:
        """获取股票日线数据"""
        try:
            # Tushare需要转换日期格式
            start_ts = start_date.replace('-', '')
            end_ts = end_date.replace('-', '')

            # 获取股票数据
            df = self.pro.daily(
                ts_code=symbol,
                start_date=start_ts,
                end_date=end_ts
            )

            # 按日期排序
            df = df.sort_values('trade_date')
            df['trade_date'] = pd.to_datetime(df['trade_date'])
            df.set_index('trade_date', inplace=True)

            # 重命名列
            df = df.rename(columns={
                'open': 'open',
                'close': 'close',
                'high': 'high',
                'low': 'low',
                'vol': 'volume',
                'amount': 'amount'
            })

            return df

        except Exception as e:
            print(f"获取Tushare数据失败: {e}")
            return pd.DataFrame()

    def get_stock_basic(self) -> pd.DataFrame:
        """获取股票基本信息"""
        try:
            return self.pro.stock_basic(
                exchange='',
                list_status='L',
                fields='ts_code,symbol,name,area,industry,market,list_date'
            )
        except Exception as e:
            print(f"获取股票基本信息失败: {e}")
            return pd.DataFrame()
```

## 数据获取管理器

### 1. 统一数据获取接口

```python
from abc import ABC, abstractmethod
from typing import Optional, Dict, Any
import pandas as pd

class DataFetcher(ABC):
    """数据获取器基类"""

    def __init__(self, name: str):
        self.name = name

    @abstractmethod
    def get_stock_daily(self, symbol: str, start_date: str, end_date: str) -> pd.DataFrame:
        """获取股票日线数据"""
        pass

    @abstractmethod
    def get_index_data(self, index_code: str, start_date: str, end_date: str) -> pd.DataFrame:
        """获取指数数据"""
        pass

class DataManager:
    """数据管理器"""

    def __init__(self, primary_fetcher: DataFetcher, backup_fetcher: Optional[DataFetcher] = None):
        self.primary_fetcher = primary_fetcher
        self.backup_fetcher = backup_fetcher
        self.cache = {}

    def get_stock_data(self, symbol: str, start_date: str, end_date: str,
                      use_cache: bool = True) -> pd.DataFrame:
        """获取股票数据，支持缓存和备用数据源"""

        # 检查缓存
        cache_key = f"{symbol}_{start_date}_{end_date}"
        if use_cache and cache_key in self.cache:
            print(f"从缓存获取数据: {symbol}")
            return self.cache[cache_key].copy()

        # 尝试从主数据源获取
        print(f"从 {self.primary_fetcher.name} 获取数据: {symbol}")
        data = self.primary_fetcher.get_stock_daily(symbol, start_date, end_date)

        # 如果主数据源失败且存在备用数据源
        if data.empty and self.backup_fetcher:
            print(f"主数据源失败，尝试从 {self.backup_fetcher.name} 获取数据")
            data = self.backup_fetcher.get_stock_daily(symbol, start_date, end_date)

        # 缓存数据
        if not data.empty and use_cache:
            self.cache[cache_key] = data.copy()

        return data

    def clear_cache(self):
        """清空缓存"""
        self.cache.clear()
        print("缓存已清空")
```

### 2. 数据获取工厂

```python
class DataFetcherFactory:
    """数据获取器工厂"""

    @staticmethod
    def create_fetcher(source: str, **kwargs) -> DataFetcher:
        """创建数据获取器"""
        if source == "akshare":
            return AkshareDataFetcher()
        elif source == "tushare":
            token = kwargs.get('token')
            if not token:
                raise ValueError("Tushare需要提供token")
            return TushareDataFetcher(token)
        else:
            raise ValueError(f"不支持的数据源: {source}")
```

## 数据存储

### 1. 数据库配置

```python
from sqlalchemy import create_engine, text
from sqlalchemy.types import String, Float, DateTime, Integer
import os

class DataStorage:
    """数据存储类"""

    def __init__(self, db_path: str = "data/storage/trading.db"):
        self.db_path = db_path
        self.engine = create_engine(f'sqlite:///{db_path}')
        self._init_database()

    def _init_database(self):
        """初始化数据库"""
        # 创建目录
        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)

        # 创建表
        self._create_tables()

    def _create_tables(self):
        """创建数据表"""
        # 股票日线数据表
        stock_daily_sql = """
        CREATE TABLE IF NOT EXISTS stock_daily (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            symbol TEXT NOT NULL,
            date TEXT NOT NULL,
            open REAL,
            high REAL,
            low REAL,
            close REAL,
            volume INTEGER,
            amount REAL,
            pct_change REAL,
            turnover REAL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            UNIQUE(symbol, date)
        )
        """

        # 指数数据表
        index_daily_sql = """
        CREATE TABLE IF NOT EXISTS index_daily (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            index_code TEXT NOT NULL,
            date TEXT NOT NULL,
            open REAL,
            high REAL,
            low REAL,
            close REAL,
            volume INTEGER,
            amount REAL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            UNIQUE(index_code, date)
        )
        """

        with self.engine.connect() as conn:
            conn.execute(text(stock_daily_sql))
            conn.execute(text(index_daily_sql))
            conn.commit()

    def save_stock_data(self, data: pd.DataFrame, symbol: str) -> bool:
        """保存股票数据"""
        try:
            data_copy = data.copy()
            data_copy['symbol'] = symbol
            data_copy.reset_index(inplace=True)
            data_copy['date'] = data_copy['date'].dt.strftime('%Y-%m-%d')

            data_copy.to_sql(
                'stock_daily',
                self.engine,
                if_exists='append',
                index=False,
                method='multi'
            )
            return True
        except Exception as e:
            print(f"保存数据失败: {e}")
            return False

    def load_stock_data(self, symbol: str, start_date: str = None,
                       end_date: str = None) -> pd.DataFrame:
        """加载股票数据"""
        try:
            query = "SELECT * FROM stock_daily WHERE symbol = ?"
            params = [symbol]

            if start_date:
                query += " AND date >= ?"
                params.append(start_date)

            if end_date:
                query += " AND date <= ?"
                params.append(end_date)

            query += " ORDER BY date"

            data = pd.read_sql(query, self.engine, params=params)

            if not data.empty:
                data['date'] = pd.to_datetime(data['date'])
                data.set_index('date', inplace=True)
                data.drop(['id', 'symbol', 'created_at'], axis=1, inplace=True)

            return data
        except Exception as e:
            print(f"加载数据失败: {e}")
            return pd.DataFrame()
```

## 数据质量检查

### 1. 数据验证器

```python
class DataValidator:
    """数据验证器"""

    @staticmethod
    def validate_stock_data(data: pd.DataFrame) -> Dict[str, Any]:
        """验证股票数据质量"""
        validation_result = {
            'is_valid': True,
            'errors': [],
            'warnings': [],
            'stats': {}
        }

        if data.empty:
            validation_result['is_valid'] = False
            validation_result['errors'].append("数据为空")
            return validation_result

        # 检查必需的列
        required_columns = ['open', 'high', 'low', 'close', 'volume']
        missing_columns = [col for col in required_columns if col not in data.columns]
        if missing_columns:
            validation_result['is_valid'] = False
            validation_result['errors'].append(f"缺少必需列: {missing_columns}")

        # 检查数据类型
        for col in required_columns:
            if col in data.columns and not pd.api.types.is_numeric_dtype(data[col]):
                validation_result['warnings'].append(f"列 {col} 不是数值类型")

        # 检查空值
        null_counts = data[required_columns].isnull().sum()
        if null_counts.any():
            validation_result['warnings'].append(f"发现空值: {null_counts[null_counts > 0].to_dict()}")

        # 检查异常值
        for col in ['open', 'high', 'low', 'close']:
            if col in data.columns:
                negative_count = (data[col] < 0).sum()
                if negative_count > 0:
                    validation_result['warnings'].append(f"列 {col} 有 {negative_count} 个负值")

        # 检查价格逻辑
        if all(col in data.columns for col in ['open', 'high', 'low', 'close']):
            # 检查 high >= max(open, close) 和 low <= min(open, close)
            invalid_high = (data['high'] < data[['open', 'close']].max(axis=1)).sum()
            invalid_low = (data['low'] > data[['open', 'close']].min(axis=1)).sum()

            if invalid_high > 0:
                validation_result['warnings'].append(f"发现 {invalid_high} 条价格逻辑错误（最高价过低）")
            if invalid_low > 0:
                validation_result['warnings'].append(f"发现 {invalid_low} 条价格逻辑错误（最低价过高）")

        # 统计信息
        validation_result['stats'] = {
            'total_rows': len(data),
            'date_range': {
                'start': data.index.min().strftime('%Y-%m-%d') if not data.empty else None,
                'end': data.index.max().strftime('%Y-%m-%d') if not data.empty else None
            },
            'missing_data_ratio': data.isnull().sum().sum() / (len(data) * len(data.columns))
        }

        return validation_result
```

## 使用示例

### 完整的数据获取流程

```python
def main():
    """主函数示例"""
    # 初始化数据获取器
    akshare_fetcher = DataFetcherFactory.create_fetcher("akshare")

    # 如果有Tushare token，可以创建备用数据源
    # tushare_fetcher = DataFetcherFactory.create_fetcher("tushare", token="your_token")

    # 创建数据管理器
    data_manager = DataManager(akshare_fetcher)

    # 创建数据存储
    storage = DataStorage()

    # 获取股票数据
    symbol = "000001.SZ"  # 平安银行
    end_date = datetime.now().strftime('%Y-%m-%d')
    start_date = (datetime.now() - timedelta(days=365)).strftime('%Y-%m-%d')

    # 获取数据
    stock_data = data_manager.get_stock_data(symbol, start_date, end_date)

    if not stock_data.empty:
        print(f"成功获取 {len(stock_data)} 条数据")
        print(stock_data.head())

        # 数据质量检查
        validator = DataValidator()
        validation_result = validator.validate_stock_data(stock_data)

        print("\n数据验证结果:")
        print(f"是否有效: {validation_result['is_valid']}")
        if validation_result['errors']:
            print(f"错误: {validation_result['errors']}")
        if validation_result['warnings']:
            print(f"警告: {validation_result['warnings']}")

        # 保存数据
        if validation_result['is_valid']:
            storage.save_stock_data(stock_data, symbol)
            print(f"数据已保存到数据库")
    else:
        print("获取数据失败")

if __name__ == "__main__":
    main()
```

## 数据更新策略

### 1. 定时更新

```python
import schedule
import time

class DataUpdater:
    """数据更新器"""

    def __init__(self, data_manager: DataManager, storage: DataStorage):
        self.data_manager = data_manager
        self.storage = storage

    def update_stocks(self, symbols: list):
        """更新指定股票数据"""
        end_date = datetime.now().strftime('%Y-%m-%d')
        start_date = (datetime.now() - timedelta(days=7)).strftime('%Y-%m-%d')  # 更新最近7天

        for symbol in symbols:
            print(f"更新股票数据: {symbol}")
            data = self.data_manager.get_stock_data(symbol, start_date, end_date, use_cache=False)

            if not data.empty:
                # 检查数据是否已存在
                existing_data = self.storage.load_stock_data(symbol, start_date, end_date)

                if existing_data.empty:
                    # 全新数据
                    self.storage.save_stock_data(data, symbol)
                    print(f"保存新数据: {len(data)} 条")
                else:
                    # 增量更新
                    new_data = data[~data.index.isin(existing_data.index)]
                    if not new_data.empty:
                        self.storage.save_stock_data(new_data, symbol)
                        print(f"增量更新: {len(new_data)} 条")
                    else:
                        print("没有新数据需要更新")

    def schedule_update(self, symbols: list, time_str: str = "09:30"):
        """设置定时更新"""
        schedule.every().day.at(time_str).do(self.update_stocks, symbols)
        print(f"已设置定时更新: 每天 {time_str}")

        while True:
            schedule.run_pending()
            time.sleep(60)  # 每分钟检查一次
```

## 性能优化

### 1. 批量数据获取

```python
def batch_get_stock_data(symbols: list, start_date: str, end_date: str) -> Dict[str, pd.DataFrame]:
    """批量获取股票数据"""
    data_manager = DataManager(AkshareDataFetcher())
    results = {}

    for i, symbol in enumerate(symbols):
        print(f"获取数据 {i+1}/{len(symbols)}: {symbol}")
        data = data_manager.get_stock_data(symbol, start_date, end_date)

        if not data.empty:
            results[symbol] = data
        else:
            print(f"获取数据失败: {symbol}")

    return results
```

### 2. 异步数据获取

```python
import asyncio
import aiohttp
import json

class AsyncDataFetcher:
    """异步数据获取器"""

    async def fetch_multiple_data(self, symbols: list) -> Dict[str, pd.DataFrame]:
        """异步获取多个股票数据"""
        tasks = [self.fetch_single_data(symbol) for symbol in symbols]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        return dict(zip(symbols, results))

    async def fetch_single_data(self, symbol: str) -> pd.DataFrame:
        """异步获取单个股票数据"""
        # 这里需要根据具体API实现异步调用
        # 示例代码，需要根据实际情况调整
        pass
```

## 常见问题

### 1. 数据获取失败
- 检查网络连接
- 验证API token是否有效
- 检查股票代码格式

### 2. 数据质量问题
- 使用数据验证器检查
- 对异常数据进行清洗
- 设置数据获取重试机制

### 3. 存储空间不足
- 定期清理历史数据
- 使用数据压缩
- 考虑使用更高效的存储格式

## 下一步

完成数据获取模块后，您可以：
1. 学习[技术指标计算](05-技术指标.md)
2. 开始[策略开发](06-策略开发.md)
3. 运行[回测系统](07-回测系统.md)