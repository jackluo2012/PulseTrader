# 2.3 Python-Rusté›†æˆ

## ğŸ“– æœ¬èŠ‚æ¦‚è¿°

æœ¬èŠ‚å°†æ„å»ºPythonå’ŒRustçš„æ— ç¼é›†æˆæ¥å£ï¼Œä½¿ç”¨PyO3å’ŒMaturinå®ç°Pythonç»‘å®šï¼Œè®©Pythonä»£ç èƒ½å¤Ÿè°ƒç”¨Rustçš„é«˜æ€§èƒ½æ•°æ®å¤„ç†æ¨¡å—ï¼ŒåŒæ—¶ä¿æŒPythonç”Ÿæ€ç³»ç»Ÿçš„æ˜“ç”¨æ€§å’Œçµæ´»æ€§ã€‚

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬èŠ‚å­¦ä¹ åï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š
- âœ… ä½¿ç”¨PyO3åˆ›å»ºPython-Rustç»‘å®š
- âœ… é…ç½®Maturinæ„å»ºç³»ç»Ÿ
- âœ… å®ç°é«˜æ€§èƒ½çš„Pythonæ¥å£
- âœ… å¤„ç†Pythonå’ŒRustä¹‹é—´çš„æ•°æ®è½¬æ¢
- âœ… å»ºç«‹é”™è¯¯å¤„ç†å’Œå¼‚å¸¸ç®¡ç†æœºåˆ¶

## â±ï¸ é¢„è®¡æ—¶é—´ï¼š40-50åˆ†é’Ÿ

---

## ğŸ”— PyO3ç»‘å®šå¼€å‘

### 1. åˆ›å»ºPythonç»‘å®šæ¨¡å—

**rust/src/python/mod.rs**
```rust
//! Pythonç»‘å®šæ¨¡å—

use pyo3::prelude::*;
use pyo3::{PyResult, Python, pymodule, PyResult as PyResultPyO3};
use anyhow::Result;

pub mod bindings;
pub mod exceptions;

// é‡æ–°å¯¼å‡ºä¸»è¦æ¥å£
pub use bindings::{
    TDXParser,
    DataProcessor,
    IndicatorCalculator,
    EnhancedDayRecordPy,
    get_pandas_dataframe,
    save_to_clickhouse,
};

pub use exceptions::{PulseTraderError, PulseTraderResult};

/// åˆ›å»ºPythonæ¨¡å—
#[pymodule]
fn pulse_trader_rust(m: &Python, m: &PyModule) -> PyResult<()> {
    pyo3_env_logger::init();

    m.add_class::<TDXParser>()?;
    m.add_class::<DataProcessor>()?;
    m.add_class::<IndicatorCalculator>()?;
    m.add_class::<EnhancedDayRecordPy>()?;

    // æ·»åŠ å‡½æ•°
    m.add_function(wrap_pyfunction!(get_pandas_dataframe))?;
    m.add_function(wrap_pyfunction!(save_to_clickhouse))?;
    m.add_function(wrap_pyfunction!(parse_tdx_data))?;
    m.add_function(wrap_pyfunction!(calculate_indicators))?;
    m.add_function(wrap_pyfunction!(clean_data))?;

    // æ·»åŠ å¼‚å¸¸ç±»
    m.add("PulseTraderError", m.get_type::<PulseTraderError>())?;

    // æ·»åŠ æ¨¡å—ä¿¡æ¯
    m.add("__version__", env!("CARGO_PKG_VERSION"))?;
    m.add("__author__", env!("CARGO_PKG_AUTHORS"))?;
    m.add("__doc__", env!("CARGO_PKG_DESCRIPTION"))?;

    Ok(())
}
```

### 2. å¼‚å¸¸å¤„ç†æ¨¡å—

**rust/src/python/exceptions.rs**
```rust
//! å¼‚å¸¸å¤„ç†æ¨¡å—

use pyo3::create_exception;
use pyo3::exceptions::PyException;
use pyo3::Python;
use pyo3::PyResult as PyResultPyO3;

/// PulseTraderè‡ªå®šä¹‰å¼‚å¸¸
#[pyclass(extends = PyException)]
#[derive(Debug)]
pub struct PulseTraderError {
    #[pyo3(get)]
    msg: String,
}

impl PulseTraderError {
    pub fn new(msg: String) -> Self {
        Self { msg }
    }
}

/// Rust Resultåˆ°Python Resultçš„è½¬æ¢
pub type PyResult<T> = std::result::Result<T, PulseTraderError>;

impl<T> From<anyhow::Error> for PulseTraderError {
    fn from(err: anyhow::Error) -> Self {
        PulseTraderError {
            msg: err.to_string(),
        }
    }
}

impl<T> From<PulseTraderError> for PyResultPyO3<T> {
    fn from(err: PulseTraderError) -> Self {
        PyErr::new::<PulseTraderError, _>(err)
    }
}

/// Rust Resultåˆ°Python Resultçš„ä¾¿æ·è½¬æ¢
pub trait IntoPyResult<T> {
    fn into_py_result(self) -> PyResult<T>;
}

impl<T> IntoPyResult<T> for Result<T> {
    fn into_py_result(self) -> PyResult<T> {
        self.map_err(IntoPyResult::into_py_result)
    }
}
```

### 3. Pythonç»‘å®šçš„ä¸»è¦æ¥å£

**rust/src/python/bindings.rs**
```rust
//! Pythonç»‘å®šæ¥å£

use pyo3::prelude::*;
use pyo3::types::{PyDict, PyList, PyTuple};
use pyo3::{Python, PyResult, IntoPyPointer};
use std::collections::HashMap;

use crate::parsers::{TDXDayParser, TDXDayRecord, TDXStatistics};
use crate::processors::{DataCleaner, DataProcessor, IndicatorCalculator, EnhancedDayRecord};
use crate::storage::{ClickHouseWriter, BatchWriter};
use crate::python::{PyResult, IntoPyResult};

/// é€šè¾¾ä¿¡è§£æå™¨Pythonç»‘å®š
#[pyclass]
pub struct TDXParser {
    #[pyo3(get)]
    data_root: String,
    parser: TDXDayParser,
}

#[pymethods]
impl TDXParser {
    /// åˆ›å»ºæ–°çš„è§£æå™¨
    #[new]
    fn __new__(py: Python, data_root: &str) -> PyResult<Self> {
        let parser = TDXDayParser::new(data_root);
        Ok(Self {
            data_root: data_root.to_string(),
            parser,
        })
    }

    /// è§£æå•ä¸ªæ–‡ä»¶
    fn parse_file(&self, py: Python, file_path: &str) -> PyResult<Vec<EnhancedDayRecordPy>> {
        python::allow_threads(py, || {
            let records = self.parser.parse_file(file_path).into_py_result()?;

            // è½¬æ¢ä¸ºPythonå¯¹è±¡
            records
                .into_iter()
                .map(|record| EnhancedDayRecordPy::from_record(record))
                .collect()
        })
    }

    /// è§£æç›®å½•ä¸‹çš„æ‰€æœ‰æ–‡ä»¶
    fn parse_directory(&self, py: Python, dir_path: &str) -> PyResult<Vec<EnhancedDayRecordPy>> {
        python::allow_threads(py, || {
            let records = self.parser.parse_directory(dir_path).into_py_result()?;

            // è½¬æ¢ä¸ºPythonå¯¹è±¡
            records
                .into_iter()
                .map(|record| EnhancedDayRecordPy::from_record(record))
                .collect()
        })
    }

    /// è·å–æ‰€æœ‰è‚¡ç¥¨åˆ—è¡¨
    fn get_stock_list(&self, py: Python) -> PyResult<Vec<(String, String)>> {
        python::allow_threads(py, || {
            self.parser.get_stock_list().into_py_result()
        })
    }

    /// è·å–æŒ‡å®šæ—¥æœŸçš„æ•°æ®
    fn get_data_by_date(&self, py: Python, date_str: &str) -> PyResult<Vec<EnhancedDayRecordPy>> {
        python::allow_threads(py, || {
            let date = chrono::NaiveDate::parse_from_str(date_str, "%Y-%m-%d")
                .map_err(|e| PulseTraderError::new(format!("Invalid date format: {}", e)))?;

            let records = self.parser.get_data_by_date(date).into_py_result()?;

            // è½¬æ¢ä¸ºPythonå¯¹è±¡
            records
                .into_iter()
                .map(|record| EnhancedDayRecordPy::from_record(record))
                .collect()
        })
    }

    /// è·å–æŒ‡å®šè‚¡ç¥¨çš„æ•°æ®
    fn get_data_by_symbol(
        &self,
        py: Python,
        symbol: &str,
        market: &str,
    ) -> PyResult<Vec<EnhancedDayRecordPy>> {
        python::allow_threads(py, || {
            let records = self.parser.get_data_by_symbol(symbol, market).into_py_result()?;

            // è½¬æ¢ä¸ºPythonå¯¹è±¡
            records
                .into_iter()
                .map(|record| EnhancedDayRecordPy::from_record(record))
                .collect()
        })
    }

    /// è·å–ç»Ÿè®¡ä¿¡æ¯
    fn get_statistics(&self, py: Python) -> PyResult<TDXStatisticsPy> {
        python::allow_threads(py, || {
            let stats = self.parser.get_statistics().into_py_result()?;
            Ok(TDXStatisticsPy::from_statistics(stats))
        })
    }

    /// æ£€æŸ¥æ–‡ä»¶å®Œæ•´æ€§
    fn check_file_integrity(&self, py: Python, file_path: &str) -> PyResult<bool> {
        python::allow_threads(py, || {
            // ç®€åŒ–å®ç°ï¼šæ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨ä¸”å¯è¯»
            std::path::Path::new(file_path).exists()
        })
    }

    /// éªŒè¯æ•°æ®æ ¼å¼
    fn validate_data(&self, py: Python, records: &PyList) -> PyResult<bool> {
        python::allow_threads(py, || {
            let mut valid_count = 0;

            for record in records {
                let py_record = record.extract::<EnhancedDayRecordPy>()?;
                if py_record.is_valid() {
                    valid_count += 1;
                }
            }

            Ok(valid_count == records.len())
        })
    }
}

/// æ•°æ®å¤„ç†å™¨Pythonç»‘å®š
#[pyclass]
pub struct DataProcessor {
    #[pyo3(get)]
    concurrency_limit: usize,
    processor: DataProcessor,
}

#[pymethods]
impl DataProcessor {
    /// åˆ›å»ºæ–°çš„æ•°æ®å¤„ç†å™¨
    #[new]
    fn __new__(concurrency_limit: usize) -> Self {
        let processor = DataProcessor::new(concurrency_limit, 1024 * 1024 * 1024);
        Self {
            concurrency_limit,
            processor,
        }
    }

    /// æ¸…æ´—æ•°æ®
    fn clean_data(&self, py: Python, records: Vec<EnhancedDayRecordPy>) -> PyResult<CleaningResultPy> {
        python::allow_threads(py, || {
            // è½¬æ¢ä¸ºRustè®°å½•
            let rust_records: Vec<TDXDayRecord> = records
                .into_iter()
                .map(|record| record.into_rust_record())
                .collect();

            // åˆ›å»ºæ¸…æ´—å™¨å¹¶æ¸…æ´—æ•°æ®
            let mut cleaner = DataCleaner::default();
            let result = cleaner.clean(rust_records).into_py_result()?;

            Ok(CleaningResultPy::from_result(result))
        })
    }

    /// å¹¶è¡Œå¤„ç†æ•°æ®
    fn process_parallel(
        &self,
        py: Python,
        records: Vec<EnhancedDayRecordPy>,
        batch_size: Option<usize>,
    ) -> PyResult<Vec<EnhancedDayRecordPy>> {
        python::allow_threads(py, || {
            // è½¬æ¢ä¸ºRustè®°å½•
            let rust_records: Vec<TDXDayRecord> = records
                .into_iter()
                .map(|record| record.into_rust_record())
                .collect();

            // å¹¶è¡Œå¤„ç†
            let processed_records = self.processor.process_parallel(
                rust_records,
                |record: TDXDayRecord| -> Result<TDXDayRecord> {
                    // ç®€åŒ–å¤„ç†ï¼šç›´æ¥è¿”å›
                    Ok(record)
                },
            )?;

            // è½¬æ¢å›Pythonå¯¹è±¡
            Ok(processed_records
                .into_iter()
                .map(|record| EnhancedDayRecordPy::from_record(&record))
                .collect())
        })
    }
}

/// æŠ€æœ¯æŒ‡æ ‡è®¡ç®—å™¨Pythonç»‘å®š
#[pyclass]
pub struct IndicatorCalculator {
    #[pyo3(get)]
    window_sizes: Vec<usize>,
    calculator: IndicatorCalculator,
}

#[pymethods]
impl IndicatorCalculator {
    /// åˆ›å»ºæ–°çš„æŒ‡æ ‡è®¡ç®—å™¨
    #[new]
    #[kwargs]
    fn __new__(
        window_sizes: Option<Vec<usize>>,
    ) -> Self {
        let calculator = if let Some(sizes) = window_sizes {
            IndicatorCalculator::new().with_window_sizes(sizes)
        } else {
            IndicatorCalculator::new()
        };

        Self {
            window_sizes: calculator.window_sizes.clone(),
            calculator,
        }
    }

    /// è®¡ç®—æ‰€æœ‰æŠ€æœ¯æŒ‡æ ‡
    fn calculate_all_indicators(&self, py: Python, records: Vec<EnhancedDayRecordPy>) -> PyResult<Vec<EnhancedDayRecordPy>> {
        python::allow_threads(py, || {
            // è½¬æ¢ä¸ºRustè®°å½•
            let rust_records: Vec<TDXDayRecord> = records
                .into_iter()
                .map(|record| record.into_rust_record())
                .collect();

            // è®¡ç®—æŒ‡æ ‡
            let enhanced_records = self.calculator.calculate_all_indicators(&rust_records).into_py_result()?;

            // è½¬æ¢ä¸ºPythonå¯¹è±¡
            Ok(enhanced_records
                .into_iter()
                .map(|record| EnhancedDayRecordPy::from_enhanced_record(&record))
                .collect())
        })
    }

    /// å¹¶è¡Œè®¡ç®—æŒ‡æ ‡
    fn calculate_parallel(&self, py: Python, records: Vec<EnhancedDayRecordPy>) -> PyResult<Vec<EnhancedDayRecordPy>> {
        python::allow_threads(py, || {
            // è½¬æ¢ä¸ºRustè®°å½•
            let rust_records: Vec<TDXDayRecord> = records
                .into_iter()
                .map(|record| record.into_rust_record())
                .collect();

            // å¹¶è¡Œè®¡ç®—
            let enhanced_records = self.calculator.calculate_parallel(&rust_records).into_py_result()?;

            // è½¬æ¢ä¸ºPythonå¯¹è±¡
            Ok(enhanced_records
                .into_iter()
                .map(|record| EnhancedDayRecordPy::from_enhanced_record(&record))
                .collect())
        })
    }

    /// è®¡ç®—æŒ‡å®šæŒ‡æ ‡çš„å¿«é€Ÿæ–¹æ³•
    fn calculate_ma(
        &self,
        py: Python,
        prices: Vec<f64>,
        period: usize,
    ) -> PyResult<f64> {
        python::allow_threads(py, || {
            let calculator = IndicatorCalculator::new();
            let ma = calculator.calculate_ma(&prices);
            Ok(ma)
        })
    }

    /// è®¡ç®—RSI
    fn calculate_rsi(&self, py: Python, closes: Vec<f64>) -> PyResult<f64> {
        python::allow_threads(py, || {
            let calculator = IndicatorCalculator::new();
            let rsi = calculator.calculate_rsi(&closes);
            Ok(rsi)
        })
    }
}

/// å¢å¼ºæ—¥çº¿è®°å½•PythonåŒ…è£…å™¨
#[pyclass]
#[derive(Clone)]
pub struct EnhancedDayRecordPy {
    #[pyo3(get)]
    pub symbol: String,
    #[pyo3(get)]
    pub date: String,
    #[pyo3(get)]
    pub open: f64,
    #[pyo3(get)]
    pub high: f64,
    #[pyo3(get)]
    pub low: f64,
    #[pyo3(get)]
    pub close: f64,
    #[pyo3(get)]
    pub volume: u64,
    #[pyo3(get)]
    pub amount: f64,
    #[pyo3(get)]
    pub market: String,

    // æŠ€æœ¯æŒ‡æ ‡
    #[pyo3(get, set)]
    pub ma5: Option<f64>,
    #[pyo3(get, set)]
    pub ma10: Option<f64>,
    #[pyo3(get, set)]
    pub ma20: Option<f64>,
    #[pyo3(get, set)]
    pub ma60: Option<f64>,
    #[pyo3(get, set)]
    pub rsi: Option<f64>,
    #[pyo3(get, set)]
    pub change_percent: Option<f64>,
    #[pyo3(get, set)]
    pub amplitude: Option<f64>,
}

impl EnhancedDayRecordPy {
    /// ä»åŸºç¡€è®°å½•åˆ›å»ºPythonåŒ…è£…å™¨
    pub fn from_record(record: &TDXDayRecord) -> Self {
        Self {
            symbol: record.symbol.clone(),
            date: record.date.to_string(),
            open: record.open,
            high: record.high,
            low: record.low,
            close: record.close,
            volume: record.volume,
            amount: record.amount,
            market: record.market.clone(),
            ma5: None,
            ma10: None,
            ma20: None,
            ma60: None,
            rsi: None,
            change_percent: None,
            amplitude: None,
        }
    }

    /// ä»å¢å¼ºè®°å½•åˆ›å»ºPythonåŒ…è£…å™¨
    pub fn from_enhanced_record(record: &EnhancedDayRecord) -> Self {
        let base = &record.base_record;
        let indicators = &record.indicators;

        Self {
            symbol: base.symbol.clone(),
            date: base.date.to_string(),
            open: base.open,
            high: base.high,
            low: base.low,
            close: base.close,
            volume: base.volume,
            amount: base.amount,
            market: base.market.clone(),
            ma5: indicators.ma5,
            ma10: indicators.ma10,
            ma20: indicators.ma20,
            ma60: indicators.ma60,
            rsi: indicators.rsi,
            change_percent: indicators.change_percent,
            amplitude: indicators.amplitude,
        }
    }

    /// è½¬æ¢ä¸ºRuståŸºç¡€è®°å½•
    pub fn into_rust_record(self) -> TDXDayRecord {
        TDXDayRecord {
            date: chrono::NaiveDate::parse_from_str(&self.date, "%Y-%m-%d")
                .expect("Invalid date format"),
            symbol: self.symbol,
            open: self.open,
            high: self.high,
            low: self.low,
            close: self.close,
            volume: self.volume,
            amount: self.amount,
            market: self.market,
        }
    }

    /// éªŒè¯è®°å½•æœ‰æ•ˆæ€§
    pub fn is_valid(&self) -> bool {
        // åŸºæœ¬éªŒè¯
        if self.symbol.is_empty() || self.market.is_empty() {
            return false;
        }

        // ä»·æ ¼éªŒè¯
        if self.open <= 0.0 || self.high <= 0.0 || self.low <= 0.0 || self.close <= 0.0 {
            return false;
        }

        // ä»·æ ¼å…³ç³»éªŒè¯
        if self.high < self.low {
            return false;
        }

        if self.open > self.high || self.open < self.low {
            return false;
        }

        if self.close > self.high || self.close < self.low {
            return false;
        }

        // æˆäº¤é‡éªŒè¯
        if self.volume == 0 {
            return false;
        }

        true
    }

    /// è·å–è®°å½•çš„å­—å…¸è¡¨ç¤º
    fn to_dict(&self) -> PyResult<HashMap<String, String>> {
        let mut dict = HashMap::new();

        dict.insert("symbol".to_string(), self.symbol.clone());
        dict.insert("date".to_string(), self.date.clone());
        dict.insert("open".to_string(), format!("{:.4}", self.open));
        dict.insert("high".to_string(), format!("{:.4}", self.high));
        dict.insert("low".to_string(), format!("{:.4}", self.low));
        dict.insert("close".to_string(), format!("{:.4}", self.close));
        dict.insert("volume".to_string(), self.volume.to_string());
        dict.insert("amount".to_string(), format!("{:.2}", self.amount));
        dict.insert("market".to_string(), self.market.clone());

        // æŠ€æœ¯æŒ‡æ ‡
        if let Some(ma5) = self.ma5 {
            dict.insert("ma5".to_string(), format!("{:.4}", ma5));
        }
        if let Some(ma10) = self.ma10 {
            dict.insert("ma10".to_string(), format!("{:.4}", ma10));
        }
        if let Some(rsi) = self.rsi {
            dict.insert("rsi".to_string(), format!("{:.2}", rsi));
        }

        Ok(dict)
    }

    /// ä»å­—å…¸åˆ›å»ºè®°å½•
    #[staticmethod]
    fn from_dict(dict: &PyDict) -> PyResult<Self> {
        let symbol = dict.get_item("symbol")?.extract::<String>()?;
        let date = dict.get_item("date")?.extract::<String>()?;
        let open = dict.get_item("open")?.extract::<f64>()?;
        let high = dict.get_item("high")?.extract::<f64>()?;
        let low = dict.get_item("low")?.extract::<f64>()?;
        let close = dict.get_item("close")?.extract::<f64>()?;
        let volume = dict.get_item("volume")?.extract::<u64>()?;
        let amount = dict.get_item("amount")?.extract::<f64>()?;
        let market = dict.get_item("market")?.extract::<String>()?;

        let mut record = Self {
            symbol,
            date,
            open,
            high,
            low,
            close,
            volume,
            amount,
            market,
            ma5: None,
            ma10: None,
            ma20: None,
            ma60: None,
            rsi: None,
            change_percent: None,
            amplitude: None,
        };

        // å¯é€‰å­—æ®µ
        if let Ok(ma5) = dict.get_item("ma5").and_then(|v| v.extract::<f64>()) {
            record.ma5 = Some(ma5);
        }
        if let Ok(ma10) = dict.get_item("ma10").and_then(|v| v.extract::<f64>()) {
            record.ma10 = Some(ma10);
        }
        if let Ok(ma20) = dict.get_item("ma20").and_then(|v| v.extract::<f64>()) {
            record.ma20 = Some(ma20);
        }
        if let Ok(ma60) = dict.get_item("ma60").and_then(|v| v.extract::<f64>()) {
            record.ma60 = Some(ma60);
        }
        if let Ok(rsi) = dict.get_item("rsi").and_then(|v| v.extract::<f64>()) {
            record.rsi = Some(rsi);
        }

        Ok(record)
    }

    /// å­—ç¬¦ä¸²è¡¨ç¤º
    fn __str__(&self) -> String {
        format!(
            "EnhancedDayRecord(symbol={}, date={}, close={:.2}, volume={})",
            self.symbol,
            self.date,
            self.close,
            self.volume
        )
    }

    /// è°ƒè¯•è¡¨ç¤º
    fn __repr__(&self) -> PyResult<String> {
        Ok(self.__str__())
    }
}

/// æ¸…æ´—ç»“æœPythonåŒ…è£…å™¨
#[pyclass]
#[derive(Clone)]
pub struct CleaningResultPy {
    #[pyo3(get)]
    pub original_count: usize,
    #[pyo3(get)]
    pub cleaned_count: usize,
    #[pyo3(get)]
    pub removed_count: usize,
    #[pyo3(get)]
    pub applied_rules: Vec<String>,
}

impl CleaningResultPy {
    /// ä»Rustç»“æœåˆ›å»ºPythonåŒ…è£…å™¨
    pub fn from_result(result: crate::processors::CleaningResult) -> Self {
        Self {
            original_count: result.original_count,
            cleaned_count: result.cleaned_count,
            removed_count: result.removed_count,
            applied_rules: result.applied_rules,
        }
    }

    /// è·å–æ¸…æ´—ç‡
    fn get_cleaning_rate(&self) -> f64 {
        if self.original_count == 0 {
            0.0
        } else {
            (self.cleaned_count as f64) / (self.original_count as f64)
        }
    }

    /// å­—ç¬¦ä¸²è¡¨ç¤º
    fn __str__(&self) -> String {
        format!(
            "CleaningResult(original={}, cleaned={}, removed={}, rules={})",
            self.original_count,
            self.cleaned_count,
            self.removed_count,
            self.applied_rules.len()
        )
    }

    /// è°ƒè¯•è¡¨ç¤º
    fn __repr__(&self) -> PyResult<String> {
        Ok(self.__str__())
    }
}

/// ç»Ÿè®¡ä¿¡æ¯PythonåŒ…è£…å™¨
#[pyclass]
#[derive(Clone)]
pub struct TDXStatisticsPy {
    #[pyo3(get)]
    pub total_stocks: usize,
    #[pyo3(get)]
    pub total_records: usize,
    #[pyo3(get)]
    pub sh_count: usize,
    #[pyo3(get)]
    pub sz_count: usize,
    #[pyo3(get)]
    pub earliest_date: Option<String>,
    #[pyo3(get)]
    pub latest_date: Option<String>,
    #[pyo3(get)]
    pub data_size_mb: f64,
}

impl TDXStatisticsPy {
    /// ä»Rustç»Ÿè®¡ä¿¡æ¯åˆ›å»ºPythonåŒ…è£…å™¨
    pub fn from_statistics(stats: TDXStatistics) -> Self {
        Self {
            total_stocks: stats.total_stocks,
            total_records: stats.total_records,
            sh_count: stats.sh_count,
            sz_count: stats.sz_count,
            earliest_date: stats.earliest_date.map(|d| d.to_string()),
            latest_date: stats.latest_date.map(|d| d.to_string()),
            data_size_mb: stats.data_size_bytes as f64 / (1024.0 * 1024.0),
        }
    }

    /// å­—ç¬¦ä¸²è¡¨ç¤º
    fn __str__(&self) -> String {
        format!(
            "TDXStatistics(stocks={}, records={}, sh={}, sz={}, size={:.2}MB)",
            self.total_stocks,
            self.total_records,
            self.sh_count,
            self.sz_count,
            self.data_size_mb
        )
    }

    /// è°ƒè¯•è¡¨ç¤º
    fn __repr__(&self) -> PyResult<String> {
        Ok(self.__str__())
    }
}
```

---

## ğŸ Pandasé›†æˆæ¥å£

### 1. åˆ›å»ºPandasè½¬æ¢å·¥å…·

**rust/src/python/pandas_integration.rs**
```rust
//! Pandasé›†æˆæ¨¡å—

use pyo3::prelude::*;
use pyo3::{Python, PyResult, IntoPyPointer};
use numpy::{IntoPyArray, PyArray1, PyArrayDyn};

use crate::python::{PyResult, EnhancedDayRecordPy};

/// å°†è®°å½•åˆ—è¡¨è½¬æ¢ä¸ºPandas DataFrame
#[pyfunction]
pub fn get_pandas_dataframe(py: Python, records: Vec<EnhancedDayRecordPy>) -> PyResult<&pyo3::types::PyAny> {
    // å¯¼å…¥pandas
    let pandas = py.import("pandas")?;

    // æå–æ•°æ®åˆ—
    let symbols: Vec<String> = records.iter().map(|r| r.symbol.clone()).collect();
    let dates: Vec<String> = records.iter().map(|r| r.date.clone()).collect();
    let opens: Vec<f64> = records.iter().map(|r| r.open).collect();
    let highs: Vec<f64> = records.iter().map(|r| r.high).collect();
    let lows: Vec<f64> = records.iter().map(|r| r.low).collect();
    let closes: Vec<f64> = records.iter().map(|r| r.close).collect();
    let volumes: Vec<u64> = records.iter().map(|r| r.volume).collect();
    let amounts: Vec<f64> = records.iter().map(|r| r.amount).collect();
    let markets: Vec<String> = records.iter().map(|r| r.market.clone()).collect();

    // åˆ›å»ºæ•°æ®å­—å…¸
    let data = pyo3::types::PyDict::new(py);
    data.set_item("symbol", symbols.into_pyarray(py))?;
    data.set_item("date", dates.into_pyarray(py))?;
    data.set_item("open", opens.into_pyarray(py))?;
    data.set_item("high", highs.into_pyarray(py))?;
    data.set_item("low", lows.into_pyarray(py))?;
    data.set_item("close", closes.into_pyarray(py))?;
    data.set_item("volume", volumes.into_pyarray(py))?;
    data.set_item("amount", amounts.into_pyarray(py))?;
    data.set_item("market", markets.into_pyarray(py))?;

    // æŠ€æœ¯æŒ‡æ ‡åˆ—
    let ma5_exists = records.iter().any(|r| r.ma5.is_some());
    if ma5_exists {
        let ma5_values: Vec<f64> = records
            .iter()
            .map(|r| r.ma5.unwrap_or(0.0))
            .collect();
        data.set_item("ma5", ma5_values.into_pyarray(py))?;
    }

    let ma10_exists = records.iter().any(|r| r.ma10.is_some());
    if ma10_exists {
        let ma10_values: Vec<f64> = records
            .iter()
            .map(|r| r.ma10.unwrap_or(0.0))
            .collect();
        data.set_item("ma10", ma10_values.into_pyarray(py))?;
    }

    let rsi_exists = records.iter().any(|r| r.rsi.is_some());
    if rsi_exists {
        let rsi_values: Vec<f64> = records
            .iter()
            .map(|r| r.rsi.unwrap_or(50.0))
            .collect();
        data.set_item("rsi", rsi_values.into_pyarray(py))?;
    }

    // åˆ›å»ºDataFrame
    let df = pandas.call_method("DataFrame", (data,), None)?;
    Ok(df)
}

/// å°†DataFrameä¿å­˜åˆ°æ–‡ä»¶
#[pyfunction]
pub fn save_dataframe(
    py: Python,
    df: &pyo3::types::PyAny,
    file_path: &str,
    format: Option<&str>,
) -> PyResult<()> {
    let format = format.unwrap_or("csv", "csv");

    match format {
        "csv" => {
            df.call_method("to_csv", (file_path, py.None()), None)?;
        }
        "parquet" => {
            let pyarrow = py.import("pyarrow.parquet")?;
            let table = pyarrow.call_method("Table", (df,), None)?;
            table.call_method("write_parquet", (file_path,), None)?;
        }
        "json" => {
            df.call_method("to_json", (file_path, py.None(), py.None()), None)?;
        }
        "excel" => {
            df.call_method("to_excel", (file_path, py.None()), None)?;
        }
        _ => {
            return Err(PulseTraderError::new(format!("Unsupported format: {}", format)).into_py_result());
        }
    }

    Ok(())
}

/// ä»Pandas DataFrameåˆ›å»ºè®°å½•åˆ—è¡¨
#[pyfunction]
pub fn dataframe_to_records(
    py: Python,
    df: &pyo3::types::PyAny,
) -> PyResult<Vec<EnhancedDayRecordPy>> {
    let symbols = df.get_item("symbol")?.downcast::<PyArrayDyn<f64>>()?.to_vec()?;
    let dates = df.get_item("date")?.downcast::<PyArrayDyn<u8>>()?.to_vec()?;
    let opens = df.get_item("open")?.downcast::<PyArrayDyn<f64>>()?.to_vec()?;
    let highs = df.get_item("high")?.downcast::<PyArrayDyn<f64>>()?.to_vec()?;
    let lows = df.get_item("low")?.downcast::<PyArrayDyn<f64>>()?.to_vec()?;
    let closes = df.get_item("close")?.downcast::<PyArrayDyn<f64>>()?.to_vec()?;
    let volumes = df.get_item("volume")?.downcast::<PyArrayDyn<f64>>()?.to_vec()?;
    let amounts = df.get_item("amount")?.downcast::<PyArrayDyn<f64>>()?.to_vec()?;
    let markets = df.get_item("market")?.downcast::<PyArrayDyn<u8>>()?.to_vec()?;

    let mut records = Vec::with_capacity(symbols.len());

    for i in 0..symbols.len() {
        // æå–å­—ç¬¦ä¸²æ•°æ®
        let symbol = String::from_utf8_lossy(&symbols[i]);
        let date = String::from_utf8_lossy(&dates[i]);
        let market = String::from_utf8_lossy(&markets[i]);

        let record = EnhancedDayRecordPy {
            symbol: symbol.to_string(),
            date: date.to_string(),
            open: opens[i],
            high: highs[i],
            low: lows[i],
            close: closes[i],
            volume: volumes[i] as u64,
            amount: amounts[i],
            market: market.to_string(),
            ma5: None,
            ma10: None,
            ma20: None,
            ma60: None,
            rsi: None,
            change_percent: None,
            amplitude: None,
        };

        records.push(record);
    }

    Ok(records)
}

/// å¿«é€Ÿæ•°æ®èšåˆå‡½æ•°
#[pyfunction]
pub fn aggregate_data(
    py: Python,
    records: Vec<EnhancedDayRecordPy>,
    group_by: &str,
    agg_func: &str,
) -> PyResult<pyo3::types::PyAny> {
    let pandas = py.import("pandas")?;
    let numpy = py.import("numpy")?;

    // è½¬æ¢ä¸ºDataFrame
    let df = get_pandas_dataframe(py, records)?;

    // æ ¹æ®åˆ†ç»„å­—æ®µå’Œèšåˆå‡½æ•°è¿›è¡Œèšåˆ
    match group_by {
        "symbol" => {
            match agg_func {
                "mean" => {
                    let group_cols = vec!["symbol"];
                    let agg_cols = vec!["open", "high", "low", "close", "volume", "amount"];

                    let grouped = df.call_method("groupby", (group_cols,), None)?;
                    let agg_dict = pyo3::types::PyDict::from_sequence([
                        ("open", "mean"),
                        ("high", "mean"),
                        ("low", "mean"),
                        ("close", "mean"),
                        ("volume", "mean"),
                        ("amount", "mean"),
                    ])?;

                    grouped.call_method("agg", (agg_dict,), None)
                }
                "sum" => {
                    let group_cols = vec!["symbol"];
                    let agg_cols = vec!["volume", "amount"];

                    let grouped = df.call_method("groupby", (group_cols,), None)?;
                    let agg_dict = pyo3::types::PyDict::from_sequence([
                        ("volume", "sum"),
                        ("amount", "sum"),
                    ])?;

                    grouped.call_method("agg", (agg_dict,), None)
                }
                _ => Err(PulseTraderError::new(format!("Unsupported aggregation function: {}", agg_func)).into_py_result()),
            }
        }
        "date" => {
            match agg_func {
                "mean" => {
                    let group_cols = vec!["date"];
                    let agg_cols = vec!["close", "volume"];

                    let grouped = df.call_method("groupby", (group_cols,), None)?;
                    let agg_dict = pyo3::types::PyDict::from_sequence([
                        ("close", "mean"),
                        ("volume", "mean"),
                    ])?;

                    grouped.call_method("agg", (agg_dict,), None)
                }
                _ => Err(PulseTraderError::new(format!("Unsupported aggregation for date: {}", agg_func)).into_py_result()),
            }
        }
        _ => Err(PulseTraderError::new(format!("Unsupported group_by: {}", group_by)).into_py_result()),
    }
}
```

---

## ğŸ—„ï¸ ClickHouseé›†æˆ

### 1. ClickHouseå†™å…¥å™¨Pythonç»‘å®š

**rust/src/python/clickhouse_integration.rs**
```rust
//! ClickHouseé›†æˆæ¨¡å—

use pyo3::prelude::*;
use pyo3::{Python, PyResult};
use std::collections::HashMap;

use crate::storage::{ClickHouseWriter, BatchWriter};
use crate::python::{PyResult, EnhancedDayRecordPy};

/// ClickHouseå†™å…¥å™¨Pythonç»‘å®š
#[pyclass]
pub class ClickHouseWriterPy {
    #[pyo3(get)]
    host: String,
    #[pyo3(get)]
    port: u16,
    #[pyo3(get)]
    database: String,
    #[pyo3(get)]
    user: String,
    #[pyo3(get)]
    password: String,
    writer: ClickHouseWriter,
}

#[pymethods]
impl ClickHouseWriterPy {
    /// åˆ›å»ºæ–°çš„ClickHouseå†™å…¥å™¨
    #[new]
    #[kwargs]
    fn __new__(
        host: Option<String>,
        port: Option<u16>,
        database: Option<String>,
        user: Option<String>,
        password: Option<String>,
    ) -> PyResult<Self> {
        let config = ClickHouseConfig {
            host: host.unwrap_or_else(|| "localhost".to_string()),
            port: port.unwrap_or(8123),
            database: database.unwrap_or_else(|| "pulse_trader".to_string()),
            user: user.unwrap_or_else(|| "default".to_string()),
            password: password.unwrap_or_else(|| "".to_string()),
        };

        let writer = ClickHouseWriter::new(config).into_py_result()?;

        Ok(Self {
            host: writer.config.host.clone(),
            port: writer.config.port,
            database: writer.config.database.clone(),
            user: writer.config.user.clone(),
            password: writer.config.password.clone(),
            writer,
        })
    }

    /// æµ‹è¯•è¿æ¥
    fn test_connection(&self, py: Python) -> PyResult<bool> {
        python::allow_threads(py, || {
            self.writer.test_connection().into_py_result()
        })
    }

    /// æ‰¹é‡æ’å…¥æ—¥çº¿æ•°æ®
    fn insert_daily_quotes(&self, py: Python, records: Vec<EnhancedDayRecordPy>) -> PyResult<u64> {
        python::allow_threads(py, || {
            // è½¬æ¢ä¸ºRustè®°å½•
            let rust_records: Vec<crate::parsers::TDXDayRecord> = records
                .into_iter()
                .map(|record| record.into_rust_record())
                .collect();

            self.writer.insert_daily_quotes(&rust_records).into_py_result()
        })
    }

    /// æ‰¹é‡æ’å…¥å¢å¼ºæ•°æ®
    fn insert_enhanced_data(&self, py: Python, records: Vec<EnhancedDayRecordPy>) -> PyResult<u64> {
        python::allow_threads(py, || {
            // è½¬æ¢ä¸ºRustè®°å½•
            let rust_records: Vec<crate::parsers::TDXDayRecord> = records
                .into_iter()
                .map(|record| record.into_rust_record())
                .collect();

            self.writer.insert_enhanced_data(&rust_records).into_py_result()
        })
    }

    /// æ‰§è¡ŒæŸ¥è¯¢
    fn execute_query(&self, py: Python, query: &str) -> PyResult<Vec<Py<pyo3::PyAny>>> {
        python::allow_threads(py, || {
            let results = self.writer.execute_query(query).into_py_result()?;

            // å°†ç»“æœè½¬æ¢ä¸ºPythonå¯¹è±¡
            let mut python_results = Vec::new();
            for row in results {
                let py_row = pyo3::types::PyDict::new(py);

                // å‡è®¾æ¯ä¸ªå­—æ®µéƒ½æ˜¯å­—ç¬¦ä¸²ç±»å‹
                for (key, value) in row {
                    py_row.set_item(key, value)?;
                }

                python_results.push(py_row.into_py(py));
            }

            Ok(python_results)
        })
    }

    /// åˆ›å»ºè¡¨ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
    fn create_table_if_not_exists(&self, py: Python, table_name: &str, schema: &str) -> PyResult<bool> {
        python::allow_threads(py, || {
            self.writer.create_table_if_not_exists(table_name, schema).into_py_result()
        })
    }

    /// è·å–è¡¨ç»“æ„ä¿¡æ¯
    fn get_table_info(&self, py: Python, table_name: &str) -> PyResult<HashMap<String, String>> {
        python::allow_threads(py, || {
            self.writer.get_table_info(table_name).into_py_result()
        })
    }

    /// è·å–è¡¨ç»Ÿè®¡ä¿¡æ¯
    fn get_table_stats(&self, py: Python, table_name: &str) -> PyResult<HashMap<String, String>> {
        python::allow_threads(py, || {
            self.writer.get_table_stats(table_name).into_py_result()
        })
    }

    /// ä¼˜åŒ–è¡¨
    fn optimize_table(&self, py: Python, table_name: &str) -> PyResult<()> {
        python::allow_threads(py, || {
            self.writer.optimize_table(table_name).into_py_result()
        })
    }
}

/// ClickHouseé…ç½®
#[derive(Debug, Clone)]
pub struct ClickHouseConfig {
    pub host: String,
    pub port: u16,
    pub database: String,
    pub user: String,
    pub password: String,
}

impl Default for ClickHouseConfig {
    fn default() -> Self {
        Self {
            host: "localhost".to_string(),
            port: 8123,
            database: "pulse_trader".to_string(),
            user: "default".to_string(),
            password: "".to_string(),
        }
    }
}
```

### 2. ä¾¿æ·çš„ä¿å­˜å‡½æ•°

**rust/src/python/convenience_functions.rs**
```rust
//! ä¾¿æ·å‡½æ•°æ¨¡å—

use pyo3::prelude::*;
use pyo3::{Python, PyResult};

use crate::python::{
    PyResult, TDXParser, EnhancedDayRecordPy,
    get_pandas_dataframe, save_dataframe,
    ClickHouseWriterPy,
};
use crate::processors::{DataProcessor, IndicatorCalculator};

/// ä¾¿æ·çš„è§£æé€šè¾¾ä¿¡æ•°æ®å‡½æ•°
#[pyfunction]
fn parse_tdx_data(
    py: Python,
    data_dir: &str,
    market: Option<&str>, // "all", "sh", "sz"
    save_to_python: bool = true,
) -> PyResult<Vec<EnhancedDayRecordPy>> {
    let parser = TDXParser::new(data_dir);

    let mut all_records = Vec::new();

    match market.unwrap_or("all") {
        "all" => {
            // è§£ææ‰€æœ‰å¸‚åœº
            if let Ok(sh_records) = parser.parse_directory(&format!("{}/vipdoc/sh/day", data_dir)) {
                all_records.extend(sh_records);
            }
            if let Ok(sz_records) = parser.parse_directory(&format!("{}/vipdoc/sz/day", data_dir)) {
                all_records.extend(sz_records);
            }
        }
        "sh" => {
            // ä»…è§£ææ²ªå¸‚
            if let Ok(sh_records) = parser.parse_directory(&format!("{}/vipdoc/sh/day", data_dir)) {
                all_records.extend(sh_records);
            }
        }
        "sz" => {
            // ä»…è§£ææ·±å¸‚
            if let Ok(sz_records) = parser.parse_directory(&format!("{}/vipdoc/sz/day", data_dir)) {
                all_records.extend(sz_records);
            }
        }
        _ => {
            return Err(PulseTraderError::new(format!("Invalid market: {}", market.unwrap())).into_py_result());
        }
    }

    if save_to_python {
        // è‡ªåŠ¨ä¿å­˜åˆ°Pythonå˜é‡
        // è¿™é‡Œå¯ä»¥å®ç°å°†æ•°æ®ä¿å­˜åˆ°å…¨å±€å˜é‡æˆ–æ•°æ®åº“
    }

    Ok(all_records)
}

/// ä¾¿æ·çš„è®¡ç®—æŒ‡æ ‡å‡½æ•°
#[pyfunction]
fn calculate_indicators(
    py: Python,
    records: Vec<EnhancedDayRecordPy>,
    indicators: Vec<String>, // æŒ‡æ ‡åˆ—è¡¨: ["ma5", "ma10", "rsi", "macd", "bollinger"]
    batch_size: Option<usize>,
) -> PyResult<Vec<EnhancedDayRecordPy>> {
    let calculator = IndicatorCalculator::new();
    let mut enhanced_records = Vec::new();

    // ç®€åŒ–å®ç°ï¼šè½¬æ¢ä¸ºRustè®°å½•å¹¶è®¡ç®—æ‰€æœ‰æŒ‡æ ‡
    let rust_records: Vec<crate::processors::EnhancedDayRecord> = records
        .into_iter()
        .map(|record| {
            crate::processors::EnhancedDayRecord::from_record(&record.into_rust_record(), crate::processors::IndicatorValues::default())
        })
        .collect();

    // å¹¶è¡Œè®¡ç®—æŒ‡æ ‡
    let calculated_records = calculator.calculate_parallel(&rust_records).into_py_result()?;

    // è½¬æ¢ä¸ºPythonå¯¹è±¡
    for record in calculated_records {
        enhanced_records.push(EnhancedDayRecordPy::from_enhanced_record(&record));
    }

    Ok(enhanced_records)
}

/// ä¾¿æ·çš„æ•°æ®æ¸…æ´—å‡½æ•°
#[pyfunction]
fn clean_data(
    py: Python,
    records: Vec<EnhancedDayRecordPy>,
    rules: Option<Vec<String>>, // è§„åˆ™åˆ—è¡¨
    remove_outliers: bool = true,
    fill_missing: bool = true,
    remove_duplicates: bool = true,
) -> PyResult<Vec<EnhancedDayRecordPy>> {
    let mut processor = DataProcessor::new(num_cpus::get());

    // æ ¹æ®å‚æ•°æ·»åŠ æ¸…æ´—è§„åˆ™
    if remove_outliers {
        processor.add_rule(crate::processors::CleaningRule::RemoveOutliers {
            field: "close".to_string(),
            method: crate::processors::OutlierMethod::IQR { multiplier: 2.0 },
            threshold: 3.0,
        });
    }

    if remove_duplicates {
        processor.add_rule(crate::processors::CleaningRule::RemoveDuplicates {
            keys: vec!["symbol".to_string(), "date".to_string()],
        });
    }

    // æ¸…æ´—æ•°æ®
    let cleaned_records = processor.clean_data(records).into_py_result()?;

    Ok(cleaned_records.cleaned_records)
}

/// ä¾¿æ·çš„ä¿å­˜å‡½æ•°
#[pyfunction]
fn save_to_clickhouse(
    py: Python,
    records: Vec<EnhancedDayRecordPy>,
    table_name: &str,
    clickhouse_config: Option<HashMap<String, String>>,
) -> PyResult<u64> {
    // åˆ›å»ºClickHouseå†™å…¥å™¨
    let mut writer = ClickHouseWriterPy::new(
        clickhouse_config
            .map(|config| ClickHouseConfig {
                host: config.get("host").unwrap_or("localhost").to_string(),
                port: config.get("port").unwrap_or(8123),
                database: config.get("database").unwrap_or("pulse_trader").to_string(),
                user: config.get("user").unwrap_or("default").to_string(),
                password: config.get("password").unwrap_or("").to_string(),
            })
            .unwrap_or_default(),
    )?;

    // æ‰¹é‡æ’å…¥æ•°æ®
    let inserted_count = writer.insert_daily_quotes(records).into_py_result()?;

    // è¾“å‡ºç»Ÿè®¡ä¿¡æ¯
    println!("æˆåŠŸæ’å…¥ {} æ¡è®°å½•åˆ° ClickHouse è¡¨: {}", inserted_count, table_name);

    Ok(inserted_count)
}

/// ä¾¿æ·çš„æ•°æ®åˆ†æå‡½æ•°
#[pyfunction]
fn analyze_data(
    py: Python,
    records: Vec<EnhancedDayRecordPy>,
    analysis_type: &str,
) -> PyResult<HashMap<String, f64>> {
    match analysis_type {
        "basic" => {
            let mut stats = HashMap::new();

            if records.is_empty() {
                return Ok(stats);
            }

            // åŸºæœ¬ç»Ÿè®¡
            let close_prices: Vec<f64> = records.iter().map(|r| r.close).collect();
            let volumes: Vec<u64> = records.iter().map(|r| r.volume).collect();
            let amounts: Vec<f64> = records.iter().map(|r| r.amount).collect();

            stats.insert("total_records".to_string(), records.len() as f64);
            stats.insert("avg_price".to_string(), close_prices.iter().sum::<f64>() / close_prices.len() as f64);
            stats.insert("min_price".to_string(), close_prices.iter().fold(f64::INFINITY, |a, b| a.min(*b)));
            stats.insert("max_price".to_string(), close_prices.iter().fold(0.0, |a, b| a.max(*b)));
            stats.insert("total_volume".to_string(), volumes.iter().sum::<u64>() as f64);
            stats.insert("total_amount".to_string(), amounts.iter().sum::<f64>());

            // è®¡ç®—ä»·æ ¼æ³¢åŠ¨æ€§
            if close_prices.len() > 1 {
                let returns: Vec<f64> = close_prices
                    .windows(2)
                    .map(|w| (w[1] - w[0]) / w[0])
                    .collect();
                let avg_return = returns.iter().sum::<f64>() / returns.len() as f64;
                let variance: f64 = returns.iter().map(|r| (*r - avg_return).powi(2)).sum::<f64>() / returns.len() as f64;
                let volatility = variance.sqrt();

                stats.insert("avg_return".to_string(), avg_return);
                stats.insert("volatility".to_string(), volatility);
            }

            Ok(stats)
        }
        "volume_analysis" => {
            let mut stats = HashMap::new();

            let volumes: Vec<u64> = records.iter().map(|r| r.volume).collect();

            if !volumes.is_empty() {
                return Ok(stats);
            }

            stats.insert("total_volume".to_string(), volumes.iter().sum::<u64>() as f64);
            stats.insert("avg_volume".to_string(), volumes.iter().sum::<u64>() as f64 / volumes.len() as f64);
            stats.insert("max_volume".to_string(), volumes.iter().max().unwrap_or(0) as f64);
            stats.insert("min_volume".to_string(), volumes.iter().min().unwrap_or(0) as f64);

            // è®¡ç®—æˆäº¤é‡åˆ†å¸ƒ
            let high_volume_days = volumes.iter().filter(|&v| *v > volumes.iter().sum::<u64>() / volumes.len() as u64 * 2).count();
            stats.insert("high_volume_days".to_string(), high_volume_days as f64);

            Ok(stats)
        }
        _ => Err(PulseTraderError::new(format!("Unsupported analysis type: {}", analysis_type))).into_py_result()),
    }
}

/// ä¾¿æ·çš„CSVå¯¼å‡ºå‡½æ•°
#[pyfunction]
fn export_to_csv(
    py: Python,
    records: Vec<EnhancedDayRecordPy>,
    file_path: &str,
    include_indicators: bool = true,
) -> PyResult<()> {
    let df = get_pandas_dataframe(py, records)?;
    save_dataframe(py, df, file_path, Some("csv"))
}

/// ä¾¿æ·çš„JSONå¯¼å‡ºå‡½æ•°
#[pyfunction]
fn export_to_json(
    py: Python,
    records: Vec<EnhancedDayRecordPy>,
    file_path: &str,
    include_indicators: bool = true,
) -> PyResult<()> {
    let df = get_pandas_dataframe(py, records)?;
    save_dataframe(py, df, file_path, Some("json"))
}
```

---

## ğŸ§ª æ„å»ºé…ç½®

### 1. Maturiné…ç½®

**rust/pyproject.toml**
```toml
[tool.maturin]
python-source = "python"
module-name = "pulse_trader_rust._core"
features = ["pyo3/extension-module"]

[build-system]
requires = ["maturin>=1.0,<2.0"]
build-backend = "maturin"
```

### 2. è®¾ç½®è„šæœ¬

**scripts/setup_rust_environment.py**
```python
#!/usr/bin/env python3
"""
Rustç¯å¢ƒè®¾ç½®è„šæœ¬
"""

import os
import sys
import subprocess
import logging
from pathlib import Path

def setup_rust_environment():
    """è®¾ç½®Rustå¼€å‘ç¯å¢ƒ"""
    print("ğŸš€ å¼€å§‹è®¾ç½®Rustå¼€å‘ç¯å¢ƒ...")

    # æ£€æŸ¥Rustæ˜¯å¦å·²å®‰è£…
    try:
        result = subprocess.run(
            ["rustc", "--version"],
            capture_output=True,
            text=True,
            check=True
        )
        print(f"âœ… Rustå·²å®‰è£…: {result.stdout.strip()}")
    except subprocess.CalledProcessError:
        print("âŒ Rustæœªå®‰è£…")
        return install_rust()

    # æ£€æŸ¥Cargoæ˜¯å¦å¯ç”¨
    try:
        result = subprocess.run(
            ["cargo", "--version"],
            capture_output=True,
            text=True,
            check=True
        )
        print(f"âœ… Cargoå·²å®‰è£…: {result.stdout.strip()}")
    except subprocess.CalledProcessError:
        print("âŒ Cargoæœªå®‰è£…")
        return False

    # åˆ›å»ºè™šæ‹Ÿç¯å¢ƒï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
    venv_path = Path(".venv")
    if not venv_path.exists():
        print("åˆ›å»ºPythonè™šæ‹Ÿç¯å¢ƒ...")
        subprocess.run([sys.executable, "-m", "venv", str(venv_path)], check=True)

    # å®‰è£…Pythonä¾èµ–
    install_python_dependencies()

    # æ„å»ºRustæ¨¡å—
    build_rust_module()

    print("ğŸ‰ Rustç¯å¢ƒè®¾ç½®å®Œæˆï¼")

def install_rust():
    """å®‰è£…Rust"""
    print("ğŸ“¥ å®‰è£…Rust...")
    if sys.platform == "win32":
        # Windows: ä½¿ç”¨rustup
        url = "https://win.rustup.rs/x86_64"
        print(f"è¯·è®¿é—® {url} ä¸‹è½½å¹¶å®‰è£…Rust")
        print("æˆ–ä½¿ç”¨åŒ…ç®¡ç†å™¨: choco install rust")
        return False
    else:
        # Linux/macOS: ä½¿ç”¨rustup
        curl_command = "curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh"
        subprocess.run(curl_command, shell=True, check=True)
        return True

def install_python_dependencies():
    """å®‰è£…Pythonä¾èµ–"""
    print("ğŸ“¦ å®‰è£…Pythonä¾èµ–...")

    # å®‰è£…Maturin
    subprocess.run([
        sys.executable, "-m", "pip", "install", "maturin>=1.0.0", "--upgrade"
    ], check=True)

    # å®‰è£…PyO3
    subprocess.run([
        sys.executable, "-m", "pip", "install", "PyO3>=0.20.0", "--upgrade"
    ], check=True)

    # å®‰è£…å…¶ä»–ä¾èµ–
    dependencies = [
        "numpy>=1.24.0",
        "pandas>=2.0.0",
        "clickhouse-driver",
        "clickhouse-pool",
        "akshare",
        "asyncio",
        "aiofiles",
        "python-dotenv",
        "pyyaml",
    ]

    for dep in dependencies:
        print(f"å®‰è£… {dep}...")
        subprocess.run([
            sys.executable, "-m", "pip", "install", dep
        ], check=True)

def build_rust_module():
    """æ„å»ºRustæ¨¡å—"""
    print("ğŸ”¨ æ„å»ºRustæ¨¡å—...")

    # è¿›å…¥rustç›®å½•
    rust_dir = Path("rust")
    if not rust_dir.exists():
        print("âŒ Rustç›®å½•ä¸å­˜åœ¨")
        return False

    # æ„å»ºå‘å¸ƒç‰ˆæœ¬
    os.chdir(rust_dir)

    # æ¸…ç†ä¹‹å‰çš„æ„å»º
    print("æ¸…ç†ä¹‹å‰çš„æ„å»º...")
    subprocess.run(["cargo", "clean"], check=True)

    # æ„å»ºå‘å¸ƒç‰ˆæœ¬
    print("æ„å»ºå‘å¸ƒç‰ˆæœ¬...")
    result = subprocess.run(
        ["cargo", "build", "--release"],
        capture_output=True,
        text=True
    )

    if result.returncode == 0:
        print("âœ… Rustæ¨¡å—æ„å»ºæˆåŠŸ")
        return True
    else:
        print("âŒ Rustæ¨¡å—æ„å»ºå¤±è´¥:")
        print(result.stderr)
        return False

def test_rust_integration():
    """æµ‹è¯•Rusté›†æˆ"""
    print("ğŸ§ª æµ‹è¯•Rusté›†æˆ...")

    try:
        # æµ‹è¯•å¯¼å…¥
        import pulse_trader_rust

        # æµ‹è¯•åŸºæœ¬åŠŸèƒ½
        parser = pulse_trust.TDXParser("data/tdx")
        print(f"âœ… Python-Rusté›†æˆæµ‹è¯•é€šè¿‡")

        return True

    except Exception as e:
        print(f"âŒ Python-Rusté›†æˆæµ‹è¯•å¤±è´¥: {e}")
        return False

def main():
    """ä¸»å‡½æ•°"""
    if setup_rust_environment():
        test_rust_integration()
    else:
        print("âŒ ç¯å¢ƒè®¾ç½®å¤±è´¥")

if __name__ == "__main__":
    main()
```

---

## ğŸ¯ æœ¬èŠ‚å°ç»“

### âœ… å®Œæˆå†…å®¹

1. **PyO3ç»‘å®š**: å®ç°äº†å®Œæ•´çš„Python-Rustç»‘å®šæ¥å£
2. **å¼‚å¸¸å¤„ç†**: å»ºç«‹äº†ç»Ÿä¸€çš„é”™è¯¯å¤„ç†å’Œå¼‚å¸¸è½¬æ¢æœºåˆ¶
3. **Pandasé›†æˆ**: æä¾›äº†é«˜æ•ˆçš„æ•°æ®è½¬æ¢å’Œåˆ†æåŠŸèƒ½
4. **ClickHouseé›†æˆ**: å®ç°äº†é«˜æ€§èƒ½çš„æ•°æ®åº“å­˜å‚¨æ¥å£
5. **ä¾¿æ·å‡½æ•°**: åˆ›å»ºäº†å¸¸ç”¨çš„å¿«æ·æ“ä½œå‡½æ•°

### ğŸ“Š é›†æˆç‰¹æ€§

| åŠŸèƒ½ | Rustå®ç° | Pythonæ¥å£ | æ€§èƒ½ä¼˜åŠ¿ |
|------|-----------|-------------|----------|
| æ•°æ®è§£æ | äºŒè¿›åˆ¶è§£æ | é¢å‘å¯¹è±¡ | é«˜æ€§èƒ½ |
| æŒ‡æ ‡è®¡ç®— | å¹¶è¡Œè®¡ç®— | å‡½æ•°è°ƒç”¨ | æ•°å€¼ä¼˜åŒ– |
| æ•°æ®æ¸…æ´— | è§„åˆ™å¼•æ“ | é¢å‘å¯¹è±¡ | å†…å­˜å®‰å…¨ |
| å­˜å‚¨æ“ä½œ | æ‰¹é‡å†™å…¥ | æ–¹æ³•è°ƒç”¨ | å¹¶å‘å¤„ç† |

### ğŸ”§ æ ¸å¿ƒæ¥å£

1. **TDXParser**: é€šè¾¾ä¿¡æ•°æ®è§£æ
2. **DataProcessor**: æ•°æ®æ¸…æ´—å’Œå¤„ç†
3. **IndicatorCalculator**: æŠ€æœ¯æŒ‡æ ‡è®¡ç®—
4. **ClickHouseWriter**: æ•°æ®åº“æ‰¹é‡å†™å…¥
5. **ä¾¿æ·å‡½æ•°**: å¸¸ç”¨æ“ä½œçš„å¿«æ·æ–¹å¼

### âš ï¸ ä½¿ç”¨æ³¨æ„

1. **çº¿ç¨‹å®‰å…¨**: Rustä»£ç åœ¨Pythonçº¿ç¨‹ä¸­å®‰å…¨æ‰§è¡Œ
2. **å†…å­˜ç®¡ç†**: é¿å…åœ¨Rustå’ŒPythoné—´ä¼ é€’å¤§æ•°æ®
3. **ç±»å‹è½¬æ¢**: æ³¨æ„Pythonå’ŒRustç±»å‹çš„å¯¹åº”å…³ç³»
4. **é”™è¯¯ä¼ æ’­**: å¼‚å¸¸éœ€è¦æ­£ç¡®åœ°ä»Rustä¼ æ’­åˆ°Python
5. **æ€§èƒ½è€ƒè™‘**: æ‰¹é‡æ“ä½œæ¯”é€ä¸ªè°ƒç”¨æ›´é«˜æ•ˆ

### ğŸ”„ ä¸‹ä¸€æ­¥

ä¸‹ä¸€èŠ‚æˆ‘ä»¬å°†å­¦ä¹ **ClickHouseæ‰¹é‡å­˜å‚¨**ï¼Œå®ç°é«˜æ€§èƒ½çš„æ•°æ®å†™å…¥å’Œå­˜å‚¨ä¼˜åŒ–ã€‚

**[â†’ å‰å¾€ 2.4 ClickHouseæ‰¹é‡å­˜å‚¨](2.4-ClickHouseæ‰¹é‡å­˜å‚¨.md)**

---

## ğŸ†˜ å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

### Q1: PyO3ç»‘å®šç¼–è¯‘å¤±è´¥æ€ä¹ˆåŠï¼Ÿ

**A**: è§£å†³æ–¹æ¡ˆï¼š
1. æ£€æŸ¥Rustå’ŒPythonç‰ˆæœ¬å…¼å®¹æ€§
2. ç¡®ä¿æ‰€æœ‰ä¾èµ–å·²æ­£ç¡®å®‰è£…
3. æ¸…ç†ä¹‹å‰çš„æ„å»ºç¼“å­˜
4. æ£€æŸ¥Maturiné…ç½®æ–‡ä»¶
5. æŸ¥çœ‹ç¼–è¯‘é”™è¯¯æ—¥å¿—

### Q2: æ€§èƒ½ä¸å¦‚é¢„æœŸå¦‚ä½•ä¼˜åŒ–ï¼Ÿ

**A**: ä¼˜åŒ–ç­–ç•¥ï¼š
1. ä½¿ç”¨æ‰¹é‡æ“ä½œè€Œéé€ä¸ªè°ƒç”¨
2. é¿å…åœ¨Pythonå’ŒRusté—´ä¼ é€’å¤§æ•°æ®
3. å¯ç”¨Rustçš„å¹¶è¡Œå¤„ç†èƒ½åŠ›
4. ä¼˜åŒ–æ•°æ®åºåˆ—åŒ–å’Œååºåˆ—åŒ–
5. ä½¿ç”¨å†…å­˜æ˜ å°„å¤„ç†å¤§æ•°æ®é›†

### Q3: å†…å­˜æ³„æ¼æ€ä¹ˆåŠï¼Ÿ

**A**: å†…å­˜ç®¡ç†ï¼š
1. ç¡®ä¿åŠæ—¶é‡Šæ”¾Ruståˆ›å»ºçš„å¯¹è±¡
2. é¿å…å¾ªç¯å¼•ç”¨
3. ä½¿ç”¨Rustçš„æ‰€æœ‰æƒç³»ç»Ÿ
4. ç›‘æ§å†…å­˜ä½¿ç”¨æƒ…å†µ
5. å®šæœŸè¿›è¡Œæ€§èƒ½åˆ†æ

### Q4: Pythonå’ŒRustç±»å‹ä¸åŒ¹é…ï¼Ÿ

**A**: ç±»å‹è½¬æ¢ï¼š
1. å®šä¹‰æ˜ç¡®çš„æ•°æ®è½¬æ¢æ¥å£
2. ä½¿ç”¨ç±»å‹å®‰å…¨çš„è½¬æ¢å‡½æ•°
3. éªŒè¯æ•°æ®æ ¼å¼å’ŒèŒƒå›´
4. å®ç°è‡ªåŠ¨ç±»å‹æ¨æ–­
5. ç¼–å†™å•å…ƒæµ‹è¯•éªŒè¯è½¬æ¢é€»è¾‘

---

**æœ¬èŠ‚å»ºç«‹äº†Pythonå’ŒRustçš„æ— ç¼é›†æˆï¼Œä¸ºé‡åŒ–äº¤æ˜“ç³»ç»Ÿæä¾›äº†é«˜æ€§èƒ½çš„æ•°æ®å¤„ç†èƒ½åŠ›ï¼** ğŸ”—âœ¨
