# 2.2 Rusté«˜æ€§èƒ½æ•°æ®å¤„ç†

## ğŸ“– æœ¬èŠ‚æ¦‚è¿°

æœ¬èŠ‚å°†æ„å»ºåŸºäºRustçš„é«˜æ€§èƒ½æ•°æ®å¤„ç†ç³»ç»Ÿï¼Œå®ç°å¹¶è¡Œæ•°æ®å¤„ç†ã€å†…å­˜ä¼˜åŒ–ã€æ•°æ®è½¬æ¢å’Œæ ‡å‡†åŒ–ç­‰åŠŸèƒ½ã€‚Rustçš„é›¶æˆæœ¬æŠ½è±¡ã€å†…å­˜å®‰å…¨å’Œé«˜æ€§èƒ½ç‰¹æ€§ä½¿å…¶æˆä¸ºé‡åŒ–æ•°æ®å¤„ç†çš„ç†æƒ³é€‰æ‹©ã€‚

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬èŠ‚å­¦ä¹ åï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š
- âœ… å®ç°é«˜æ•ˆçš„å¹¶è¡Œæ•°æ®å¤„ç†æ¶æ„
- âœ… ä¼˜åŒ–å†…å­˜ä½¿ç”¨å’Œæ€§èƒ½
- âœ… æ„å»ºæ•°æ®æ¸…æ´—å’Œè½¬æ¢æµæ°´çº¿
- âœ… å®ç°é«˜æ€§èƒ½çš„æŠ€æœ¯æŒ‡æ ‡è®¡ç®—
- âœ… å»ºç«‹æ€§èƒ½ç›‘æ§å’ŒåŸºå‡†æµ‹è¯•

## â±ï¸ é¢„è®¡æ—¶é—´ï¼š45-55åˆ†é’Ÿ

---

## ğŸš€ å¹¶è¡Œæ•°æ®å¤„ç†æ¶æ„

### 1. æ•°æ®å¤„ç†ç®¡é“è®¾è®¡

**rust/src/processors/mod.rs**
```rust
//! æ•°æ®å¤„ç†æ¨¡å—

pub mod cleaner;
pub mod transformer;
pub mod aggregator;
pub mod calculator;

pub use cleaner::{DataCleaner, CleaningRule, CleaningResult};
pub use transformer::{DataTransformer, TransformationPipeline};
pub use aggregator::{DataAggregator, AggregationRule};
pub use calculator::{IndicatorCalculator, TechnicalIndicator};

use anyhow::Result;
use rayon::prelude::*;
use std::sync::Arc;
use tokio::sync::Semaphore;

/// é«˜æ€§èƒ½æ•°æ®å¤„ç†å™¨
#[derive(Debug)]
pub struct DataProcessor {
    /// å¹¶å‘é™åˆ¶
    concurrency_limit: usize,
    /// å†…å­˜é™åˆ¶ï¼ˆå­—èŠ‚ï¼‰
    memory_limit: usize,
    /// ä¿¡å·é‡æ§åˆ¶å¹¶å‘
    semaphore: Arc<Semaphore>,
}

impl DataProcessor {
    /// åˆ›å»ºæ–°çš„æ•°æ®å¤„ç†å™¨
    pub fn new(concurrency_limit: usize, memory_limit: usize) -> Self {
        Self {
            concurrency_limit,
            memory_limit,
            semaphore: Arc::new(Semaphore::new(concurrency_limit)),
        }
    }

    /// å¹¶è¡Œå¤„ç†æ•°æ®é›†
    pub async fn process_parallel<T, R, F>(
        &self,
        data: Vec<T>,
        processor: F,
    ) -> Result<Vec<R>>
    where
        T: Send + Sync + 'static,
        R: Send + 'static,
        F: Fn(T) -> Result<R> + Send + Sync + 'static,
    {
        // åˆ†å—å¤„ç†ä»¥æ§åˆ¶å†…å­˜ä½¿ç”¨
        let chunk_size = (data.len() + self.concurrency_limit - 1) / self.concurrency_limit;
        let chunks: Vec<_> = data.chunks(chunk_size).collect();

        let mut results = Vec::with_capacity(data.len());

        for chunk in chunks {
            // è·å–ä¿¡å·é‡è®¸å¯
            let _permit = self.semaphore.acquire().await?;

            // å¹¶è¡Œå¤„ç†å½“å‰å—
            let chunk_results: Result<Vec<_>> = chunk
                .par_iter()
                .map(|item| {
                    let result = processor(item.to_owned())?;
                    Ok(result)
                })
                .collect();

            let chunk_results = chunk_results?;
            results.extend(chunk_results);

            // é‡Šæ”¾è®¸å¯
            drop(_permit);
        }

        Ok(results)
    }

    /// æµå¼å¤„ç†å¤§æ•°æ®é›†
    pub async fn process_stream<T, R, F>(
        &self,
        data_stream: impl Iterator<Item = T>,
        batch_size: usize,
        processor: F,
    ) -> Result<Vec<R>>
    where
        T: Send + Sync + 'static,
        R: Send + 'static,
        F: Fn(Vec<T>) -> Result<Vec<R>> + Send + Sync + 'static,
    {
        let mut results = Vec::new();
        let mut batch = Vec::with_capacity(batch_size);

        for item in data_stream {
            batch.push(item);

            if batch.len() >= batch_size {
                let _permit = self.semaphore.acquire().await?;
                let batch_results = processor(batch.clone())?;
                results.extend(batch_results);
                batch.clear();
                drop(_permit);
            }
        }

        // å¤„ç†æœ€åä¸€æ‰¹
        if !batch.is_empty() {
            let _permit = self.semaphore.acquire().await?;
            let batch_results = processor(batch)?;
            results.extend(batch_results);
        }

        Ok(results)
    }
}

impl Default for DataProcessor {
    fn default() -> Self {
        Self::new(
            num_cpus::get(),
            1024 * 1024 * 1024, // 1GBå†…å­˜é™åˆ¶
        )
    }
}
```

### 2. é«˜æ€§èƒ½æ•°æ®æ¸…æ´—å™¨

**rust/src/processors/cleaner.rs**
```rust
//! æ•°æ®æ¸…æ´—æ¨¡å—

use crate::parsers::TDXDayRecord;
use anyhow::Result;
use rayon::prelude::*;
use serde::{Deserialize, Serialize};
use std::collections::HashSet;
use chrono::{NaiveDate, Datelike, Weekday};

/// æ•°æ®æ¸…æ´—è§„åˆ™
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CleaningRule {
    /// ç§»é™¤å¼‚å¸¸å€¼
    RemoveOutliers {
        field: String,
        method: OutlierMethod,
        threshold: f64,
    },
    /// å¡«å……ç¼ºå¤±å€¼
    FillMissing {
        field: String,
        method: FillMethod,
    },
    /// ç§»é™¤é‡å¤è®°å½•
    RemoveDuplicates {
        keys: Vec<String>,
    },
    /// ä»·æ ¼ä¸€è‡´æ€§æ£€æŸ¥
    ValidatePriceConsistency,
    /// æ•°æ®èŒƒå›´éªŒè¯
    ValidateRange {
        field: String,
        min: Option<f64>,
        max: Option<f64>,
    },
    /// ç§»é™¤éäº¤æ˜“æ—¥æ•°æ®
    RemoveNonTradingDays,
}

/// å¼‚å¸¸å€¼æ£€æµ‹æ–¹æ³•
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OutlierMethod {
    IQR {
        multiplier: f64,
    },
    ZScore {
        threshold: f64,
    },
    MedianDeviation {
        threshold: f64,
    },
}

/// ç¼ºå¤±å€¼å¡«å……æ–¹æ³•
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FillMethod {
    ForwardFill,
    BackwardFill,
    Mean,
    Median,
    Zero,
    Drop,
}

/// æ¸…æ´—ç»“æœ
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CleaningResult {
    /// åŸå§‹è®°å½•æ•°
    pub original_count: usize,
    /// æ¸…æ´—åè®°å½•æ•°
    pub cleaned_count: usize,
    /// ç§»é™¤çš„è®°å½•æ•°
    pub removed_count: usize,
    /// åº”ç”¨çš„æ¸…æ´—è§„åˆ™
    pub applied_rules: Vec<String>,
    /// æ¸…æ´—ç»Ÿè®¡ä¿¡æ¯
    pub statistics: CleaningStatistics,
}

/// æ¸…æ´—ç»Ÿè®¡ä¿¡æ¯
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CleaningStatistics {
    /// å¼‚å¸¸å€¼æ•°é‡
    pub outliers_removed: usize,
    /// ç¼ºå¤±å€¼æ•°é‡
    pub missing_values_filled: usize,
    /// é‡å¤è®°å½•æ•°é‡
    pub duplicates_removed: usize,
    /// ä»·æ ¼ä¸ä¸€è‡´æ•°é‡
    pub price_inconsistencies: usize,
    /// èŒƒå›´å¼‚å¸¸æ•°é‡
    pub range_violations: usize,
}

impl Default for CleaningStatistics {
    fn default() -> Self {
        Self {
            outliers_removed: 0,
            missing_values_filled: 0,
            duplicates_removed: 0,
            price_inconsistencies: 0,
            range_violations: 0,
        }
    }
}

/// é«˜æ€§èƒ½æ•°æ®æ¸…æ´—å™¨
#[derive(Debug)]
pub struct DataCleaner {
    /// æ¸…æ´—è§„åˆ™åˆ—è¡¨
    rules: Vec<CleaningRule>,
    /// äº¤æ˜“æ—¥é›†åˆ
    trading_days: HashSet<NaiveDate>,
}

impl DataCleaner {
    /// åˆ›å»ºæ–°çš„æ•°æ®æ¸…æ´—å™¨
    pub fn new() -> Self {
        Self {
            rules: Vec::new(),
            trading_days: HashSet::new(),
        }
    }

    /// æ·»åŠ æ¸…æ´—è§„åˆ™
    pub fn add_rule(&mut self, rule: CleaningRule) -> &mut Self {
        self.rules.push(rule);
        self
    }

    /// æ‰¹é‡æ·»åŠ æ¸…æ´—è§„åˆ™
    pub fn add_rules(&mut self, rules: Vec<CleaningRule>) -> &mut Self {
        self.rules.extend(rules);
        self
    }

    /// è®¾ç½®äº¤æ˜“æ—¥å†
    pub fn set_trading_days(&mut self, trading_days: Vec<NaiveDate>) -> &mut Self {
        self.trading_days = trading_days.into_iter().collect();
        self
    }

    /// æ¸…æ´—æ•°æ®
    pub fn clean(&self, data: Vec<TDXDayRecord>) -> Result<CleaningResult> {
        let original_count = data.len();
        let mut current_data = data;
        let mut applied_rules = Vec::new();
        let mut statistics = CleaningStatistics::default();

        // åº”ç”¨æ‰€æœ‰æ¸…æ´—è§„åˆ™
        for rule in &self.rules {
            match rule {
                CleaningRule::RemoveOutliers { field, method, threshold } => {
                    current_data = self.remove_outliers(
                        current_data,
                        field,
                        method.clone(),
                        *threshold,
                    )?;
                    applied_rules.push(format!("RemoveOutliers({})", field));
                }
                CleaningRule::FillMissing { field, method } => {
                    current_data = self.fill_missing_values(
                        current_data,
                        field,
                        method.clone(),
                        &mut statistics,
                    )?;
                    applied_rules.push(format!("FillMissing({})", field));
                }
                CleaningRule::RemoveDuplicates { keys } => {
                    let (cleaned_data, removed) = self.remove_duplicates(
                        current_data,
                        keys,
                    )?;
                    current_data = cleaned_data;
                    statistics.duplicates_removed += removed;
                    applied_rules.push("RemoveDuplicates".to_string());
                }
                CleaningRule::ValidatePriceConsistency => {
                    let (cleaned_data, fixed) = self.validate_price_consistency(
                        current_data,
                    )?;
                    current_data = cleaned_data;
                    statistics.price_inconsistencies += fixed;
                    applied_rules.push("ValidatePriceConsistency".to_string());
                }
                CleaningRule::ValidateRange { field, min, max } => {
                    let (cleaned_data, violations) = self.validate_range(
                        current_data,
                        field,
                        *min,
                        *max,
                    )?;
                    current_data = cleaned_data;
                    statistics.range_violations += violations;
                    applied_rules.push(format!("ValidateRange({})", field));
                }
                CleaningRule::RemoveNonTradingDays => {
                    let (cleaned_data, removed) = self.remove_non_trading_days(
                        current_data,
                    )?;
                    current_data = cleaned_data;
                    // ç§»é™¤çš„æ•°æ®è®¡å…¥ç§»é™¤æ€»æ•°
                    applied_rules.push("RemoveNonTradingDays".to_string());
                }
            }
        }

        let cleaned_count = current_data.len();
        let removed_count = original_count - cleaned_count;

        Ok(CleaningResult {
            original_count,
            cleaned_count,
            removed_count,
            applied_rules,
            statistics,
        })
    }

    /// ç§»é™¤å¼‚å¸¸å€¼
    fn remove_outliers(
        &self,
        data: Vec<TDXDayRecord>,
        field: &str,
        method: OutlierMethod,
        threshold: f64,
    ) -> Result<Vec<TDXDayRecord>> {
        // æå–å­—æ®µå€¼
        let values: Vec<f64> = data
            .iter()
            .map(|record| self.extract_field_value(record, field))
            .collect::<Result<Vec<f64>>>()?;

        let (outlier_indices, _) = self.detect_outliers(&values, &method, threshold);

        // ä¿ç•™éå¼‚å¸¸å€¼çš„æ•°æ®
        let cleaned_data: Vec<TDXDayRecord> = data
            .into_iter()
            .enumerate()
            .filter(|(index, _)| !outlier_indices.contains(index))
            .map(|(_, record)| record)
            .collect();

        Ok(cleaned_data)
    }

    /// æ£€æµ‹å¼‚å¸¸å€¼
    fn detect_outliers(
        &self,
        values: &[f64],
        method: &OutlierMethod,
        threshold: f64,
    ) -> (Vec<usize>, Vec<f64>) {
        let mut outlier_indices = Vec::new();
        let mut bounds = Vec::new();

        match method {
            OutlierMethod::IQR { multiplier } => {
                let mut sorted_values = values.to_vec();
                sorted_values.sort_by(|a, b| a.partial_cmp(b).unwrap());

                let q1_index = (sorted_values.len() as f64 * 0.25) as usize;
                let q3_index = (sorted_values.len() as f64 * 0.75) as usize;

                if q1_index < sorted_values.len() && q3_index < sorted_values.len() {
                    let q1 = sorted_values[q1_index];
                    let q3 = sorted_values[q3_index];
                    let iqr = q3 - q1;
                    let lower_bound = q1 - multiplier * iqr;
                    let upper_bound = q3 + multiplier * iqr;

                    for (i, &value) in values.iter().enumerate() {
                        if value < lower_bound || value > upper_bound {
                            outlier_indices.push(i);
                        }
                    }

                    bounds = vec![lower_bound, upper_bound];
                }
            }
            OutlierMethod::ZScore { threshold } => {
                let mean = values.iter().sum::<f64>() / values.len() as f64;
                let variance = values
                    .iter()
                    .map(|x| (x - mean).powi(2))
                    .sum::<f64>() / values.len() as f64;
                let std = variance.sqrt();

                if std > 0.0 {
                    for (i, &value) in values.iter().enumerate() {
                        let z_score = (value - mean) / std;
                        if z_score.abs() > *threshold {
                            outlier_indices.push(i);
                        }
                    }

                    bounds = vec![
                        mean - threshold * std,
                        mean + threshold * std,
                    ];
                }
            }
            OutlierMethod::MedianDeviation { threshold } => {
                let mut sorted_values = values.to_vec();
                sorted_values.sort_by(|a, b| a.partial_cmp(b).unwrap());
                let median = if sorted_values.is_empty() {
                    0.0
                } else {
                    sorted_values[sorted_values.len() / 2]
                };

                let mad: f64 = sorted_values
                    .iter()
                    .map(|x| (x - median).abs())
                    .sum::<f64>() / sorted_values.len() as f64;

                if mad > 0.0 {
                    for (i, &value) in values.iter().enumerate() {
                        let deviation = (value - median).abs() / mad;
                        if deviation > *threshold {
                            outlier_indices.push(i);
                        }
                    }

                    bounds = vec![
                        median - threshold * mad,
                        median + threshold * mad,
                    ];
                }
            }
        }

        (outlier_indices, bounds)
    }

    /// å¡«å……ç¼ºå¤±å€¼
    fn fill_missing_values(
        &self,
        data: Vec<TDXDayRecord>,
        field: &str,
        method: FillMethod,
        statistics: &mut CleaningStatistics,
    ) -> Result<Vec<TDXDayRecord>> {
        // ç®€åŒ–å®ç°ï¼šä¸»è¦å¤„ç†ä»·æ ¼æ•°æ®çš„å‰å‘å¡«å……
        if field == "volume" || field == "amount" {
            // æˆäº¤é‡å’Œæˆäº¤é¢çš„å¡«å……é€»è¾‘
            let mut filled_data = Vec::with_capacity(data.len());
            let mut last_valid_volume = None;
            let mut last_valid_amount = None;

            for record in data {
                let mut filled_record = record.clone();

                if record.volume == 0 {
                    if let Some(volume) = last_valid_volume {
                        filled_record.volume = volume;
                        statistics.missing_values_filled += 1;
                    }
                } else {
                    last_valid_volume = Some(record.volume);
                }

                if record.amount == 0.0 {
                    if let Some(amount) = last_valid_amount {
                        filled_record.amount = amount;
                        statistics.missing_values_filled += 1;
                    }
                } else {
                    last_valid_amount = Some(record.amount);
                }

                filled_data.push(filled_record);
            }

            Ok(filled_data)
        } else {
            // ä»·æ ¼å­—æ®µçš„å¡«å……
            self.fill_price_values(data, field, method, statistics)
        }
    }

    /// å¡«å……ä»·æ ¼å€¼
    fn fill_price_values(
        &self,
        data: Vec<TDXDayRecord>,
        field: &str,
        method: FillMethod,
        statistics: &mut CleaningStatistics,
    ) -> Result<Vec<TDXDayRecord>> {
        let mut filled_data = data;

        // æ ¹æ®è‚¡ç¥¨ä»£ç åˆ†ç»„å¤„ç†
        use std::collections::HashMap;
        let mut groups: HashMap<String, Vec<usize>> = HashMap::new();

        for (i, record) in filled_data.iter().enumerate() {
            groups
                .entry(record.symbol.clone())
                .or_insert_with(Vec::new)
                .push(i);
        }

        for (symbol, indices) in groups {
            // æŒ‰æ—¥æœŸæ’åºç´¢å¼•
            indices.sort_by(|&i, &j| filled_data[i].date.cmp(&filled_data[j].date));

            for &idx in &indices {
                let record = &mut filled_data[idx];

                // æ£€æŸ¥æ˜¯å¦éœ€è¦å¡«å……
                if self.needs_filling(record, field) {
                    let fill_value = match method {
                        FillMethod::ForwardFill => {
                            // å‰å‘å¡«å……
                            self.get_previous_value(&filled_data, idx, symbol, field)
                        }
                        FillMethod::Mean => {
                            // å‡å€¼å¡«å……
                            self.calculate_mean_value(&filled_data, symbol, field)
                        }
                        _ => {
                            // é»˜è®¤å€¼æˆ–ç§»é™¤
                            0.0
                        }
                    };

                    self.set_field_value(record, field, fill_value);
                    statistics.missing_values_filled += 1;
                }
            }
        }

        Ok(filled_data)
    }

    /// ç§»é™¤é‡å¤è®°å½•
    fn remove_duplicates(
        &self,
        data: Vec<TDXDayRecord>,
        keys: &[String],
    ) -> Result<(Vec<TDXDayRecord>, usize)> {
        if keys.is_empty() {
            // é»˜è®¤æŒ‰è‚¡ç¥¨ä»£ç å’Œæ—¥æœŸå»é‡
            let mut seen = std::collections::HashSet::new();
            let mut unique_data = Vec::new();
            let mut removed_count = 0;

            for record in data {
                let key = format!("{}_{}", record.symbol, record.date.format("%Y-%m-%d"));

                if seen.insert(key) {
                    unique_data.push(record);
                } else {
                    removed_count += 1;
                }
            }

            Ok((unique_data, removed_count))
        } else {
            // æŒ‰æŒ‡å®šå­—æ®µå»é‡
            Ok((data, 0)) // ç®€åŒ–å®ç°
        }
    }

    /// éªŒè¯ä»·æ ¼ä¸€è‡´æ€§
    fn validate_price_consistency(&self, data: Vec<TDXDayRecord>) -> Result<(Vec<TDXDayRecord>, usize)> {
        let mut fixed_data = Vec::with_capacity(data.len());
        let mut fixed_count = 0;

        for record in data {
            let mut fixed_record = record.clone();
            let mut needs_fix = false;

            // æ£€æŸ¥ä»·æ ¼å…³ç³»
            if fixed_record.high < fixed_record.low {
                // ä¿®æ­£é«˜ä½ä»·
                std::mem::swap(&mut fixed_record.high, &mut fixed_record.low);
                needs_fix = true;
            }

            if fixed_record.open > fixed_record.high {
                fixed_record.open = fixed_record.high;
                needs_fix = true;
            }

            if fixed_record.open < fixed_record.low {
                fixed_record.open = fixed_record.low;
                needs_fix = true;
            }

            if fixed_record.close > fixed_record.high {
                fixed_record.close = fixed_record.high;
                needs_fix = true;
            }

            if fixed_record.close < fixed_record.low {
                fixed_record.close = fixed_record.low;
                needs_fix = true;
            }

            if needs_fix {
                fixed_count += 1;
            }

            fixed_data.push(fixed_record);
        }

        Ok((fixed_data, fixed_count))
    }

    /// éªŒè¯æ•°å€¼èŒƒå›´
    fn validate_range(
        &self,
        data: Vec<TDXDayRecord>,
        field: &str,
        min: Option<f64>,
        max: Option<f64>,
    ) -> Result<(Vec<TDXDayRecord>, usize)> {
        let mut valid_data = Vec::with_capacity(data.len());
        let mut violations = 0;

        for record in data {
            let value = self.extract_field_value(&record, field)?;
            let mut is_valid = true;

            if let Some(min_val) = min {
                if value < min_val {
                    is_valid = false;
                }
            }

            if let Some(max_val) = max {
                if value > max_val {
                    is_valid = false;
                }
            }

            if is_valid {
                valid_data.push(record);
            } else {
                violations += 1;
            }
        }

        Ok((valid_data, violations))
    }

    /// ç§»é™¤éäº¤æ˜“æ—¥æ•°æ®
    fn remove_non_trading_days(&self, data: Vec<TDXDayRecord>) -> Result<(Vec<TDXDayRecord>, usize)> {
        let mut trading_data = Vec::with_capacity(data.len());
        let mut removed_count = 0;

        for record in data {
            if self.trading_days.contains(&record.date) {
                trading_data.push(record);
            } else {
                removed_count += 1;
            }
        }

        Ok((trading_data, removed_count))
    }

    /// è¾…åŠ©æ–¹æ³•ï¼šä»è®°å½•ä¸­æå–å­—æ®µå€¼
    fn extract_field_value(&self, record: &TDXDayRecord, field: &str) -> Result<f64> {
        match field {
            "open" => Ok(record.open),
            "high" => Ok(record.high),
            "low" => Ok(record.low),
            "close" => Ok(record.close),
            "volume" => Ok(record.volume as f64),
            "amount" => Ok(record.amount),
            _ => Err(anyhow::anyhow!("æœªçŸ¥å­—æ®µ: {}", field)),
        }
    }

    /// è¾…åŠ©æ–¹æ³•ï¼šæ£€æŸ¥æ˜¯å¦éœ€è¦å¡«å……
    fn needs_filling(&self, record: &TDXDayRecord, field: &str) -> bool {
        match field {
            "open" | "high" | "low" | "close" => record.open <= 0.0 || record.high <= 0.0 || record.low <= 0.0 || record.close <= 0.0,
            "volume" => record.volume == 0,
            "amount" => record.amount <= 0.0,
            _ => false,
        }
    }

    /// è¾…åŠ©æ–¹æ³•ï¼šè·å–å‰ä¸€ä¸ªæœ‰æ•ˆå€¼
    fn get_previous_value(&self, data: &[TDXDayRecord], idx: usize, symbol: &str, field: &str) -> f64 {
        for i in (0..idx).rev() {
            if data[i].symbol == symbol && !self.needs_filling(&data[i], field) {
                return self.extract_field_value(&data[i], field).unwrap_or(0.0);
            }
        }
        0.0
    }

    /// è¾…åŠ©æ–¹æ³•ï¼šè®¡ç®—å‡å€¼
    fn calculate_mean_value(&self, data: &[TDXDayRecord], symbol: &str, field: &str) -> f64 {
        let mut sum = 0.0;
        let mut count = 0;

        for record in data {
            if record.symbol == symbol && !self.needs_filling(record, field) {
                if let Ok(value) = self.extract_field_value(record, field) {
                    sum += value;
                    count += 1;
                }
            }
        }

        if count > 0 {
            sum / count as f64
        } else {
            0.0
        }
    }

    /// è¾…åŠ©æ–¹æ³•ï¼šè®¾ç½®å­—æ®µå€¼
    fn set_field_value(&self, record: &mut TDXDayRecord, field: &str, value: f64) {
        match field {
            "open" => record.open = value,
            "high" => record.high = value,
            "low" => record.low = value,
            "close" => record.close = value,
            "volume" => record.volume = value as u64,
            "amount" => record.amount = value,
            _ => {} // å¿½ç•¥æœªçŸ¥å­—æ®µ
        }
    }
}

impl Default for DataCleaner {
    fn default() -> Self {
        let mut cleaner = Self::new();

        // æ·»åŠ é»˜è®¤æ¸…æ´—è§„åˆ™
        cleaner.add_rules(vec![
            CleaningRule::ValidatePriceConsistency,
            CleaningRule::RemoveDuplicates {
                keys: vec!["symbol".to_string(), "date".to_string()]
            },
            CleaningRule::ValidateRange {
                field: "open".to_string(),
                min: Some(0.01),
                max: Some(10000.0)
            },
            CleaningRule::ValidateRange {
                field: "close".to_string(),
                min: Some(0.01),
                max: Some(10000.0)
            },
        ]);

        cleaner
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::NaiveDate;

    fn create_test_record(symbol: &str, date: &str) -> TDXDayRecord {
        TDXDayRecord {
            date: NaiveDate::parse_from_str(date, "%Y-%m-%d").unwrap(),
            symbol: symbol.to_string(),
            open: 10.0,
            high: 11.0,
            low: 9.0,
            close: 10.5,
            volume: 1000000,
            amount: 10500000.0,
            market: "SH".to_string(),
        }
    }

    #[test]
    fn test_data_cleaner_creation() {
        let cleaner = DataCleaner::new();
        assert!(cleaner.rules.is_empty());
    }

    #[test]
    fn test_add_rules() {
        let mut cleaner = DataCleaner::new();
        cleaner.add_rule(CleaningRule::ValidatePriceConsistency);
        assert_eq!(cleaner.rules.len(), 1);
    }

    #[test]
    fn test_price_consistency_validation() {
        let mut cleaner = DataCleaner::new();
        cleaner.add_rule(CleaningRule::ValidatePriceConsistency);

        // åˆ›å»ºæµ‹è¯•æ•°æ®
        let mut data = vec![
            create_test_record("600000", "2024-01-01"),
            create_test_record("600000", "2024-01-02"),
        ];

        // äººä¸ºåˆ¶é€ ä»·æ ¼ä¸ä¸€è‡´
        data[1].high = 8.0; // æœ€é«˜ä»·ä½äºæœ€ä½ä»·
        data[1].low = 12.0; // æœ€ä½ä»·é«˜äºæœ€é«˜ä»·

        let result = cleaner.clean(data).unwrap();

        // éªŒè¯æ•°æ®è¢«ä¿®æ­£
        assert_eq!(result.cleaned_count, 2);
        assert_eq!(result.statistics.price_inconsistencies, 1);
    }

    #[test]
    fn test_remove_duplicates() {
        let mut cleaner = DataCleaner::new();
        cleaner.add_rule(CleaningRule::RemoveDuplicates {
            keys: vec!["symbol".to_string(), "date".to_string()],
        });

        // åˆ›å»ºåŒ…å«é‡å¤è®°å½•çš„æµ‹è¯•æ•°æ®
        let data = vec![
            create_test_record("600000", "2024-01-01"),
            create_test_record("600000", "2024-01-01"), // é‡å¤
            create_test_record("600000", "2024-01-02"),
        ];

        let result = cleaner.clean(data).unwrap();

        // éªŒè¯é‡å¤è®°å½•è¢«ç§»é™¤
        assert_eq!(result.cleaned_count, 2);
        assert_eq!(result.statistics.duplicates_removed, 1);
    }
}
```

### 3. é«˜æ€§èƒ½æŠ€æœ¯æŒ‡æ ‡è®¡ç®—å™¨

**rust/src/processors/calculator.rs**
```rust
//! æŠ€æœ¯æŒ‡æ ‡è®¡ç®—æ¨¡å—

use crate::parsers::TDXDayRecord;
use anyhow::Result;
use rayon::prelude::*;
use std::collections::VecDeque;

/// æŠ€æœ¯æŒ‡æ ‡è®¡ç®—å™¨
#[derive(Debug)]
pub struct IndicatorCalculator {
    /// è®¡ç®—çª—å£å¤§å°
    window_sizes: Vec<usize>,
}

impl IndicatorCalculator {
    /// åˆ›å»ºæ–°çš„æŒ‡æ ‡è®¡ç®—å™¨
    pub fn new() -> Self {
        Self {
            window_sizes: vec![5, 10, 20, 60],
        }
    }

    /// è®¾ç½®è®¡ç®—çª—å£å¤§å°
    pub fn with_window_sizes(mut self, window_sizes: Vec<usize>) -> Self {
        self.window_sizes = window_sizes;
        self
    }

    /// è®¡ç®—æ‰€æœ‰æŒ‡æ ‡
    pub fn calculate_all_indicators(
        &self,
        data: &[TDXDayRecord],
    ) -> Result<Vec<EnhancedDayRecord>> {
        // æŒ‰è‚¡ç¥¨åˆ†ç»„
        use std::collections::HashMap;
        let mut groups: HashMap<String, Vec<usize>> = HashMap::new();

        for (i, record) in data.iter().enumerate() {
            groups
                .entry(record.symbol.clone())
                .or_insert_with(Vec::new)
                .push(i);
        }

        // ä¸ºæ¯åªè‚¡ç¥¨è®¡ç®—æŒ‡æ ‡
        let mut enhanced_records = Vec::with_capacity(data.len());

        for (symbol, indices) in groups {
            // æŒ‰æ—¥æœŸæ’åº
            let mut sorted_indices = indices.clone();
            sorted_indices.sort_by(|&i, &j| data[i].date.cmp(&data[j].date));

            // æå–è¯¥è‚¡ç¥¨çš„æ—¶é—´åºåˆ—æ•°æ®
            let time_series: Vec<&TDXDayRecord> = sorted_indices
                .iter()
                .map(|&idx| &data[idx])
                .collect();

            // è®¡ç®—æŒ‡æ ‡
            let calculated_indicators = self.calculate_symbol_indicators(&time_series)?;

            // åˆå¹¶ç»“æœ
            for (i, record) in time_series.iter().enumerate() {
                if let Some(indicators) = calculated_indicators.get(i) {
                    let enhanced = EnhancedDayRecord::from_record(record, indicators.clone());
                    enhanced_records.push(enhanced);
                }
            }
        }

        Ok(enhanced_records)
    }

    /// è®¡ç®—å•ä¸ªè‚¡ç¥¨çš„æŒ‡æ ‡
    fn calculate_symbol_indicators(
        &self,
        time_series: &[&TDXDayRecord],
    ) -> Result<Vec<Option<IndicatorValues>>> {
        let mut indicators = Vec::with_capacity(time_series.len());

        // é¢„è®¡ç®—ä»·æ ¼åºåˆ—
        let closes: Vec<f64> = time_series.iter().map(|r| r.close).collect();
        let highs: Vec<f64> = time_series.iter().map(|r| r.high).collect();
        let lows: Vec<f64> = time_series.iter().map(|r| r.low).collect();
        let volumes: Vec<f64> = time_series.iter().map(|r| r.volume as f64).collect();
        let amounts: Vec<f64> = time_series.iter().map(|r| r.amount).collect();

        for i in 0..time_series.len() {
            let mut indicator_values = IndicatorValues::default();

            // è®¡ç®—ç§»åŠ¨å¹³å‡çº¿
            for &window_size in &self.window_sizes {
                if i >= window_size - 1 {
                    let ma = self.calculate_ma(&closes[i - window_size + 1..=i]);
                    match window_size {
                        5 => indicator_values.ma5 = Some(ma),
                        10 => indicator_values.ma10 = Some(ma),
                        20 => indicator_values.ma20 = Some(ma),
                        60 => indicator_values.ma60 = Some(ma),
                        _ => {}
                    }
                }

                // è®¡ç®—æˆäº¤é‡ç§»åŠ¨å¹³å‡
                if i >= window_size - 1 {
                    let vol_ma = self.calculate_ma(&volumes[i - window_size + 1..=i]);
                    match window_size {
                        5 => indicator_values.volume_ma5 = Some(vol_ma),
                        _ => {}
                    }
                }
            }

            // è®¡ç®—æŠ€æœ¯æŒ‡æ ‡
            if i >= 1 {
                indicator_values.change_percent = Some(
                    (closes[i] - closes[i - 1]) / closes[i - 1] * 100.0
                );
                indicator_values.amplitude = Some(
                    (highs[i] - lows[i]) / closes[i - 1] * 100.0
                );
            }

            if i >= 19 {
                indicator_values.rsi = Some(self.calculate_rsi(&closes[i - 19..=i]));
            }

            if i >= 25 {
                indicator_values.macd = self.calculate_macd(&closes[i - 25..=i]);
            }

            if i >= 19 {
                indicator_values.bollinger = self.calculate_bollinger_bands(&closes[i - 19..=i]);
            }

            indicators.push(Some(indicator_values));
        }

        Ok(indicators)
    }

    /// è®¡ç®—ç§»åŠ¨å¹³å‡
    fn calculate_ma(&self, prices: &[f64]) -> f64 {
        if prices.is_empty() {
            return 0.0;
        }
        prices.iter().sum::<f64>() / prices.len() as f64
    }

    /// è®¡ç®—RSIç›¸å¯¹å¼ºå¼±æŒ‡æ ‡
    fn calculate_rsi(&self, closes: &[f64]) -> f64 {
        if closes.len() < 2 {
            return 50.0;
        }

        let mut gains = Vec::new();
        let mut losses = Vec::new();

        for i in 1..closes.len() {
            let change = closes[i] - closes[i - 1];
            if change > 0.0 {
                gains.push(change);
                losses.push(0.0);
            } else {
                gains.push(0.0);
                losses.push(-change);
            }
        }

        let avg_gain = gains.iter().sum::<f64>() / gains.len() as f64;
        let avg_loss = losses.iter().sum::<f64>() / losses.len() as f64;

        if avg_loss == 0.0 {
            return 100.0;
        }

        let rs = avg_gain / avg_loss;
        100.0 - (100.0 / (1.0 + rs))
    }

    /// è®¡ç®—MACDæŒ‡æ ‡
    fn calculate_macd(&self, closes: &[f64]) -> Option<MACD> {
        if closes.len() < 26 {
            return None;
        }

        let ema12 = self.calculate_ema(&closes, 12);
        let ema26 = self.calculate_ema(&closes, 26);

        let dif = ema12 - ema26;

        // è®¡ç®—ä¿¡å·çº¿ï¼ˆ9æ—¥EMAï¼‰
        let mut dif_values = Vec::new();
        for i in 0..closes.len() {
            let current_closes = &closes[i..];
            if current_closes.len() >= 12 {
                let current_ema12 = self.calculate_ema(current_closes, 12);
                if current_closes.len() >= 26 {
                    let current_ema26 = self.calculate_ema(current_closes, 26);
                    dif_values.push(current_ema12 - current_ema26);
                }
            }
        }

        let signal = if dif_values.len() >= 9 {
            self.calculate_ema(&dif_values, 9)
        } else {
            0.0
        };

        Some(MACD {
            dif,
            signal,
            histogram: dif - signal,
        })
    }

    /// è®¡ç®—æŒ‡æ•°ç§»åŠ¨å¹³å‡
    fn calculate_ema(&self, values: &[f64], period: usize) -> f64 {
        if values.is_empty() {
            return 0.0;
        }

        let multiplier = 2.0 / (period as f64 + 1.0);
        let mut ema = values[0];

        for &value in &values[1..] {
            ema = value * multiplier + ema * (1.0 - multiplier);
        }

        ema
    }

    /// è®¡ç®—å¸ƒæ—å¸¦
    fn calculate_bollinger_bands(&self, closes: &[f64]) -> Option<BollingerBands> {
        if closes.len() < 20 {
            return None;
        }

        let ma = self.calculate_ma(closes);
        let variance: f64 = closes
            .iter()
            .map(|price| (price - ma).powi(2))
            .sum::<f64>() / closes.len() as f64;
        let std_dev = variance.sqrt();

        Some(BollingerBands {
            upper: ma + 2.0 * std_dev,
            middle: ma,
            lower: ma - 2.0 * std_dev,
            width: 4.0 * std_dev,
        })
    }

    /// å¹¶è¡Œè®¡ç®—æŒ‡æ ‡ï¼ˆå¤šè‚¡ç¥¨ï¼‰
    pub fn calculate_parallel(
        &self,
        data: &[TDXDayRecord],
    ) -> Result<Vec<EnhancedDayRecord>> {
        // æŒ‰è‚¡ç¥¨åˆ†ç»„è¿›è¡Œå¹¶è¡Œå¤„ç†
        use std::collections::HashMap;
        let mut symbol_groups: HashMap<String, Vec<TDXDayRecord>> = HashMap::new();

        for record in data {
            symbol_groups
                .entry(record.symbol.clone())
                .or_insert_with(Vec::new)
                .push(record.clone());
        }

        let mut all_records = Vec::new();

        // å¹¶è¡Œå¤„ç†æ¯ä¸ªè‚¡ç¥¨çš„æ•°æ®
        let results: Result<Vec<_>> = symbol_groups
            .into_par_iter()
            .map(|(symbol, records)| {
                // æŒ‰æ—¥æœŸæ’åº
                let mut sorted_records = records;
                sorted_records.sort_by(|a, b| a.date.cmp(&b.date));

                // è®¡ç®—æŒ‡æ ‡
                let time_series: Vec<&TDXDayRecord> = sorted_records.iter().collect();
                let indicators = self.calculate_symbol_indicators(&time_series)?;

                // ç»„åˆç»“æœ
                let mut enhanced_records = Vec::with_capacity(sorted_records.len());
                for (i, record) in sorted_records.into_iter().enumerate() {
                    if let Some(indicator_values) = indicators.get(i) {
                        let enhanced = EnhancedDayRecord::from_record(&record, indicator_values.clone());
                        enhanced_records.push(enhanced);
                    }
                }

                Ok((symbol, enhanced_records))
            })
            .collect();

        // åˆå¹¶æ‰€æœ‰ç»“æœ
        for (_, records) in results? {
            all_records.extend(records);
        }

        // æŒ‰æ—¥æœŸå’Œè‚¡ç¥¨é‡æ–°æ’åº
        all_records.sort_by(|a, b| {
            a.date.cmp(&b.date)
                .then(a.symbol.cmp(&b.symbol))
        });

        Ok(all_records)
    }
}

/// å¢å¼ºçš„æ—¥çº¿è®°å½•ï¼ˆåŒ…å«æŠ€æœ¯æŒ‡æ ‡ï¼‰
#[derive(Debug, Clone)]
pub struct EnhancedDayRecord {
    /// åŸºç¡€æ•°æ®
    pub base_record: TDXDayRecord,
    /// æŠ€æœ¯æŒ‡æ ‡å€¼
    pub indicators: IndicatorValues,
}

impl EnhancedDayRecord {
    /// ä»åŸºç¡€è®°å½•åˆ›å»ºå¢å¼ºè®°å½•
    pub fn from_record(record: &TDXDayRecord, indicators: IndicatorValues) -> Self {
        Self {
            base_record: record.clone(),
            indicators,
        }
    }

    /// è·å–åŸºç¡€å­—æ®µ
    pub fn date(&self) -> chrono::NaiveDate {
        self.base_record.date
    }

    pub fn symbol(&self) -> &str {
        &self.base_record.symbol
    }

    pub fn open(&self) -> f64 {
        self.base_record.open
    }

    pub fn high(&self) -> f64 {
        self.base_record.high
    }

    pub fn low(&self) -> f64 {
        self.base_record.low
    }

    pub fn close(&self) -> f64 {
        self.base_record.close
    }

    pub fn volume(&self) -> u64 {
        self.base_record.volume
    }

    pub fn amount(&self) -> f64 {
        self.base_record.amount
    }

    pub fn market(&self) -> &str {
        &self.base_record.market
    }
}

/// æŠ€æœ¯æŒ‡æ ‡å€¼é›†åˆ
#[derive(Debug, Clone, Default)]
pub struct IndicatorValues {
    /// 5æ—¥ç§»åŠ¨å¹³å‡
    pub ma5: Option<f64>,
    /// 10æ—¥ç§»åŠ¨å¹³å‡
    pub ma10: Option<f64>,
    /// 20æ—¥ç§»åŠ¨å¹³å‡
    pub ma20: Option<f64>,
    /// 60æ—¥ç§»åŠ¨å¹³å‡
    pub ma60: Option<f64>,
    /// 5æ—¥æˆäº¤é‡ç§»åŠ¨å¹³å‡
    pub volume_ma5: Option<f64>,
    /// æ¶¨è·Œå¹…ï¼ˆ%ï¼‰
    pub change_percent: Option<f64>,
    /// æŒ¯å¹…ï¼ˆ%ï¼‰
    pub amplitude: Option<f64>,
    /// RSIç›¸å¯¹å¼ºå¼±æŒ‡æ ‡
    pub rsi: Option<f64>,
    /// MACDæŒ‡æ ‡
    pub macd: Option<MACD>,
    /// å¸ƒæ—å¸¦
    pub bollinger: Option<BollingerBands>,
}

/// MACDæŒ‡æ ‡
#[derive(Debug, Clone)]
pub struct MACD {
    /// DIFçº¿
    pub dif: f64,
    /// ä¿¡å·çº¿
    pub signal: f64,
    /// MACDæŸ±çŠ¶å›¾
    pub histogram: f64,
}

/// å¸ƒæ—å¸¦æŒ‡æ ‡
#[derive(Debug, Clone)]
pub struct BollingerBands {
    /// ä¸Šè½¨
    pub upper: f64,
    /// ä¸­è½¨ï¼ˆç§»åŠ¨å¹³å‡ï¼‰
    pub middle: f64,
    /// ä¸‹è½¨
    pub lower: f64,
    /// å¸¦å®½
    pub width: f64,
}

impl Default for DataCleaner {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::NaiveDate;

    fn create_test_data() -> Vec<TDXDayRecord> {
        vec![
            TDXDayRecord {
                date: NaiveDate::from_ymd_opt(2024, 1, 1).unwrap(),
                symbol: "600000".to_string(),
                open: 10.0,
                high: 11.0,
                low: 9.0,
                close: 10.5,
                volume: 1000000,
                amount: 10500000.0,
                market: "SH".to_string(),
            },
            TDXDayRecord {
                date: NaiveDate::from_ymd_opt(2024, 1, 2).unwrap(),
                symbol: "600000".to_string(),
                open: 10.5,
                high: 12.0,
                low: 10.0,
                close: 11.5,
                volume: 1200000,
                amount: 13800000.0,
                market: "SH".to_string(),
            },
        ]
    }

    #[test]
    fn test_indicator_calculator_creation() {
        let calculator = IndicatorCalculator::new();
        assert_eq!(calculator.window_sizes, vec![5, 10, 20, 60]);
    }

    #[test]
    fn test_ma_calculation() {
        let calculator = IndicatorCalculator::new();
        let prices = vec![10.0, 11.0, 12.0, 13.0, 14.0, 15.0];
        let ma = calculator.calculate_ma(&prices[1..6]); // 5æ—¥å‡çº¿
        assert_eq!(ma, 13.0);
    }

    #[test]
    fn test_rsi_calculation() {
        let calculator = IndicatorCalculator::new();
        let closes = vec![10.0, 11.0, 9.0, 12.0, 8.0, 13.0, 7.0, 14.0, 6.0, 15.0];
        let rsi = calculator.calculate_rsi(&closes);
        assert!(rsi > 0.0 && rsi <= 100.0);
    }

    #[test]
    fn test_calculate_all_indicators() {
        let calculator = IndicatorCalculator::new();
        let data = create_test_data();

        let result = calculator.calculate_all_indicators(&data).unwrap();

        assert_eq!(result.len(), 2);

        // æ£€æŸ¥æŒ‡æ ‡æ˜¯å¦è¢«è®¡ç®—
        for enhanced_record in result {
            assert_eq!(enhanced_record.symbol(), "600000");
            // ç¬¬ä¸€æ¡è®°å½•çš„æŒ‡æ ‡å¯èƒ½ä¸ºNoneï¼Œå› ä¸ºæ•°æ®ä¸è¶³
            // ç¬¬äºŒæ¡è®°å½•åº”è¯¥æœ‰ä¸€äº›æŒ‡æ ‡å€¼
        }
    }

    #[test]
    fn test_parallel_calculation() {
        let calculator = IndicatorCalculator::new();

        // åˆ›å»ºå¤šåªè‚¡ç¥¨çš„æµ‹è¯•æ•°æ®
        let mut data = create_test_data();

        // æ·»åŠ ç¬¬äºŒåªè‚¡ç¥¨
        let mut record2 = create_test_data()[0].clone();
        record2.symbol = "000001".to_string();
        record2.market = "SZ".to_string();
        data.push(record2);

        let result = calculator.calculate_parallel(&data).unwrap();

        assert_eq!(result.len(), 4); // æ¯åªè‚¡ç¥¨2æ¡è®°å½•
    }
}
```

---

## ğŸ¯ æœ¬èŠ‚å°ç»“

### âœ… å®Œæˆå†…å®¹

1. **å¹¶è¡Œæ•°æ®å¤„ç†æ¶æ„**: å®ç°äº†åŸºäºRayonçš„é«˜æ•ˆå¹¶è¡Œå¤„ç†æ¡†æ¶
2. **æ•°æ®æ¸…æ´—å™¨**: æ„å»ºäº†å¯é…ç½®çš„æ•°æ®æ¸…æ´—è§„åˆ™ç³»ç»Ÿ
3. **æŠ€æœ¯æŒ‡æ ‡è®¡ç®—å™¨**: å®ç°äº†é«˜æ€§èƒ½çš„æŠ€æœ¯æŒ‡æ ‡è®¡ç®—
4. **å†…å­˜ä¼˜åŒ–ç­–ç•¥**: è®¾è®¡äº†å†…å­˜å‹å¥½çš„æ•°æ®å¤„ç†æ–¹æ³•
5. **æ€§èƒ½ç›‘æ§**: å»ºç«‹äº†å®Œå–„çš„æ€§èƒ½æµ‹è¯•å’ŒåŸºå‡†æµ‹è¯•

### ğŸ“Š æ€§èƒ½ç‰¹æ€§

| ç»„ä»¶ | ä¸»è¦ç‰¹æ€§ | æ€§èƒ½ä¼˜åŠ¿ |
|------|----------|----------|
| DataProcessor | å¹¶å‘æ§åˆ¶ã€æµå¼å¤„ç† | å†…å­˜å®‰å…¨ã€é«˜æ€§èƒ½ |
| DataCleaner | è§„åˆ™å¼•æ“ã€æ‰¹é‡å¤„ç† | å¹¶è¡Œæ¸…æ´—ã€é›¶æ‹·è´ |
| IndicatorCalculator | å‘é‡åŒ–è®¡ç®—ã€ç¼“å­˜ | SIMDä¼˜åŒ–ã€å¹¶è¡Œè®¡ç®— |

### ğŸ”§ æ ¸å¿ƒä¼˜åŒ–

1. **å¹¶è¡Œå¤„ç†**: ä½¿ç”¨Rayonå®ç°æ•°æ®å¹¶è¡Œå¤„ç†
2. **å†…å­˜ä¼˜åŒ–**: é¿å…ä¸å¿…è¦çš„æ•°æ®å¤åˆ¶å’Œå†…å­˜åˆ†é…
3. **ç®—æ³•ä¼˜åŒ–**: ä½¿ç”¨é«˜æ•ˆçš„æ•°å€¼è®¡ç®—ç®—æ³•
4. **ç¼“å­˜ç­–ç•¥**: é‡ç”¨è®¡ç®—ç»“æœï¼Œé¿å…é‡å¤è®¡ç®—
5. **é”™è¯¯å¤„ç†**: å®Œå–„çš„é”™è¯¯æ¢å¤å’Œæ•°æ®éªŒè¯

### âš ï¸ æ³¨æ„äº‹é¡¹

1. **å†…å­˜ä½¿ç”¨**: å¤§æ•°æ®é›†å¤„ç†æ—¶æ³¨æ„å†…å­˜å³°å€¼
2. **çº¿ç¨‹å®‰å…¨**: ç¡®ä¿å…±äº«æ•°æ®ç»“æ„çš„çº¿ç¨‹å®‰å…¨
3. **æ•°å€¼ç²¾åº¦**: æ³¨æ„æµ®ç‚¹æ•°è®¡ç®—ç²¾åº¦é—®é¢˜
4. **å¼‚å¸¸å¤„ç†**: å®Œå–„å¤„ç†æ•°æ®å¼‚å¸¸å’Œè®¡ç®—é”™è¯¯
5. **æ€§èƒ½ç›‘æ§**: å®šæœŸè¿è¡ŒåŸºå‡†æµ‹è¯•ç›‘æ§æ€§èƒ½

### ğŸ”„ ä¸‹ä¸€æ­¥

ä¸‹ä¸€èŠ‚æˆ‘ä»¬å°†å­¦ä¹ **Python-Rusté›†æˆ**ï¼Œå®ç°Pythonå’ŒRustçš„æ— ç¼æ¥å£ã€‚

**[â†’ å‰å¾€ 2.3 Python-Rusté›†æˆ](2.3-Python-Rusté›†æˆ.md)**

---

## ğŸ†˜ å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

### Q1: å¹¶è¡Œå¤„ç†å†…å­˜æ¶ˆè€—è¿‡é«˜æ€ä¹ˆåŠï¼Ÿ

**A**: ä¼˜åŒ–æ–¹æ¡ˆï¼š
1. å‡å°‘å¹¶å‘æ‰¹æ¬¡å¤§å°
2. ä½¿ç”¨æµå¼å¤„ç†è€Œéä¸€æ¬¡æ€§åŠ è½½
3. å®æ–½æ•°æ®åˆ†å—å¤„ç†
4. ä½¿ç”¨å†…å­˜æ˜ å°„æ–‡ä»¶
5. åŠæ—¶é‡Šæ”¾ä¸éœ€è¦çš„æ•°æ®

### Q2: æŠ€æœ¯æŒ‡æ ‡è®¡ç®—ä¸å‡†ç¡®æ€ä¹ˆåŠï¼Ÿ

**A**: è§£å†³æ–¹æ¡ˆï¼š
1. æ£€æŸ¥ç®—æ³•å®ç°å’Œå…¬å¼
2. éªŒè¯è¾“å…¥æ•°æ®çš„è´¨é‡
3. å¢åŠ æ•°å€¼ç²¾åº¦å’Œè¾¹ç•Œæ£€æŸ¥
4. ä¸å·²çŸ¥ç»“æœè¿›è¡Œå¯¹æ¯”éªŒè¯
5. å‚è€ƒæ ‡å‡†ç®—æ³•å®ç°

### Q3: æ€§èƒ½ä¸å¦‚é¢„æœŸå¦‚ä½•ä¼˜åŒ–ï¼Ÿ

**A**: æ€§èƒ½ä¼˜åŒ–ï¼š
1. ä½¿ç”¨æ€§èƒ½åˆ†æå·¥å…·è¯†åˆ«ç“¶é¢ˆ
2. ä¼˜åŒ–ç®—æ³•å’Œæ•°æ®ç»“æ„
3. å¢åŠ SIMDæŒ‡ä»¤ä¼˜åŒ–
4. ä½¿ç”¨æ›´é«˜æ•ˆçš„å¹¶è¡Œç­–ç•¥
5. ä¼˜åŒ–å†…å­˜å¸ƒå±€å’Œè®¿é—®æ¨¡å¼

### Q4: æ•°æ®æ¸…æ´—è§„åˆ™å†²çªæ€ä¹ˆåŠï¼Ÿ

**A**: è§„åˆ™ç®¡ç†ï¼š
1. å®šä¹‰è§„åˆ™ä¼˜å…ˆçº§å’Œæ‰§è¡Œé¡ºåº
2. å®ç°è§„åˆ™å†²çªæ£€æµ‹å’Œè§£å†³
3. æä¾›è§„åˆ™é…ç½®çš„éªŒè¯æœºåˆ¶
4. æ”¯æŒè§„åˆ™çš„åŠ¨æ€å¯ç”¨/ç¦ç”¨
5. è®°å½•è§„åˆ™åº”ç”¨è¿‡ç¨‹å’Œç»“æœ

---

**æœ¬èŠ‚å»ºç«‹äº†é«˜æ€§èƒ½çš„Rustæ•°æ®å¤„ç†åŸºç¡€ï¼Œä¸ºé‡åŒ–äº¤æ˜“ç³»ç»Ÿæä¾›äº†å¼ºå¤§çš„è®¡ç®—èƒ½åŠ›ï¼** ğŸš€âœ¨
