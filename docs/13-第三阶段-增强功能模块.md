# ç¬¬ä¸‰é˜¶æ®µï¼šå¢å¼ºåŠŸèƒ½æ¨¡å—ï¼ˆè¿­ä»£ç‰ˆï¼‰

> **ç›®æ ‡**: åœ¨MVPåŸºç¡€ä¸Šé€æ­¥å¢å¼ºå®ç”¨åŠŸèƒ½ï¼Œä¿æŒæ¯æ¬¡è¿­ä»£å°è€Œç²¾
> **è®¾è®¡ç†å¿µ**: è¿­ä»£æ”¹è¿›ï¼Œé€æ­¥å®Œå–„ï¼Œæ¯æ¬¡éƒ½æœ‰å¯ç”¨çš„åŠŸèƒ½
> **é¢„è®¡æ—¶é—´**: æ¯ä¸ªè¿­ä»£30-60åˆ†é’Ÿ

## ğŸ“‹ è¿­ä»£è®¡åˆ’

### è¿­ä»£1ï¼šå®Œå–„å›æµ‹ç³»ç»Ÿ (60åˆ†é’Ÿ)
**ç›®æ ‡**: è®©å›æµ‹åŠŸèƒ½æ›´ä¸“ä¸šå’Œå®ç”¨

#### æ­¥éª¤1.1ï¼šå¢å¼ºå›æµ‹å¼•æ“ (20åˆ†é’Ÿ)
```bash
# æ”¹è¿› backtest/engine.py
```

**æ–°å¢åŠŸèƒ½**:
- æ‰‹ç»­è´¹è®¡ç®—
- æ»‘ç‚¹æ¨¡æ‹Ÿ
- æŒä»“è®°å½•
- èµ„é‡‘æ›²çº¿è®¡ç®—

#### æ­¥éª¤1.2ï¼šé£é™©æŒ‡æ ‡è®¡ç®— (20åˆ†é’Ÿ)
```bash
# åˆ›å»º backtest/metrics.py
```

**æ–°å¢åŠŸèƒ½**:
- å¤æ™®æ¯”ç‡
- æœ€å¤§å›æ’¤
- èƒœç‡ç»Ÿè®¡
- å¹´åŒ–æ³¢åŠ¨ç‡

#### æ­¥éª¤1.3ï¼šå¯è§†åŒ–å›¾è¡¨ (20åˆ†é’Ÿ)
```bash
# åˆ›å»º analysis/visualization.py
```

**æ–°å¢åŠŸèƒ½**:
- èµ„é‡‘æ›²çº¿å›¾
- æŒä»“å˜åŒ–å›¾
- ç­–ç•¥ä¿¡å·å›¾

### è¿­ä»£2ï¼šç­–ç•¥ä¼˜åŒ–å™¨ (45åˆ†é’Ÿ)
**ç›®æ ‡**: è‡ªåŠ¨ä¼˜åŒ–ç­–ç•¥å‚æ•°

#### æ­¥éª¤2.1ï¼šå‚æ•°ä¼˜åŒ–æ¡†æ¶ (25åˆ†é’Ÿ)
```bash
# åˆ›å»º optimization/optimizer.py
mkdir -p pulse_trader/optimization
touch pulse_trader/optimization/__init__.py
```

**æ–°å¢åŠŸèƒ½**:
- ç½‘æ ¼æœç´¢
- é—ä¼ ç®—æ³•ï¼ˆç®€åŒ–ç‰ˆï¼‰
- å‚æ•°è¯„ä¼°æŒ‡æ ‡

#### æ­¥éª¤2.2ï¼šç­–ç•¥å‚æ•°è‡ªåŠ¨è°ƒä¼˜ (20åˆ†é’Ÿ)
```bash
# åˆ›å»º optimization/strategies.py
```

**æ–°å¢åŠŸèƒ½**:
- MAå‚æ•°ä¼˜åŒ–
- è‡ªåŠ¨å¯»æ‰¾æœ€ä½³å‚æ•°ç»„åˆ
- ä¼˜åŒ–ç»“æœå±•ç¤º

### è¿­ä»£3ï¼šå¤šç­–ç•¥æ¡†æ¶ (60åˆ†é’Ÿ)
**ç›®æ ‡**: æ”¯æŒè¿è¡Œå¤šä¸ªç­–ç•¥å¹¶æ¯”è¾ƒ

#### æ­¥éª¤3.1ï¼šç­–ç•¥æ³¨å†Œç³»ç»Ÿ (20åˆ†é’Ÿ)
```bash
# åˆ›å»º strategies/base.py å’Œ strategies/registry.py
```

**æ–°å¢åŠŸèƒ½**:
- ç­–ç•¥åŸºç±»
- ç­–ç•¥æ³¨å†Œå™¨
- ç­–ç•¥é…ç½®ç®¡ç†

#### æ­¥éª¤3.2ï¼šç»„åˆç­–ç•¥ (20åˆ†é’Ÿ)
```bash
# åˆ›å»º strategies/portfolio.py
```

**æ–°å¢åŠŸèƒ½**:
- å¤šç­–ç•¥ç»„åˆ
- èµ„é‡‘åˆ†é…
- ç­–ç•¥ç›¸å…³æ€§åˆ†æ

#### æ­¥éª¤3.3ï¼šç­–ç•¥æ¯”è¾ƒæŠ¥å‘Š (20åˆ†é’Ÿ)
```bash
# åˆ›å»º analysis/comparison.py
```

**æ–°å¢åŠŸèƒ½**:
- ç­–ç•¥æ€§èƒ½å¯¹æ¯”
- æ”¶ç›Šé£é™©å¯¹æ¯”
- æ’è¡Œæ¦œ

### è¿­ä»£4ï¼šæ•°æ®å¢å¼º (45åˆ†é’Ÿ)
**ç›®æ ‡**: æ›´ä¸°å¯Œå’Œç¨³å®šçš„æ•°æ®æº

#### æ­¥éª¤4.1ï¼šå¤šæ•°æ®æºæ”¯æŒ (20åˆ†é’Ÿ)
```bash
# å¢å¼º data/source.py
```

**æ–°å¢åŠŸèƒ½**:
- AkShareæ•°æ®æº
- æ•°æ®æºè‡ªåŠ¨åˆ‡æ¢
- æ•°æ®è´¨é‡æ£€æŸ¥

#### æ­¥éª¤4.2ï¼šæ•°æ®ç¼“å­˜ç³»ç»Ÿ (25åˆ†é’Ÿ)
```bash
# åˆ›å»º data/cache.py
```

**æ–°å¢åŠŸèƒ½**:
- æœ¬åœ°æ•°æ®ç¼“å­˜
- å¢é‡æ•°æ®æ›´æ–°
- æ•°æ®ç‰ˆæœ¬ç®¡ç†

### è¿­ä»£5ï¼šé…ç½®ç®¡ç†ç³»ç»Ÿ (30åˆ†é’Ÿ)
**ç›®æ ‡**: çµæ´»çš„é…ç½®ç®¡ç†

#### æ­¥éª¤5.1ï¼šé…ç½®æ–‡ä»¶é‡æ„ (15åˆ†é’Ÿ)
```bash
# å®Œå–„ config/ ç›®å½•ç»“æ„
```

**æ–°å¢åŠŸèƒ½**:
- YAMLé…ç½®æ–‡ä»¶
- ç¯å¢ƒé…ç½®åˆ†ç¦»
- é…ç½®éªŒè¯

#### æ­¥éª¤5.2ï¼šæ—¥å¿—ç³»ç»Ÿ (15åˆ†é’Ÿ)
```bash
# åˆ›å»º utils/logger.py
```

**æ–°å¢åŠŸèƒ½**:
- ç»“æ„åŒ–æ—¥å¿—
- ä¸åŒçº§åˆ«æ—¥å¿—
- æ—¥å¿—è½®è½¬

---

## ğŸš€ è¿­ä»£1ï¼šå®Œå–„å›æµ‹ç³»ç»Ÿï¼ˆè¯¦ç»†å®ç°ï¼‰

### æ­¥éª¤1.1ï¼šå¢å¼ºå›æµ‹å¼•æ“

#### ä¿®æ”¹ pulse_trader/backtest/engine.py

```python
import pandas as pd
import numpy as np
from typing import List, Dict, Optional
from dataclasses import dataclass
from datetime import datetime

@dataclass
class Trade:
    """äº¤æ˜“è®°å½•"""
    symbol: str
    entry_date: datetime
    exit_date: Optional[datetime]
    entry_price: float
    exit_price: Optional[float]
    quantity: int
    direction: str  # 'long' or 'short'
    pnl: float = 0.0
    commission: float = 0.0

@dataclass
class Position:
    """æŒä»“ä¿¡æ¯"""
    symbol: str
    quantity: int
    entry_price: float
    entry_date: datetime
    direction: str

class EnhancedBacktestEngine:
    """å¢å¼ºçš„å›æµ‹å¼•æ“"""

    def __init__(self,
                 capital: float = 100000,
                 commission_rate: float = 0.001,  # 0.1% æ‰‹ç»­è´¹
                 slippage_rate: float = 0.001,    # 0.1% æ»‘ç‚¹
                 min_commission: float = 5.0):    # æœ€ä½æ‰‹ç»­è´¹5å…ƒ

        self.initial_capital = capital
        self.capital = capital
        self.commission_rate = commission_rate
        self.slippage_rate = slippage_rate
        self.min_commission = min_commission

        self.position = {}  # å½“å‰æŒä»“
        self.trades: List[Trade] = []  # æ‰€æœ‰äº¤æ˜“è®°å½•
        self.daily_capital = []  # æ¯æ—¥èµ„é‡‘è®°å½•
        self.positions_history = []  # æŒä»“å†å²

    def calculate_commission(self, amount: float) -> float:
        """è®¡ç®—æ‰‹ç»­è´¹"""
        commission = amount * self.commission_rate
        return max(commission, self.min_commission)

    def apply_slippage(self, price: float, direction: str) -> float:
        """åº”ç”¨æ»‘ç‚¹"""
        slippage = price * self.slippage_rate
        if direction == 'buy':
            return price + slippage
        else:
            return price - slippage

    def execute_trade(self, symbol: str, direction: str, quantity: int,
                     price: float, date: datetime):
        """æ‰§è¡Œäº¤æ˜“"""

        # è®¡ç®—å®é™…æˆäº¤ä»·æ ¼ï¼ˆåŒ…å«æ»‘ç‚¹ï¼‰
        actual_price = self.apply_slippage(price, direction)

        # è®¡ç®—äº¤æ˜“é‡‘é¢å’Œæ‰‹ç»­è´¹
        trade_amount = actual_price * quantity
        commission = self.calculate_commission(trade_amount)

        if direction == 'buy':
            # ä¹°å…¥
            total_cost = trade_amount + commission
            if self.capital >= total_cost:
                self.capital -= total_cost

                # æ›´æ–°æˆ–åˆ›å»ºæŒä»“
                if symbol in self.position:
                    # åŠ ä»“
                    old_pos = self.position[symbol]
                    new_quantity = old_pos.quantity + quantity
                    new_price = (old_pos.quantity * old_pos.entry_price +
                               quantity * actual_price) / new_quantity
                    self.position[symbol] = Position(
                        symbol, new_quantity, new_price, date, 'long'
                    )
                else:
                    # æ–°å»ºæŒä»“
                    self.position[symbol] = Position(
                        symbol, quantity, actual_price, date, 'long'
                    )

                return True

        elif direction == 'sell':
            # å–å‡º
            if symbol in self.position and self.position[symbol].quantity >= quantity:
                # è®¡ç®—æ”¶ç›Š
                total_proceeds = trade_amount - commission
                self.capital += total_proceeds

                # è®°å½•äº¤æ˜“
                pos = self.position[symbol]
                pnl = (actual_price - pos.entry_price) * quantity - commission

                trade = Trade(
                    symbol=symbol,
                    entry_date=pos.entry_date,
                    exit_date=date,
                    entry_price=pos.entry_price,
                    exit_price=actual_price,
                    quantity=quantity,
                    direction='long',
                    pnl=pnl,
                    commission=commission
                )
                self.trades.append(trade)

                # æ›´æ–°æŒä»“
                remaining_quantity = pos.quantity - quantity
                if remaining_quantity > 0:
                    self.position[symbol] = Position(
                        symbol, remaining_quantity, pos.entry_price,
                        pos.entry_date, 'long'
                    )
                else:
                    del self.position[symbol]

                return True

        return False

    def run(self, data_with_signals: pd.DataFrame, symbol: str = "STOCK"):
        """è¿è¡Œå›æµ‹"""
        signals = data_with_signals['signal']
        prices = data_with_signals['close']

        for date, (signal, price) in enumerate(zip(signals, prices)):
            current_date = data_with_signals.index[date]

            # è®°å½•å½“å‰æ€»èµ„äº§
            position_value = sum(pos.quantity * price for pos in self.position.values())
            total_value = self.capital + position_value
            self.daily_capital.append({
                'date': current_date,
                'capital': self.capital,
                'position_value': position_value,
                'total_value': total_value,
                'position_count': len(self.position)
            })

            # äº¤æ˜“é€»è¾‘
            if signal == 1 and symbol not in self.position:  # ä¹°å…¥ä¿¡å·
                # è®¡ç®—å¯ä¹°æ•°é‡ï¼ˆä½¿ç”¨90%èµ„é‡‘é¿å…è¿‡åº¦æ æ†ï¼‰
                available_capital = self.capital * 0.9
                quantity = int(available_capital / price)

                if quantity > 0:
                    self.execute_trade(symbol, 'buy', quantity, price, current_date)

            elif signal == -1 and symbol in self.position:  # å–å‡ºä¿¡å·
                pos = self.position[symbol]
                self.execute_trade(symbol, 'sell', pos.quantity, price, current_date)

        # æœ€ç»ˆæ¸…ä»“
        final_date = data_with_signals.index[-1]
        final_price = data_with_signals['close'].iloc[-1]

        for symbol_pos in list(self.position.keys()):
            pos = self.position[symbol_pos]
            self.execute_trade(symbol_pos, 'sell', pos.quantity, final_price, final_date)

        # è®¡ç®—æœ€ç»ˆèµ„äº§
        final_value = self.capital

        # è½¬æ¢ä¸ºDataFrameä¾¿äºåˆ†æ
        self.daily_capital = pd.DataFrame(self.daily_capital).set_index('date')

        return final_value

    def get_trades_df(self) -> pd.DataFrame:
        """è·å–äº¤æ˜“è®°å½•DataFrame"""
        if not self.trades:
            return pd.DataFrame()

        trades_data = []
        for trade in self.trades:
            trades_data.append({
                'symbol': trade.symbol,
                'entry_date': trade.entry_date,
                'exit_date': trade.exit_date,
                'entry_price': trade.entry_price,
                'exit_price': trade.exit_price,
                'quantity': trade.quantity,
                'pnl': trade.pnl,
                'commission': trade.commission,
                'return_pct': (trade.exit_price - trade.entry_price) / trade.entry_price
            })

        return pd.DataFrame(trades_data)

    def get_equity_curve(self) -> pd.DataFrame:
        """è·å–èµ„é‡‘æ›²çº¿"""
        return self.daily_capital.copy()
```

### æ­¥éª¤1.2ï¼šé£é™©æŒ‡æ ‡è®¡ç®—

#### åˆ›å»º pulse_trader/backtest/metrics.py

```python
import pandas as pd
import numpy as np
from typing import Dict, Any

class PerformanceMetrics:
    """ç­–ç•¥ç»©æ•ˆæŒ‡æ ‡è®¡ç®—"""

    @staticmethod
    def calculate_returns(equity_curve: pd.DataFrame) -> pd.Series:
        """è®¡ç®—æ—¥æ”¶ç›Šç‡"""
        return equity_curve['total_value'].pct_change().dropna()

    @staticmethod
    def total_return(final_value: float, initial_capital: float) -> float:
        """æ€»æ”¶ç›Šç‡"""
        return (final_value - initial_capital) / initial_capital

    @staticmethod
    def annual_return(returns: pd.Series) -> float:
        """å¹´åŒ–æ”¶ç›Šç‡"""
        if len(returns) == 0:
            return 0.0
        total_days = len(returns)
        return (1 + returns.mean()) ** 252 - 1

    @staticmethod
    def annual_volatility(returns: pd.Series) -> float:
        """å¹´åŒ–æ³¢åŠ¨ç‡"""
        if len(returns) == 0:
            return 0.0
        return returns.std() * np.sqrt(252)

    @staticmethod
    def sharpe_ratio(returns: pd.Series, risk_free_rate: float = 0.03) -> float:
        """å¤æ™®æ¯”ç‡"""
        if len(returns) == 0 or returns.std() == 0:
            return 0.0

        excess_return = returns.mean() * 252 - risk_free_rate
        return excess_return / (returns.std() * np.sqrt(252))

    @staticmethod
    def max_drawdown(equity_curve: pd.DataFrame) -> Dict[str, Any]:
        """æœ€å¤§å›æ’¤"""
        values = equity_curve['total_value'].values
        peak = np.maximum.accumulate(values)
        drawdown = (values - peak) / peak
        max_dd = drawdown.min()

        # æ‰¾åˆ°æœ€å¤§å›æ’¤æœŸé—´
        max_dd_idx = drawdown.argmin()
        peak_idx = drawdown[:max_dd_idx].argmin()

        return {
            'max_drawdown': abs(max_dd),
            'max_drawdown_pct': f"{abs(max_dd):.2%}",
            'peak_date': equity_curve.index[peak_idx],
            'trough_date': equity_curve.index[max_dd_idx]
        }

    @staticmethod
    def win_rate(trades_df: pd.DataFrame) -> Dict[str, Any]:
        """èƒœç‡ç»Ÿè®¡"""
        if trades_df.empty:
            return {'win_rate': 0, 'total_trades': 0}

        winning_trades = trades_df[trades_df['pnl'] > 0]
        losing_trades = trades_df[trades_df['pnl'] <= 0]

        return {
            'win_rate': len(winning_trades) / len(trades_df),
            'win_rate_pct': f"{len(winning_trades) / len(trades_df):.1%}",
            'total_trades': len(trades_df),
            'winning_trades': len(winning_trades),
            'losing_trades': len(losing_trades),
            'avg_win': winning_trades['pnl'].mean() if len(winning_trades) > 0 else 0,
            'avg_loss': losing_trades['pnl'].mean() if len(losing_trades) > 0 else 0,
            'profit_factor': abs(winning_trades['pnl'].sum() / losing_trades['pnl'].sum())
                           if len(losing_trades) > 0 and losing_trades['pnl'].sum() != 0 else float('inf')
        }

    @staticmethod
    def calculate_all_metrics(equity_curve: pd.DataFrame,
                            trades_df: pd.DataFrame,
                            initial_capital: float) -> Dict[str, Any]:
        """è®¡ç®—æ‰€æœ‰æŒ‡æ ‡"""

        returns = PerformanceMetrics.calculate_returns(equity_curve)
        final_value = equity_curve['total_value'].iloc[-1]

        metrics = {
            # åŸºç¡€æ”¶ç›ŠæŒ‡æ ‡
            'initial_capital': initial_capital,
            'final_value': final_value,
            'total_return': PerformanceMetrics.total_return(final_value, initial_capital),
            'total_return_pct': f"{PerformanceMetrics.total_return(final_value, initial_capital):.2%}",
            'annual_return': PerformanceMetrics.annual_return(returns),
            'annual_return_pct': f"{PerformanceMetrics.annual_return(returns):.2%}",

            # é£é™©æŒ‡æ ‡
            'annual_volatility': PerformanceMetrics.annual_volatility(returns),
            'annual_volatility_pct': f"{PerformanceMetrics.annual_volatility(returns):.2%}",
            'sharpe_ratio': PerformanceMetrics.sharpe_ratio(returns),

            # å›æ’¤æŒ‡æ ‡
            **PerformanceMetrics.max_drawdown(equity_curve),

            # äº¤æ˜“ç»Ÿè®¡
            **PerformanceMetrics.win_rate(trades_df)
        }

        return metrics
```

### æ­¥éª¤1.3ï¼šå¯è§†åŒ–å›¾è¡¨

#### åˆ›å»º pulse_trader/analysis/visualization.py

```python
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from typing import Dict, Any, Optional
import numpy as np

# è®¾ç½®ä¸­æ–‡å­—ä½“
plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False

class BacktestVisualizer:
    """å›æµ‹å¯è§†åŒ–å·¥å…·"""

    def __init__(self, style: str = 'seaborn-v0_8'):
        plt.style.use(style)
        self.colors = ['#2E86AB', '#A23B72', '#F18F01', '#C73E1D']

    def plot_equity_curve(self, equity_curve: pd.DataFrame,
                         save_path: Optional[str] = None):
        """ç»˜åˆ¶èµ„é‡‘æ›²çº¿"""
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))

        # èµ„é‡‘æ›²çº¿
        ax1.plot(equity_curve.index, equity_curve['total_value'],
                color=self.colors[0], linewidth=2, label='æ€»èµ„äº§')
        ax1.plot(equity_curve.index, equity_curve['capital'],
                color=self.colors[1], linewidth=1, alpha=0.7, label='å¯ç”¨èµ„é‡‘')
        ax1.plot(equity_curve.index, equity_curve['position_value'],
                color=self.colors[2], linewidth=1, alpha=0.7, label='æŒä»“ä»·å€¼')

        ax1.set_title('èµ„é‡‘æ›²çº¿', fontsize=16, fontweight='bold')
        ax1.set_ylabel('èµ„äº§ä»·å€¼', fontsize=12)
        ax1.legend()
        ax1.grid(True, alpha=0.3)

        # æŒä»“æ•°é‡
        ax2.plot(equity_curve.index, equity_curve['position_count'],
                color=self.colors[3], linewidth=2)
        ax2.fill_between(equity_curve.index, equity_curve['position_count'],
                         alpha=0.3, color=self.colors[3])
        ax2.set_title('æŒä»“æ•°é‡', fontsize=14)
        ax2.set_ylabel('æŒä»“æ•°é‡', fontsize=12)
        ax2.set_xlabel('æ—¥æœŸ', fontsize=12)
        ax2.grid(True, alpha=0.3)

        plt.tight_layout()
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        plt.show()

    def plot_strategy_signals(self, data_with_signals: pd.DataFrame,
                            save_path: Optional[str] = None):
        """ç»˜åˆ¶ç­–ç•¥ä¿¡å·"""
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))

        # ä»·æ ¼å’Œç§»åŠ¨å¹³å‡çº¿
        ax1.plot(data_with_signals.index, data_with_signals['close'],
                color=self.colors[0], linewidth=2, label='æ”¶ç›˜ä»·')
        ax1.plot(data_with_signals.index, data_with_signals['ma_fast'],
                color=self.colors[1], linewidth=1.5, label='å¿«é€Ÿå‡çº¿')
        ax1.plot(data_with_signals.index, data_with_signals['ma_slow'],
                color=self.colors[2], linewidth=1.5, label='æ…¢é€Ÿå‡çº¿')

        # ä¹°å–ä¿¡å·
        buy_signals = data_with_signals[data_with_signals['signal'] == 1]
        sell_signals = data_with_signals[data_with_signals['signal'] == -1]

        ax1.scatter(buy_signals.index, buy_signals['close'],
                   color='green', marker='^', s=100, label='ä¹°å…¥ä¿¡å·', zorder=5)
        ax1.scatter(sell_signals.index, sell_signals['close'],
                   color='red', marker='v', s=100, label='å–å‡ºä¿¡å·', zorder=5)

        ax1.set_title('ä»·æ ¼ä¸äº¤æ˜“ä¿¡å·', fontsize=16, fontweight='bold')
        ax1.set_ylabel('ä»·æ ¼', fontsize=12)
        ax1.legend()
        ax1.grid(True, alpha=0.3)

        # ä¿¡å·å›¾
        ax2.plot(data_with_signals.index, data_with_signals['signal'],
                color=self.colors[3], linewidth=1.5)
        ax2.fill_between(data_with_signals.index, data_with_signals['signal'],
                         alpha=0.3, color=self.colors[3])
        ax2.axhline(y=0, color='black', linestyle='--', alpha=0.5)
        ax2.set_title('äº¤æ˜“ä¿¡å·', fontsize=14)
        ax2.set_ylabel('ä¿¡å·', fontsize=12)
        ax2.set_xlabel('æ—¥æœŸ', fontsize=12)
        ax2.set_yticks([-1, 0, 1])
        ax2.set_yticklabels(['å–å‡º', 'æŒæœ‰', 'ä¹°å…¥'])
        ax2.grid(True, alpha=0.3)

        plt.tight_layout()
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        plt.show()

    def plot_drawdown(self, equity_curve: pd.DataFrame,
                     save_path: Optional[str] = None):
        """ç»˜åˆ¶å›æ’¤å›¾"""
        # è®¡ç®—å›æ’¤
        values = equity_curve['total_value'].values
        peak = np.maximum.accumulate(values)
        drawdown = (values - peak) / peak * 100

        fig, ax = plt.subplots(figsize=(12, 6))

        ax.fill_between(equity_curve.index, drawdown, 0,
                       color='red', alpha=0.3, label='å›æ’¤')
        ax.plot(equity_curve.index, drawdown, color='red', linewidth=1)

        # æ ‡è®°æœ€å¤§å›æ’¤
        max_dd_idx = drawdown.argmin()
        ax.scatter(equity_curve.index[max_dd_idx], drawdown[max_dd_idx],
                  color='darkred', s=100, zorder=5)
        ax.annotate(f'æœ€å¤§å›æ’¤: {drawdown[max_dd_idx]:.2f}%',
                   xy=(equity_curve.index[max_dd_idx], drawdown[max_dd_idx]),
                   xytext=(10, 10), textcoords='offset points',
                   bbox=dict(boxstyle='round,pad=0.3', facecolor='yellow', alpha=0.7),
                   arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0'))

        ax.set_title('ç­–ç•¥å›æ’¤åˆ†æ', fontsize=16, fontweight='bold')
        ax.set_ylabel('å›æ’¤ (%)', fontsize=12)
        ax.set_xlabel('æ—¥æœŸ', fontsize=12)
        ax.legend()
        ax.grid(True, alpha=0.3)

        plt.tight_layout()
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        plt.show()

    def plot_returns_distribution(self, equity_curve: pd.DataFrame,
                                 save_path: Optional[str] = None):
        """ç»˜åˆ¶æ”¶ç›Šç‡åˆ†å¸ƒ"""
        returns = equity_curve['total_value'].pct_change().dropna() * 100

        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))

        # æ”¶ç›Šç‡ç›´æ–¹å›¾
        ax1.hist(returns, bins=30, color=self.colors[0], alpha=0.7, edgecolor='black')
        ax1.axvline(returns.mean(), color='red', linestyle='--',
                   label=f'å‡å€¼: {returns.mean():.2f}%')
        ax1.set_title('æ—¥æ”¶ç›Šç‡åˆ†å¸ƒ', fontsize=14, fontweight='bold')
        ax1.set_xlabel('æ”¶ç›Šç‡ (%)', fontsize=12)
        ax1.set_ylabel('é¢‘æ¬¡', fontsize=12)
        ax1.legend()
        ax1.grid(True, alpha=0.3)

        # Q-Qå›¾
        from scipy import stats
        stats.probplot(returns, dist="norm", plot=ax2)
        ax2.set_title('æ”¶ç›Šç‡Q-Qå›¾', fontsize=14, fontweight='bold')
        ax2.grid(True, alpha=0.3)

        plt.tight_layout()
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        plt.show()

    def generate_report(self, equity_curve: pd.DataFrame,
                       trades_df: pd.DataFrame,
                       metrics: Dict[str, Any],
                       save_dir: str = "reports"):
        """ç”Ÿæˆå®Œæ•´çš„å¯è§†åŒ–æŠ¥å‘Š"""
        import os
        os.makedirs(save_dir, exist_ok=True)

        # ç”Ÿæˆå„ä¸ªå›¾è¡¨
        self.plot_equity_curve(equity_curve, f"{save_dir}/equity_curve.png")
        self.plot_strategy_signals(equity_curve.join(
            trades_df.groupby('entry_date').first()['return_pct']
        ).fillna(method='ffill'), f"{save_dir}/strategy_signals.png")
        self.plot_drawdown(equity_curve, f"{save_dir}/drawdown.png")
        self.plot_returns_distribution(equity_curve, f"{save_dir}/returns_dist.png")

        print(f"ğŸ“Š å¯è§†åŒ–æŠ¥å‘Šå·²ç”Ÿæˆåˆ° {save_dir}/ ç›®å½•")
        print("  - equity_curve.png: èµ„é‡‘æ›²çº¿")
        print("  - strategy_signals.png: ç­–ç•¥ä¿¡å·")
        print("  - drawdown.png: å›æ’¤åˆ†æ")
        print("  - returns_dist.png: æ”¶ç›Šç‡åˆ†å¸ƒ")
```

---

## ğŸ§ª è¿­ä»£1æµ‹è¯•è„šæœ¬

#### åˆ›å»º scripts/test_enhanced_backtest.py

```python
#!/usr/bin/env python3
"""
å¢å¼ºå›æµ‹ç³»ç»Ÿæµ‹è¯•è„šæœ¬
"""
import sys
import os
sys.path.append('.')

from pulse_trader.data.source import TushareDataSource
from pulse_trader.strategies.ma_cross import MACrossStrategy
from pulse_trader.backtest.engine import EnhancedBacktestEngine
from pulse_trader.backtest.metrics import PerformanceMetrics
from pulse_trader.analysis.visualization import BacktestVisualizer
import pandas as pd

def test_enhanced_backtest():
    """æµ‹è¯•å¢å¼ºå›æµ‹ç³»ç»Ÿ"""
    print("ğŸš€ æµ‹è¯•å¢å¼ºå›æµ‹ç³»ç»Ÿ...")

    # 1. è·å–æ•°æ®
    print("\nğŸ“ˆ è·å–æ•°æ®...")
    data_source = TushareDataSource()
    data = data_source.get_data("000001.SZ", "20240101", "20240630")
    print(f"æ•°æ®å½¢çŠ¶: {data.shape}")

    # 2. ç”Ÿæˆä¿¡å·
    print("\nğŸ¯ ç”Ÿæˆç­–ç•¥ä¿¡å·...")
    strategy = MACrossStrategy(fast=5, slow=20)
    signals = strategy.generate_signals(data)
    print(f"ä¿¡å·ç»Ÿè®¡: ä¹°å…¥{len(signals[signals['signal']==1]}æ¬¡, å–å‡º{len(signals[signals['signal']==-1]}æ¬¡")

    # 3. è¿è¡Œå¢å¼ºå›æµ‹
    print("\nâš™ï¸ è¿è¡Œå¢å¼ºå›æµ‹...")
    engine = EnhancedBacktestEngine(
        capital=100000,
        commission_rate=0.001,
        slippage_rate=0.001
    )
    final_value = engine.run(signals)

    # 4. è®¡ç®—ç»©æ•ˆæŒ‡æ ‡
    print("\nğŸ“Š è®¡ç®—ç»©æ•ˆæŒ‡æ ‡...")
    equity_curve = engine.get_equity_curve()
    trades_df = engine.get_trades_df()
    metrics = PerformanceMetrics.calculate_all_metrics(
        equity_curve, trades_df, 100000
    )

    # 5. è¾“å‡ºç»“æœ
    print("\nğŸ“ˆ å›æµ‹ç»“æœ:")
    print(f"åˆå§‹èµ„é‡‘: {metrics['initial_capital']:,.0f}")
    print(f"æœ€ç»ˆä»·å€¼: {metrics['final_value']:,.0f}")
    print(f"æ€»æ”¶ç›Š: {metrics['total_return_pct']}")
    print(f"å¹´åŒ–æ”¶ç›Š: {metrics['annual_return_pct']}")
    print(f"å¹´åŒ–æ³¢åŠ¨: {metrics['annual_volatility_pct']}")
    print(f"å¤æ™®æ¯”ç‡: {metrics['sharpe_ratio']:.2f}")
    print(f"æœ€å¤§å›æ’¤: {metrics['max_drawdown_pct']}")
    print(f"èƒœç‡: {metrics['win_rate_pct']}")
    print(f"äº¤æ˜“æ¬¡æ•°: {metrics['total_trades']}")

    # 6. ç”Ÿæˆå¯è§†åŒ–æŠ¥å‘Š
    print("\nğŸ“Š ç”Ÿæˆå¯è§†åŒ–æŠ¥å‘Š...")
    visualizer = BacktestVisualizer()
    visualizer.generate_report(equity_curve, trades_df, metrics)

    return True

if __name__ == "__main__":
    test_enhanced_backtest()
```

### è¿è¡Œæµ‹è¯•

```bash
# ç¡®ä¿åœ¨é¡¹ç›®æ ¹ç›®å½•
cd /home/jackluo/PulseTrader

# æ¿€æ´»è™šæ‹Ÿç¯å¢ƒ
source .venv/bin/activate

# è®¾ç½®Tushare token
export TUSHARE_TOKEN=your_token_here

# è¿è¡Œæµ‹è¯•
python scripts/test_enhanced_backtest.py
```

### âœ… è¿­ä»£1æˆåŠŸæ ‡å‡†

è¿è¡Œæµ‹è¯•ååº”è¯¥çœ‹åˆ°ï¼š
- âœ… å¢å¼ºå›æµ‹å¼•æ“è¿è¡ŒæˆåŠŸ
- âœ… ç»©æ•ˆæŒ‡æ ‡è®¡ç®—å®Œæˆï¼ˆåŒ…å«å¤æ™®æ¯”ç‡ã€æœ€å¤§å›æ’¤ç­‰ï¼‰
- âœ… å¯è§†åŒ–æŠ¥å‘Šç”Ÿæˆï¼ˆ4ä¸ªå›¾è¡¨æ–‡ä»¶ï¼‰
- âœ… äº¤æ˜“è®°å½•å’Œèµ„é‡‘æ›²çº¿æ•°æ®æ­£ç¡®

---

## ğŸ¯ æ€»ç»“

è¿­ä»£1å®Œæˆåï¼Œä½ å°†æ‹¥æœ‰ï¼š
1. **ä¸“ä¸šçš„å›æµ‹å¼•æ“**ï¼šè€ƒè™‘æ‰‹ç»­è´¹ã€æ»‘ç‚¹ã€æŒä»“ç®¡ç†
2. **å®Œæ•´çš„ç»©æ•ˆæŒ‡æ ‡**ï¼šå¤æ™®æ¯”ç‡ã€æœ€å¤§å›æ’¤ã€èƒœç‡ç­‰
3. **ä¸°å¯Œçš„å¯è§†åŒ–**ï¼šèµ„é‡‘æ›²çº¿ã€ä¿¡å·å›¾ã€å›æ’¤åˆ†æç­‰
4. **è¯¦ç»†çš„äº¤æ˜“è®°å½•**ï¼šæ¯ç¬”äº¤æ˜“çš„å®Œæ•´ä¿¡æ¯

è¿™ä¸ºåç»­çš„ç­–ç•¥ä¼˜åŒ–å’Œå¤šç­–ç•¥æ¯”è¾ƒæ‰“ä¸‹äº†åšå®åŸºç¡€ï¼ğŸš€

**ä¸‹ä¸€æ­¥**: å¯ä»¥é€‰æ‹©ç»§ç»­è¿­ä»£2ï¼ˆç­–ç•¥ä¼˜åŒ–å™¨ï¼‰æˆ–æ ¹æ®å®é™…éœ€æ±‚è°ƒæ•´è¿­ä»£é¡ºåºã€‚