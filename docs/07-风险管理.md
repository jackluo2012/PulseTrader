# 风险管理框架

## 风险管理概述

风险管理是量化交易系统中至关重要的一环，它决定了交易系统的长期生存能力。一个优秀的风险管理系统能够在控制风险的前提下最大化收益。

### 风险类型

1. **市场风险**: 价格波动、市场系统性风险
2. **流动性风险**: 交易品种流动性不足
3. **信用风险**: 交易对手违约风险
4. **操作风险**: 系统故障、人为错误
5. **模型风险**: 策略模型失效风险

### 风险管理目标

- **资本保全**: 保护本金安全
- **回撤控制**: 限制最大回撤
- **波动率管理**: 控制收益波动
- **流动性保证**: 确保可及时平仓
- **合规管理**: 符合监管要求

## 风险管理架构

### 1. 风险管理基类

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
import pandas as pd
import numpy as np

class RiskLevel(Enum):
    """风险等级"""
    LOW = 1
    MEDIUM = 2
    HIGH = 3
    CRITICAL = 4

@dataclass
class RiskMetrics:
    """风险指标"""
    var_95: float           # 95%置信度VaR
    var_99: float           # 99%置信度VaR
    max_drawdown: float     # 最大回撤
    volatility: float       # 波动率
    sharpe_ratio: float     # 夏普比率
    beta: float             # Beta系数
    concentration: float    # 集中度
    liquidity_ratio: float  # 流动性比率

@dataclass
class RiskAlert:
    """风险警报"""
    level: RiskLevel
    type: str
    message: str
    current_value: float
    threshold: float
    timestamp: pd.Timestamp

class RiskManager(ABC):
    """风险管理器基类"""

    def __init__(self, name: str, **params):
        self.name = name
        self.params = params
        self.risk_limits = {}
        self.alerts_history = []

    @abstractmethod
    def assess_risk(self, portfolio: Dict, market_data: pd.DataFrame) -> RiskMetrics:
        """评估风险"""
        pass

    @abstractmethod
    def check_limits(self, risk_metrics: RiskMetrics) -> List[RiskAlert]:
        """检查风险限制"""
        pass

    @abstractmethod
    def generate_risk_report(self) -> Dict:
        """生成风险报告"""
        pass

    def set_risk_limit(self, metric: str, limit: float):
        """设置风险限制"""
        self.risk_limits[metric] = limit

    def get_current_alerts(self) -> List[RiskAlert]:
        """获取当前风险警报"""
        return [alert for alert in self.alerts_history
                if (pd.Timestamp.now() - alert.timestamp).total_seconds() < 3600]
```

### 2. 仓位管理

```python
class PositionManager:
    """仓位管理器"""

    def __init__(self, max_position_size: float = 0.2, max_total_exposure: float = 1.0):
        self.max_position_size = max_position_size      # 单个标的最大仓位
        self.max_total_exposure = max_total_exposure    # 总仓位上限
        self.positions = {}
        self.exposure_history = []

    def calculate_position_size(self, signal_strength: float, price: float,
                              available_capital: float, volatility: float = None) -> int:
        """计算建议仓位大小"""
        # 基础仓位（基于信号强度）
        base_position_ratio = min(signal_strength * self.max_position_size, self.max_position_size)

        # 基于波动率调整
        if volatility is not None:
            volatility_adjustment = max(0.5, min(1.5, 1.0 / (1.0 + volatility)))
            base_position_ratio *= volatility_adjustment

        # 计算实际仓位
        position_value = available_capital * base_position_ratio
        quantity = int(position_value / price / 100) * 100  # 整手

        return quantity

    def check_position_limit(self, symbol: str, new_quantity: int, price: float,
                           portfolio_value: float) -> Tuple[bool, str]:
        """检查仓位限制"""
        current_position = self.positions.get(symbol, {}).get('quantity', 0)
        total_position_value = sum(pos.get('quantity', 0) * pos.get('price', 0)
                                 for pos in self.positions.values())
        new_position_value = abs(new_quantity) * price

        # 检查单个标的仓位限制
        single_position_ratio = (current_position * price + new_position_value) / portfolio_value
        if single_position_ratio > self.max_position_size:
            return False, f"单个标的仓位超限: {single_position_ratio:.2%} > {self.max_position_size:.2%}"

        # 检查总仓位限制
        total_ratio = (total_position_value + new_position_value) / portfolio_value
        if total_ratio > self.max_total_exposure:
            return False, f"总仓位超限: {total_ratio:.2%} > {self.max_total_exposure:.2%}"

        return True, "仓位检查通过"

    def update_position(self, symbol: str, quantity: int, price: float, date: pd.Timestamp):
        """更新仓位"""
        if symbol not in self.positions:
            self.positions[symbol] = {
                'quantity': 0,
                'avg_price': 0,
                'total_cost': 0,
                'last_update': date
            }

        position = self.positions[symbol]

        if quantity > 0:  # 买入
            new_total_cost = position['total_cost'] + quantity * price
            new_total_quantity = position['quantity'] + quantity
            position['avg_price'] = new_total_cost / new_total_quantity if new_total_quantity > 0 else 0
            position['total_cost'] = new_total_cost
            position['quantity'] = new_total_quantity
        else:  # 卖出
            position['quantity'] += quantity  # quantity为负数
            if position['quantity'] <= 0:
                position['quantity'] = 0
                position['avg_price'] = 0
                position['total_cost'] = 0

        position['last_update'] = date

        # 记录仓位历史
        total_exposure = sum(pos.get('quantity', 0) * pos.get('avg_price', 0)
                           for pos in self.positions.values())
        self.exposure_history.append({
            'date': date,
            'total_exposure': total_exposure,
            'position_count': len([p for p in self.positions.values() if p.get('quantity', 0) > 0])
        })

    def get_portfolio_exposure(self) -> Dict:
        """获取组合敞口信息"""
        total_value = sum(pos.get('quantity', 0) * pos.get('avg_price', 0)
                         for pos in self.positions.values())

        exposures = {}
        for symbol, position in self.positions.items():
            if position.get('quantity', 0) > 0:
                position_value = position['quantity'] * position['avg_price']
                exposures[symbol] = {
                    'quantity': position['quantity'],
                    'avg_price': position['avg_price'],
                    'value': position_value,
                    'weight': position_value / total_value if total_value > 0 else 0
                }

        return {
            'total_value': total_value,
            'positions': exposures,
            'position_count': len(exposures)
        }
```

### 3. 止损管理

```python
class StopLossManager:
    """止损管理器"""

    def __init__(self, default_stop_loss: float = 0.05, default_take_profit: float = 0.1):
        self.default_stop_loss = default_stop_loss    # 默认止损比例
        self.default_take_profit = default_take_profit  # 默认止盈比例
        self.active_stops = {}  # 活跃止损单

    def set_stop_loss(self, symbol: str, entry_price: float,
                     stop_loss_pct: float = None, take_profit_pct: float = None):
        """设置止损止盈"""
        stop_loss_pct = stop_loss_pct or self.default_stop_loss
        take_profit_pct = take_profit_pct or self.default_take_profit

        self.active_stops[symbol] = {
            'entry_price': entry_price,
            'stop_loss_price': entry_price * (1 - stop_loss_pct),
            'take_profit_price': entry_price * (1 + take_profit_pct),
            'stop_loss_pct': stop_loss_pct,
            'take_profit_pct': take_profit_pct,
            'created_at': pd.Timestamp.now()
        }

    def check_stop_conditions(self, symbol: str, current_price: float) -> Dict[str, bool]:
        """检查止损条件"""
        if symbol not in self.active_stops:
            return {'stop_loss': False, 'take_profit': False}

        stop_info = self.active_stops[symbol]

        return {
            'stop_loss': current_price <= stop_info['stop_loss_price'],
            'take_profit': current_price >= stop_info['take_profit_price']
        }

    def update_trailing_stop(self, symbol: str, current_price: float, trailing_pct: float = 0.02):
        """更新移动止损"""
        if symbol not in self.active_stops:
            return

        stop_info = self.active_stops[symbol]

        # 只有价格上涨时才调整止损价
        if current_price > stop_info['entry_price']:
            new_stop_loss = current_price * (1 - trailing_pct)
            if new_stop_loss > stop_info['stop_loss_price']:
                stop_info['stop_loss_price'] = new_stop_loss
                stop_info['entry_price'] = current_price  # 更新基准价

    def remove_stop_loss(self, symbol: str):
        """移除止损单"""
        if symbol in self.active_stops:
            del self.active_stops[symbol]

    def get_all_stops(self) -> Dict:
        """获取所有止损单信息"""
        return self.active_stops.copy()

    def calculate_stop_loss_distance(self, symbol: str, current_price: float) -> float:
        """计算当前价格距离止损的距离"""
        if symbol not in self.active_stops:
            return 0.0

        stop_info = self.active_stops[symbol]
        return (current_price - stop_info['stop_loss_price']) / current_price
```

### 4. VaR风险计算

```python
class VaRCalculator:
    """VaR（风险价值）计算器"""

    def __init__(self, confidence_levels: List[float] = [0.95, 0.99]):
        self.confidence_levels = confidence_levels

    def calculate_historical_var(self, returns: pd.Series,
                               confidence_levels: List[float] = None) -> Dict[float, float]:
        """历史模拟法计算VaR"""
        confidence_levels = confidence_levels or self.confidence_levels
        var_results = {}

        for confidence in confidence_levels:
            var_value = returns.quantile(1 - confidence)
            var_results[confidence] = var_value

        return var_results

    def calculate_parametric_var(self, returns: pd.Series,
                               confidence_levels: List[float] = None) -> Dict[float, float]:
        """参数法计算VaR（假设正态分布）"""
        confidence_levels = confidence_levels or self.confidence_levels
        var_results = {}

        mean = returns.mean()
        std = returns.std()

        from scipy import stats

        for confidence in confidence_levels:
            z_score = stats.norm.ppf(1 - confidence)
            var_value = mean + z_score * std
            var_results[confidence] = var_value

        return var_results

    def calculate_monte_carlo_var(self, returns: pd.Series, n_simulations: int = 10000,
                                 confidence_levels: List[float] = None) -> Dict[float, float]:
        """蒙特卡洛模拟法计算VaR"""
        confidence_levels = confidence_levels or self.confidence_levels
        var_results = {}

        mean = returns.mean()
        std = returns.std()

        # 生成随机路径
        simulated_returns = np.random.normal(mean, std, n_simulations)

        for confidence in confidence_levels:
            var_value = np.percentile(simulated_returns, (1 - confidence) * 100)
            var_results[confidence] = var_value

        return var_results

    def calculate_conditional_var(self, returns: pd.Series, confidence: float = 0.95) -> float:
        """计算条件VaR（Expected Shortfall）"""
        var_threshold = returns.quantile(1 - confidence)
        tail_losses = returns[returns <= var_threshold]

        return tail_losses.mean() if len(tail_losses) > 0 else var_threshold
```

### 5. 回撤控制

```python
class DrawdownController:
    """回撤控制器"""

    def __init__(self, max_drawdown_limit: float = 0.15, warning_threshold: float = 0.10):
        self.max_drawdown_limit = max_drawdown_limit
        self.warning_threshold = warning_threshold
        self.peak_value = 0
        self.drawdown_history = []

    def calculate_drawdown(self, current_value: float) -> Dict[str, float]:
        """计算当前回撤"""
        # 更新峰值
        if current_value > self.peak_value:
            self.peak_value = current_value

        # 计算回撤
        drawdown = (self.peak_value - current_value) / self.peak_value

        # 记录回撤历史
        self.drawdown_history.append({
            'date': pd.Timestamp.now(),
            'portfolio_value': current_value,
            'peak_value': self.peak_value,
            'drawdown': drawdown
        })

        return {
            'current_drawdown': drawdown,
            'peak_value': self.peak_value,
            'current_value': current_value,
            'drawdown_amount': self.peak_value - current_value
        }

    def check_drawdown_limits(self, current_value: float) -> Dict[str, any]:
        """检查回撤限制"""
        drawdown_info = self.calculate_drawdown(current_value)
        current_drawdown = drawdown_info['current_drawdown']

        # 确定风险等级
        if current_drawdown >= self.max_drawdown_limit:
            risk_level = RiskLevel.CRITICAL
            action = "stop_trading"
            message = f"回撤超限，建议停止交易: {current_drawdown:.2%}"
        elif current_drawdown >= self.warning_threshold:
            risk_level = RiskLevel.HIGH
            action = "reduce_position"
            message = f"回撤接近上限，建议减仓: {current_drawdown:.2%}"
        elif current_drawdown >= self.warning_threshold * 0.7:
            risk_level = RiskLevel.MEDIUM
            action = "monitor"
            message = f"回撤警告，需要密切关注: {current_drawdown:.2%}"
        else:
            risk_level = RiskLevel.LOW
            action = "normal"
            message = "回撤正常"

        return {
            'risk_level': risk_level,
            'action': action,
            'message': message,
            'drawdown_info': drawdown_info
        }

    def get_max_drawdown(self, lookback_period: int = None) -> float:
        """获取历史最大回撤"""
        if lookback_period is None:
            drawdowns = [d['drawdown'] for d in self.drawdown_history]
        else:
            recent_data = self.drawdown_history[-lookback_period:]
            drawdowns = [d['drawdown'] for d in recent_data]

        return max(drawdowns) if drawdowns else 0.0

    def get_drawdown_duration(self) -> int:
        """获取当前回撤持续时间（天数）"""
        if not self.drawdown_history:
            return 0

        current_date = pd.Timestamp.now()
        peak_date = max((d['date'] for d in self.drawdown_history
                        if d['portfolio_value'] == self.peak_value),
                       default=current_date)

        return (current_date - peak_date).days
```

## 组合风险管理

### 1. 风险预算管理器

```python
class RiskBudgetManager:
    """风险预算管理器"""

    def __init__(self, total_risk_budget: float = 0.02):
        self.total_risk_budget = total_risk_budget  # 总风险预算（日VaR）
        self.risk_allocations = {}  # 各策略风险分配
        self.current_risk_usage = {}

    def allocate_risk_budget(self, strategy_name: str, allocation_pct: float):
        """分配风险预算"""
        if allocation_pct <= 0 or allocation_pct > 1:
            raise ValueError("风险分配比例必须在0-1之间")

        if sum(self.risk_allocations.values()) + allocation_pct > 1:
            raise ValueError("风险分配总和不能超过100%")

        self.risk_allocations[strategy_name] = allocation_pct

    def calculate_strategy_risk_limit(self, strategy_name: str) -> float:
        """计算策略风险限额"""
        allocation = self.risk_allocations.get(strategy_name, 0)
        return self.total_risk_budget * allocation

    def check_risk_budget_usage(self, strategy_name: str, current_var: float) -> Dict[str, any]:
        """检查风险预算使用情况"""
        risk_limit = self.calculate_strategy_risk_limit(strategy_name)
        usage_ratio = current_var / risk_limit if risk_limit > 0 else float('inf')

        if usage_ratio >= 1.0:
            status = "exceeded"
            action = "stop_trading"
        elif usage_ratio >= 0.8:
            status = "warning"
            action = "reduce_position"
        elif usage_ratio >= 0.6:
            status = "caution"
            action = "monitor"
        else:
            status = "normal"
            action = "continue"

        self.current_risk_usage[strategy_name] = {
            'current_var': current_var,
            'risk_limit': risk_limit,
            'usage_ratio': usage_ratio,
            'status': status,
            'action': action
        }

        return self.current_risk_usage[strategy_name]

    def get_portfolio_risk_summary(self) -> Dict:
        """获取组合风险摘要"""
        total_current_var = sum(usage['current_var']
                               for usage in self.current_risk_usage.values())
        total_limit = sum(self.calculate_strategy_risk_limit(name)
                         for name in self.risk_allocations.keys())

        return {
            'total_risk_budget': self.total_risk_budget,
            'total_current_var': total_current_var,
            'total_limit': total_limit,
            'portfolio_usage_ratio': total_current_var / self.total_risk_budget,
            'strategy_breakdown': self.current_risk_usage,
            'risk_allocations': self.risk_allocations
        }
```

### 2. 相关性风险控制

```python
class CorrelationRiskManager:
    """相关性风险管理器"""

    def __init__(self, max_correlation: float = 0.7):
        self.max_correlation = max_correlation
        self.correlation_matrix = None
        self.price_history = {}

    def update_price_data(self, symbol: str, price: float, date: pd.Timestamp):
        """更新价格数据"""
        if symbol not in self.price_history:
            self.price_history[symbol] = pd.Series(dtype=float)

        self.price_history[symbol][date] = price

    def calculate_correlation_matrix(self, lookback_days: int = 60) -> pd.DataFrame:
        """计算相关性矩阵"""
        if len(self.price_history) < 2:
            return pd.DataFrame()

        # 构建价格DataFrame
        price_df = pd.DataFrame(self.price_history)
        price_df = price_df.ffill()  # 前向填充

        # 计算收益率
        returns_df = price_df.pct_change().dropna()

        # 只使用最近的数据
        if len(returns_df) > lookback_days:
            returns_df = returns_df.tail(lookback_days)

        # 计算相关性矩阵
        self.correlation_matrix = returns_df.corr()
        return self.correlation_matrix

    def check_correlation_risk(self, symbols: List[str]) -> List[Dict]:
        """检查相关性风险"""
        if self.correlation_matrix is None:
            self.calculate_correlation_matrix()

        risk_alerts = []

        # 检查两两相关性
        for i, symbol1 in enumerate(symbols):
            for symbol2 in symbols[i+1:]:
                if (symbol1 in self.correlation_matrix.index and
                    symbol2 in self.correlation_matrix.columns):

                    correlation = self.correlation_matrix.loc[symbol1, symbol2]

                    if abs(correlation) > self.max_correlation:
                        risk_alerts.append({
                            'type': 'high_correlation',
                            'symbols': [symbol1, symbol2],
                            'correlation': correlation,
                            'threshold': self.max_correlation,
                            'risk_level': RiskLevel.MEDIUM if abs(correlation) < 0.9 else RiskLevel.HIGH
                        })

        return risk_alerts

    def calculate_portfolio_correlation(self, weights: Dict[str, float]) -> float:
        """计算组合加权相关性"""
        if self.correlation_matrix is None:
            return 0.0

        symbols = list(weights.keys())
        if len(symbols) < 2:
            return 0.0

        # 只计算有效符号的相关性
        valid_symbols = [s for s in symbols if s in self.correlation_matrix.index]
        if len(valid_symbols) < 2:
            return 0.0

        sub_matrix = self.correlation_matrix.loc[valid_symbols, valid_symbols]
        weight_array = np.array([weights[s] for s in valid_symbols])

        # 计算加权平均相关性
        correlation_sum = 0
        weight_sum = 0

        for i in range(len(valid_symbols)):
            for j in range(i+1, len(valid_symbols)):
                correlation_sum += abs(sub_matrix.iloc[i, j]) * weight_array[i] * weight_array[j]
                weight_sum += weight_array[i] * weight_array[j]

        return correlation_sum / weight_sum if weight_sum > 0 else 0.0
```

## 实时风险监控

### 1. 风险监控系统

```python
class RiskMonitor:
    """风险监控系统"""

    def __init__(self):
        self.position_manager = PositionManager()
        self.stop_loss_manager = StopLossManager()
        self.drawdown_controller = DrawdownController()
        self.var_calculator = VaRCalculator()
        self.risk_budget_manager = RiskBudgetManager()
        self.correlation_manager = CorrelationRiskManager()

        self.risk_alerts = []
        self.monitoring_active = False

    def start_monitoring(self):
        """启动风险监控"""
        self.monitoring_active = True
        print("风险监控已启动")

    def stop_monitoring(self):
        """停止风险监控"""
        self.monitoring_active = False
        print("风险监控已停止")

    def real_time_risk_check(self, portfolio: Dict, market_data: pd.DataFrame) -> Dict[str, any]:
        """实时风险检查"""
        if not self.monitoring_active:
            return {}

        risk_assessment = {
            'timestamp': pd.Timestamp.now(),
            'alerts': [],
            'risk_level': RiskLevel.LOW,
            'recommendations': []
        }

        try:
            # 1. 仓位风险检查
            portfolio_value = sum(pos.get('quantity', 0) * price
                                for pos in portfolio.values()
                                for price in [market_data.get('close', {}).get(symbol, 0)])

            for symbol, position in portfolio.items():
                if position.get('quantity', 0) > 0:
                    current_price = market_data.get('close', {}).get(symbol, 0)
                    if current_price > 0:
                        can_add, message = self.position_manager.check_position_limit(
                            symbol, 0, current_price, portfolio_value
                        )
                        if not can_add:
                            risk_assessment['alerts'].append({
                                'type': 'position_limit',
                                'symbol': symbol,
                                'message': message,
                                'level': RiskLevel.HIGH
                            })

            # 2. 止损检查
            for symbol, position in portfolio.items():
                if position.get('quantity', 0) > 0:
                    current_price = market_data.get('close', {}).get(symbol, 0)
                    if current_price > 0:
                        stop_conditions = self.stop_loss_manager.check_stop_conditions(symbol, current_price)
                        if stop_conditions['stop_loss']:
                            risk_assessment['alerts'].append({
                                'type': 'stop_loss_triggered',
                                'symbol': symbol,
                                'message': f"{symbol} 触发止损",
                                'level': RiskLevel.CRITICAL
                            })
                            risk_assessment['recommendations'].append(f"立即卖出 {symbol}")

                        if stop_conditions['take_profit']:
                            risk_assessment['alerts'].append({
                                'type': 'take_profit_triggered',
                                'symbol': symbol,
                                'message': f"{symbol} 触发止盈",
                                'level': RiskLevel.MEDIUM
                            })
                            risk_assessment['recommendations'].append(f"考虑卖出 {symbol}")

            # 3. 回撤检查
            if portfolio_value > 0:
                drawdown_check = self.drawdown_controller.check_drawdown_limits(portfolio_value)
                if drawdown_check['risk_level'] != RiskLevel.LOW:
                    risk_assessment['alerts'].append({
                        'type': 'drawdown_risk',
                        'message': drawdown_check['message'],
                        'level': drawdown_check['risk_level']
                    })
                    risk_assessment['recommendations'].append(drawdown_check['action'])

            # 4. 相关性风险检查
            symbols = list(portfolio.keys())
            if len(symbols) > 1:
                correlation_risks = self.correlation_manager.check_correlation_risk(symbols)
                for risk in correlation_risks:
                    risk_assessment['alerts'].append({
                        'type': 'correlation_risk',
                        'message': f"高相关性风险: {risk['symbols']}, 相关性: {risk['correlation']:.2f}",
                        'level': risk['risk_level']
                    })

            # 5. 确定整体风险等级
            if risk_assessment['alerts']:
                max_risk_level = max(alert['level'] for alert in risk_assessment['alerts'])
                risk_assessment['risk_level'] = max_risk_level

        except Exception as e:
            risk_assessment['alerts'].append({
                'type': 'monitoring_error',
                'message': f"风险监控错误: {e}",
                'level': RiskLevel.HIGH
            })

        return risk_assessment

    def generate_risk_report(self, portfolio: Dict, returns: pd.Series) -> Dict:
        """生成风险报告"""
        try:
            # 计算VaR
            var_results = self.var_calculator.calculate_historical_var(returns)

            # 计算回撤
            current_value = portfolio.get('total_value', 0)
            drawdown_info = self.drawdown_controller.calculate_drawdown(current_value)

            # 仓位信息
            position_info = self.position_manager.get_portfolio_exposure()

            # 止损信息
            stop_info = self.stop_loss_manager.get_all_stops()

            report = {
                'timestamp': pd.Timestamp.now(),
                'var_metrics': var_results,
                'drawdown_metrics': drawdown_info,
                'position_metrics': position_info,
                'stop_loss_metrics': {
                    'active_stops': len(stop_info),
                    'stop_details': stop_info
                },
                'portfolio_value': current_value,
                'risk_alerts': self.risk_alerts[-10:]  # 最近10个警报
            }

            return report

        except Exception as e:
            return {
                'error': f"生成风险报告失败: {e}",
                'timestamp': pd.Timestamp.now()
            }

    def send_risk_alert(self, alert: Dict):
        """发送风险警报"""
        self.risk_alerts.append(alert)

        # 这里可以添加实际的警报发送逻辑
        print(f"风险警报: {alert['message']} (等级: {alert['level'].name})")

        # 如果是严重风险，可以发送邮件或短信
        if alert['level'] == RiskLevel.CRITICAL:
            self.send_critical_alert(alert)

    def send_critical_alert(self, alert: Dict):
        """发送严重风险警报"""
        # 实现具体的严重警报发送逻辑
        print(f"!!! 严重风险警报: {alert['message']} !!!")
        # 可以集成邮件、短信、钉钉等通知方式
```

## 风险事件处理

### 1. 风险事件处理器

```python
class RiskEventHandler:
    """风险事件处理器"""

    def __init__(self, risk_monitor: RiskMonitor):
        self.risk_monitor = risk_monitor
        self.event_handlers = {
            RiskLevel.LOW: self._handle_low_risk,
            RiskLevel.MEDIUM: self._handle_medium_risk,
            RiskLevel.HIGH: self._handle_high_risk,
            RiskLevel.CRITICAL: self._handle_critical_risk
        }

    def handle_risk_event(self, risk_assessment: Dict):
        """处理风险事件"""
        risk_level = risk_assessment['risk_level']
        alerts = risk_assessment['alerts']
        recommendations = risk_assessment['recommendations']

        # 调用对应的风险处理器
        handler = self.event_handlers.get(risk_level, self._handle_unknown_risk)
        handler(risk_assessment)

        # 记录风险事件
        self._log_risk_event(risk_assessment)

    def _handle_low_risk(self, risk_assessment: Dict):
        """处理低风险事件"""
        print(f"低风险等级，正常监控: {len(risk_assessment['alerts'])} 个提醒")

    def _handle_medium_risk(self, risk_assessment: Dict):
        """处理中等风险事件"""
        print(f"中等风险等级，需要关注: {len(risk_assessment['alerts'])} 个警报")
        print(f"建议措施: {', '.join(risk_assessment['recommendations'])}")

    def _handle_high_risk(self, risk_assessment: Dict):
        """处理高风险事件"""
        print(f"高风险等级，建议减仓: {len(risk_assessment['alerts'])} 个警报")

        # 自动执行一些风险控制措施
        for alert in risk_assessment['alerts']:
            if alert['type'] == 'position_limit':
                print(f"仓位超限警告: {alert['message']}")
            elif alert['type'] == 'drawdown_risk':
                print(f"回撤风险: {alert['message']}")

    def _handle_critical_risk(self, risk_assessment: Dict):
        """处理严重风险事件"""
        print(f"!!! 严重风险等级，建议停止交易 !!!")
        print(f"警报数量: {len(risk_assessment['alerts'])}")

        # 发送紧急通知
        for alert in risk_assessment['alerts']:
            self.risk_monitor.send_risk_alert(alert)

        # 可以触发紧急停止机制
        self._emergency_stop()

    def _handle_unknown_risk(self, risk_assessment: Dict):
        """处理未知风险事件"""
        print("未知风险等级，使用默认处理方式")

    def _log_risk_event(self, risk_assessment: Dict):
        """记录风险事件"""
        log_entry = {
            'timestamp': risk_assessment['timestamp'],
            'risk_level': risk_assessment['risk_level'].name,
            'alerts_count': len(risk_assessment['alerts']),
            'recommendations': risk_assessment['recommendations']
        }

        # 这里可以写入日志文件或数据库
        print(f"风险事件记录: {log_entry}")

    def _emergency_stop(self):
        """紧急停止机制"""
        print("执行紧急停止机制...")
        # 停止所有交易
        # 平仓所有头寸
        # 发送紧急通知
```

## 使用示例

### 1. 完整的风险管理流程

```python
def risk_management_example():
    """风险管理使用示例"""
    # 初始化风险管理组件
    risk_monitor = RiskMonitor()
    risk_handler = RiskEventHandler(risk_monitor)

    # 启动监控
    risk_monitor.start_monitoring()

    # 模拟投资组合
    portfolio = {
        '000001.SZ': {'quantity': 1000, 'avg_price': 15.0},
        '000002.SZ': {'quantity': 500, 'avg_price': 25.0},
        'total_value': 27500
    }

    # 模拟市场数据
    market_data = {
        'close': {
            '000001.SZ': 14.5,  # 下跌3.3%
            '000002.SZ': 26.2   # 上涨4.8%
        }
    }

    # 设置止损
    risk_monitor.stop_loss_manager.set_stop_loss('000001.SZ', 15.0, 0.05, 0.1)

    # 模拟收益率序列
    returns = pd.Series([0.01, -0.02, 0.015, -0.01, 0.005, -0.025, 0.02])

    # 实时风险检查
    risk_assessment = risk_monitor.real_time_risk_check(portfolio, market_data)

    # 处理风险事件
    if risk_assessment['alerts']:
        risk_handler.handle_risk_event(risk_assessment)

    # 生成风险报告
    risk_report = risk_monitor.generate_risk_report(portfolio, returns)

    print("\n风险报告:")
    print(f"VaR(95%): {risk_report.get('var_metrics', {}).get(0.95, 0):.4f}")
    print(f"当前回撤: {risk_report.get('drawdown_metrics', {}).get('current_drawdown', 0):.2%}")
    print(f"活跃止损单: {risk_report.get('stop_loss_metrics', {}).get('active_stops', 0)}")

    # 停止监控
    risk_monitor.stop_monitoring()

if __name__ == "__main__":
    risk_management_example()
```

## 最佳实践

### 1. 风险管理原则
- **保守原则**: 宁可错过机会，不要承担过大风险
- **分散化**: 不要把所有资金投入单一品种
- **动态调整**: 根据市场环境调整风险参数
- **持续监控**: 实时监控风险指标变化

### 2. 参数设置建议
- **止损比例**: 单笔交易2-5%
- **最大回撤**: 组合整体10-20%
- **集中度限制**: 单个品种不超过组合的20%
- **相关性控制**: 避免过度集中高相关品种

### 3. 系统设计要点
- **模块化**: 各风险模块独立，便于维护
- **可扩展**: 支持新增风险指标和规则
- **高性能**: 实时计算不能影响交易速度
- **容错性**: 风险系统故障不能影响正常交易

## 下一步

完成风险管理模块后，您可以：
1. 学习[回测系统](08-回测系统.md)
2. 探索[实盘交易](09-实盘交易.md)
3. 深入[性能优化](10-性能优化.md)