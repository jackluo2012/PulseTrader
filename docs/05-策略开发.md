# 策略开发教程

## 策略开发概述

量化策略是量化交易系统的核心，它基于技术指标、统计模型或其他分析方法来生成交易信号。本教程将带您从零开始开发交易策略。

### 策略基本要素
1. **入场信号**: 何时买入或卖出
2. **出场信号**: 何时平仓
3. **仓位管理**: 买卖多少数量
4. **风险控制**: 止损止盈设置

## 策略基类设计

### 1. 策略基类

```python
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional
import pandas as pd
import numpy as np
from dataclasses import dataclass
from enum import Enum

class Signal(Enum):
    """交易信号枚举"""
    BUY = 1
    SELL = -1
    HOLD = 0

@dataclass
class Position:
    """持仓信息"""
    symbol: str
    quantity: int
    entry_price: float
    entry_date: pd.Timestamp
    current_price: float = 0.0

@dataclass
class SignalResult:
    """信号结果"""
    signal: Signal
    strength: float  # 信号强度 0-1
    reason: str      # 信号原因
    metadata: Dict[str, Any] = None  # 额外信息

class Strategy(ABC):
    """策略基类"""

    def __init__(self, name: str, params: Dict[str, Any] = None):
        self.name = name
        self.params = params or {}
        self.positions = {}  # 当前持仓
        self.signals_history = []  # 信号历史
        self.performance_metrics = {}  # 性能指标

    @abstractmethod
    def generate_signals(self, data: pd.DataFrame) -> pd.DataFrame:
        """生成交易信号"""
        pass

    @abstractmethod
    def calculate_position_size(self, signal: SignalResult, price: float,
                              available_capital: float) -> int:
        """计算仓位大小"""
        pass

    def validate_data(self, data: pd.DataFrame) -> bool:
        """验证输入数据"""
        required_columns = ['open', 'high', 'low', 'close', 'volume']
        return all(col in data.columns for col in required_columns)

    def update_position(self, symbol: str, quantity: int, price: float,
                       date: pd.Timestamp):
        """更新持仓"""
        if symbol in self.positions:
            # 更新现有持仓
            position = self.positions[symbol]
            if quantity > 0:  # 买入
                new_quantity = position.quantity + quantity
                new_cost = (position.quantity * position.entry_price + quantity * price)
                position.entry_price = new_cost / new_quantity
                position.quantity = new_quantity
            else:  # 卖出
                position.quantity += quantity
                if position.quantity <= 0:
                    del self.positions[symbol]
        else:
            # 新建持仓
            if quantity > 0:
                self.positions[symbol] = Position(
                    symbol=symbol,
                    quantity=quantity,
                    entry_price=price,
                    entry_date=date
                )

    def get_strategy_info(self) -> Dict[str, Any]:
        """获取策略信息"""
        return {
            'name': self.name,
            'params': self.params,
            'positions': len(self.positions),
            'signals_generated': len(self.signals_history)
        }
```

### 2. 策略管理器

```python
class StrategyManager:
    """策略管理器"""

    def __init__(self):
        self.strategies = {}
        self.active_strategies = {}

    def register_strategy(self, strategy: Strategy):
        """注册策略"""
        self.strategies[strategy.name] = strategy

    def activate_strategy(self, strategy_name: str):
        """激活策略"""
        if strategy_name in self.strategies:
            self.active_strategies[strategy_name] = self.strategies[strategy_name]
        else:
            raise ValueError(f"策略 {strategy_name} 不存在")

    def deactivate_strategy(self, strategy_name: str):
        """停用策略"""
        if strategy_name in self.active_strategies:
            del self.active_strategies[strategy_name]

    def get_all_signals(self, data: pd.DataFrame) -> Dict[str, pd.DataFrame]:
        """获取所有活跃策略的信号"""
        signals = {}
        for name, strategy in self.active_strategies.items():
            try:
                signals[name] = strategy.generate_signals(data)
            except Exception as e:
                print(f"策略 {name} 生成信号失败: {e}")
        return signals
```

## 技术指标实现

### 1. 移动平均线

```python
class MovingAverage:
    """移动平均线指标"""

    @staticmethod
    def sma(data: pd.Series, window: int) -> pd.Series:
        """简单移动平均线"""
        return data.rolling(window=window).mean()

    @staticmethod
    def ema(data: pd.Series, window: int) -> pd.Series:
        """指数移动平均线"""
        return data.ewm(span=window).mean()

    @staticmethod
    def crossover(series1: pd.Series, series2: pd.Series) -> pd.Series:
        """判断金叉死叉"""
        return (series1 > series2) & (series1.shift(1) <= series2.shift(1))

    @staticmethod
    def crossunder(series1: pd.Series, series2: pd.Series) -> pd.Series:
        """判断下穿"""
        return (series1 < series2) & (series1.shift(1) >= series2.shift(1))
```

### 2. RSI指标

```python
class RSI:
    """相对强弱指数"""

    @staticmethod
    def calculate(data: pd.Series, window: int = 14) -> pd.Series:
        """计算RSI"""
        delta = data.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()

        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        return rsi

    @staticmethod
    def is_overbought(rsi: pd.Series, threshold: float = 70) -> pd.Series:
        """判断超买"""
        return rsi > threshold

    @staticmethod
    def is_oversold(rsi: pd.Series, threshold: float = 30) -> pd.Series:
        """判断超卖"""
        return rsi < threshold
```

### 3. 布林带

```python
class BollingerBands:
    """布林带指标"""

    @staticmethod
    def calculate(data: pd.Series, window: int = 20, num_std: float = 2) -> Dict[str, pd.Series]:
        """计算布林带"""
        sma = data.rolling(window=window).mean()
        std = data.rolling(window=window).std()

        upper = sma + (std * num_std)
        lower = sma - (std * num_std)

        return {
            'middle': sma,
            'upper': upper,
            'lower': lower,
            'bandwidth': (upper - lower) / sma,
            'percent_b': (data - lower) / (upper - lower)
        }

    @staticmethod
    def is_above_upper(data: pd.Series, bb: Dict[str, pd.Series]) -> pd.Series:
        """价格突破上轨"""
        return data > bb['upper']

    @staticmethod
    def is_below_lower(data: pd.Series, bb: Dict[str, pd.Series]) -> pd.Series:
        """价格跌破下轨"""
        return data < bb['lower']
```

## 策略实现示例

### 1. 双均线交叉策略

```python
class MACrossStrategy(Strategy):
    """双均线交叉策略"""

    def __init__(self, short_window: int = 5, long_window: int = 20):
        params = {
            'short_window': short_window,
            'long_window': long_window
        }
        super().__init__("MA_Cross", params)

    def generate_signals(self, data: pd.DataFrame) -> pd.DataFrame:
        """生成交易信号"""
        if not self.validate_data(data):
            raise ValueError("输入数据格式不正确")

        signals = pd.DataFrame(index=data.index)
        signals['price'] = data['close']

        # 计算移动平均线
        short_ma = MovingAverage.sma(data['close'], self.params['short_window'])
        long_ma = MovingAverage.sma(data['close'], self.params['long_window'])

        # 生成交易信号
        signals['short_ma'] = short_ma
        signals['long_ma'] = long_ma

        # 金叉买入，死叉卖出
        signals['buy_signal'] = MovingAverage.crossover(short_ma, long_ma)
        signals['sell_signal'] = MovingAverage.crossunder(short_ma, long_ma)

        # 合并信号
        signals['signal'] = 0
        signals.loc[signals['buy_signal'], 'signal'] = 1
        signals.loc[signals['sell_signal'], 'signal'] = -1

        return signals

    def calculate_position_size(self, signal: SignalResult, price: float,
                              available_capital: float) -> int:
        """计算仓位大小"""
        # 固定使用90%的资金
        position_value = available_capital * 0.9
        quantity = int(position_value / price / 100) * 100  # 整手
        return quantity

    def get_signal_description(self, row: pd.Series) -> str:
        """获取信号描述"""
        if row['signal'] == 1:
            return f"金叉买入: 短均线({row['short_ma']:.2f}) > 长均线({row['long_ma']:.2f})"
        elif row['signal'] == -1:
            return f"死叉卖出: 短均线({row['short_ma']:.2f}) < 长均线({row['long_ma']:.2f})"
        else:
            return "持有"
```

### 2. RSI反转策略

```python
class RSIStrategy(Strategy):
    """RSI反转策略"""

    def __init__(self, rsi_window: int = 14, oversold: float = 30,
                 overbought: float = 70):
        params = {
            'rsi_window': rsi_window,
            'oversold': oversold,
            'overbought': overbought
        }
        super().__init__("RSI_Reversal", params)

    def generate_signals(self, data: pd.DataFrame) -> pd.DataFrame:
        """生成交易信号"""
        if not self.validate_data(data):
            raise ValueError("输入数据格式不正确")

        signals = pd.DataFrame(index=data.index)
        signals['price'] = data['close']

        # 计算RSI
        rsi = RSI.calculate(data['close'], self.params['rsi_window'])
        signals['rsi'] = rsi

        # 生成信号
        oversold = RSI.is_oversold(rsi, self.params['oversold'])
        overbought = RSI.is_overbought(rsi, self.params['overbought'])

        # RSI从超卖区域回升买入
        signals['buy_signal'] = oversold & (rsi > self.params['oversold'])
        # RSI从超买区域回落卖出
        signals['sell_signal'] = overbought & (rsi < self.params['overbought'])

        # 合并信号
        signals['signal'] = 0
        signals.loc[signals['buy_signal'], 'signal'] = 1
        signals.loc[signals['sell_signal'], 'signal'] = -1

        return signals

    def calculate_position_size(self, signal: SignalResult, price: float,
                              available_capital: float) -> int:
        """根据RSI值调整仓位大小"""
        # RSI越低，仓位越大
        rsi_strength = 1 - (signal.metadata.get('rsi', 50) / 100)
        position_ratio = 0.3 + (rsi_strength * 0.6)  # 30%-90%仓位
        position_value = available_capital * position_ratio
        quantity = int(position_value / price / 100) * 100
        return quantity
```

### 3. 布林带策略

```python
class BollingerBandsStrategy(Strategy):
    """布林带策略"""

    def __init__(self, window: int = 20, num_std: float = 2):
        params = {
            'window': window,
            'num_std': num_std
        }
        super().__init__("Bollinger_Bands", params)

    def generate_signals(self, data: pd.DataFrame) -> pd.DataFrame:
        """生成交易信号"""
        if not self.validate_data(data):
            raise ValueError("输入数据格式不正确")

        signals = pd.DataFrame(index=data.index)
        signals['price'] = data['close']

        # 计算布林带
        bb = BollingerBands.calculate(data['close'],
                                     self.params['window'],
                                     self.params['num_std'])

        signals['upper'] = bb['upper']
        signals['middle'] = bb['middle']
        signals['lower'] = bb['lower']
        signals['percent_b'] = bb['percent_b']

        # 生成信号
        # 价格触及下轨且%b < 0.2时买入
        signals['buy_signal'] = BollingerBands.is_below_lower(data['close'], bb) & (bb['percent_b'] < 0.2)
        # 价格触及上轨且%b > 0.8时卖出
        signals['sell_signal'] = BollingerBands.is_above_upper(data['close'], bb) & (bb['percent_b'] > 0.8)

        # 合并信号
        signals['signal'] = 0
        signals.loc[signals['buy_signal'], 'signal'] = 1
        signals.loc[signals['sell_signal'], 'signal'] = -1

        return signals

    def calculate_position_size(self, signal: SignalResult, price: float,
                              available_capital: float) -> int:
        """根据布林带宽度调整仓位"""
        # 布林带宽度越大，波动越大，仓位越小
        bb_width = signal.metadata.get('bandwidth', 0.1)
        position_ratio = max(0.3, min(0.8, 0.8 - bb_width * 2))
        position_value = available_capital * position_ratio
        quantity = int(position_value / price / 100) * 100
        return quantity
```

## 策略组合

### 1. 多策略组合

```python
class PortfolioStrategy(Strategy):
    """组合策略"""

    def __init__(self, strategies: list, weights: list = None):
        params = {
            'strategies': [s.name for s in strategies],
            'weights': weights or [1.0] * len(strategies)
        }
        super().__init__("Portfolio_Strategy", params)
        self.strategies = strategies
        self.weights = weights or [1.0] * len(strategies)

    def generate_signals(self, data: pd.DataFrame) -> pd.DataFrame:
        """生成组合信号"""
        all_signals = {}

        # 获取每个子策略的信号
        for strategy in self.strategies:
            try:
                signals = strategy.generate_signals(data)
                all_signals[strategy.name] = signals['signal']
            except Exception as e:
                print(f"策略 {strategy.name} 生成信号失败: {e}")

        # 加权合并信号
        combined_signals = pd.DataFrame(index=data.index)
        combined_signals['signal'] = 0

        for i, (strategy_name, signals) in enumerate(all_signals.items()):
            weight = self.weights[i]
            combined_signals['signal'] += signals * weight

        # 标准化信号到-1, 0, 1
        combined_signals['signal'] = np.sign(combined_signals['signal'])
        combined_signals['price'] = data['close']

        return combined_signals

    def calculate_position_size(self, signal: SignalResult, price: float,
                              available_capital: float) -> int:
        """组合策略仓位计算"""
        position_value = available_capital * 0.8  # 使用80%资金
        quantity = int(position_value / price / 100) * 100
        return quantity
```

## 策略优化

### 1. 参数优化

```python
from sklearn.model_selection import ParameterGrid
import itertools

class StrategyOptimizer:
    """策略参数优化器"""

    def __init__(self, strategy_class, data: pd.DataFrame):
        self.strategy_class = strategy_class
        self.data = data

    def optimize_parameters(self, param_grid: Dict[str, list],
                          metric: str = 'sharpe_ratio') -> Dict[str, Any]:
        """优化策略参数"""
        best_params = None
        best_score = float('-inf')
        results = []

        # 生成所有参数组合
        param_combinations = list(ParameterGrid(param_grid))

        print(f"开始优化，共 {len(param_combinations)} 组参数")

        for i, params in enumerate(param_combinations):
            print(f"测试参数组 {i+1}/{len(param_combinations)}: {params}")

            try:
                # 创建策略实例
                strategy = self.strategy_class(**params)

                # 生成信号
                signals = strategy.generate_signals(self.data)

                # 计算性能指标
                performance = self._calculate_performance(signals, self.data)
                score = performance.get(metric, 0)

                results.append({
                    'params': params,
                    'performance': performance,
                    'score': score
                })

                # 更新最佳参数
                if score > best_score:
                    best_score = score
                    best_params = params

            except Exception as e:
                print(f"参数 {params} 测试失败: {e}")

        return {
            'best_params': best_params,
            'best_score': best_score,
            'all_results': results
        }

    def _calculate_performance(self, signals: pd.DataFrame, data: pd.DataFrame) -> Dict[str, float]:
        """计算策略性能"""
        # 计算收益率
        returns = data['close'].pct_change().dropna()
        strategy_returns = returns * signals['signal'].shift(1)

        # 计算性能指标
        total_return = (1 + strategy_returns).prod() - 1
        annual_return = (1 + total_return) ** (252 / len(strategy_returns)) - 1
        volatility = strategy_returns.std() * np.sqrt(252)
        sharpe_ratio = annual_return / volatility if volatility > 0 else 0

        # 最大回撤
        cumulative = (1 + strategy_returns).cumprod()
        running_max = cumulative.expanding().max()
        drawdown = (cumulative - running_max) / running_max
        max_drawdown = drawdown.min()

        return {
            'total_return': total_return,
            'annual_return': annual_return,
            'volatility': volatility,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown': max_drawdown
        }
```

### 2. 网格搜索示例

```python
def optimize_ma_strategy():
    """优化双均线策略参数"""
    # 准备数据
    from data_fetcher import DataManager
    data_manager = DataManager(AkshareDataFetcher())

    symbol = "000001.SZ"
    end_date = datetime.now().strftime('%Y-%m-%d')
    start_date = (datetime.now() - timedelta(days=365*2)).strftime('%Y-%m-%d')

    data = data_manager.get_stock_data(symbol, start_date, end_date)

    # 定义参数网格
    param_grid = {
        'short_window': [3, 5, 8, 10, 15],
        'long_window': [15, 20, 25, 30, 35, 40]
    }

    # 创建优化器
    optimizer = StrategyOptimizer(MACrossStrategy, data)

    # 执行优化
    result = optimizer.optimize_parameters(param_grid, metric='sharpe_ratio')

    print("最优参数:", result['best_params'])
    print("最优夏普比率:", result['best_score'])

    return result
```

## 策略回测

### 1. 回测引擎

```python
class Backtester:
    """回测引擎"""

    def __init__(self, strategy: Strategy, initial_capital: float = 1000000,
                 commission: float = 0.001):
        self.strategy = strategy
        self.initial_capital = initial_capital
        self.commission = commission
        self.reset()

    def reset(self):
        """重置回测状态"""
        self.capital = self.initial_capital
        self.positions = {}
        self.trades = []
        self.portfolio_value = []
        self.dates = []

    def run(self, data: pd.DataFrame) -> Dict[str, Any]:
        """运行回测"""
        self.reset()

        # 生成交易信号
        signals = self.strategy.generate_signals(data)

        for date, row in signals.iterrows():
            self.dates.append(date)
            current_price = row['price']
            signal = row['signal']

            # 执行交易
            self._execute_trade(date, current_price, signal)

            # 计算组合价值
            portfolio_value = self._calculate_portfolio_value(current_price)
            self.portfolio_value.append(portfolio_value)

        # 计算回测结果
        return self._calculate_results()

    def _execute_trade(self, date: pd.Timestamp, price: float, signal: int):
        """执行交易"""
        if signal == 1:  # 买入
            self._buy(date, price)
        elif signal == -1:  # 卖出
            self._sell(date, price)

    def _buy(self, date: pd.Timestamp, price: float):
        """买入操作"""
        if self.capital > 0:
            # 计算买入数量
            signal_result = SignalResult(Signal.BUY, 1.0, "买入信号")
            quantity = self.strategy.calculate_position_size(
                signal_result, price, self.capital
            )

            if quantity > 0:
                cost = quantity * price * (1 + self.commission)
                if cost <= self.capital:
                    self.capital -= cost
                    self.positions['quantity'] = self.positions.get('quantity', 0) + quantity
                    self.trades.append({
                        'date': date,
                        'action': 'buy',
                        'quantity': quantity,
                        'price': price,
                        'cost': cost
                    })

    def _sell(self, date: pd.Timestamp, price: float):
        """卖出操作"""
        quantity = self.positions.get('quantity', 0)
        if quantity > 0:
            # 全部卖出
            proceeds = quantity * price * (1 - self.commission)
            self.capital += proceeds
            self.trades.append({
                'date': date,
                'action': 'sell',
                'quantity': quantity,
                'price': price,
                'proceeds': proceeds
            })
            self.positions['quantity'] = 0

    def _calculate_portfolio_value(self, current_price: float) -> float:
        """计算组合价值"""
        holdings_value = self.positions.get('quantity', 0) * current_price
        return self.capital + holdings_value

    def _calculate_results(self) -> Dict[str, Any]:
        """计算回测结果"""
        portfolio_series = pd.Series(self.portfolio_value, index=self.dates)
        returns = portfolio_series.pct_change().dropna()

        # 基础指标
        total_return = (portfolio_series.iloc[-1] / self.initial_capital) - 1
        annual_return = (1 + total_return) ** (252 / len(returns)) - 1
        volatility = returns.std() * np.sqrt(252)
        sharpe_ratio = annual_return / volatility if volatility > 0 else 0

        # 回撤指标
        cumulative = portfolio_series / self.initial_capital
        running_max = cumulative.expanding().max()
        drawdown = (cumulative - running_max) / running_max
        max_drawdown = drawdown.min()

        # 交易统计
        total_trades = len(self.trades)
        winning_trades = sum(1 for trade in self.trades if trade['action'] == 'sell')

        return {
            'total_return': total_return,
            'annual_return': annual_return,
            'volatility': volatility,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown': max_drawdown,
            'total_trades': total_trades,
            'portfolio_values': portfolio_series,
            'trades': self.trades
        }
```

## 策略评估

### 1. 性能指标计算

```python
class PerformanceAnalyzer:
    """性能分析器"""

    @staticmethod
    def calculate_metrics(returns: pd.Series, benchmark_returns: pd.Series = None) -> Dict[str, float]:
        """计算性能指标"""
        # 基础指标
        total_return = (1 + returns).prod() - 1
        annual_return = (1 + total_return) ** (252 / len(returns)) - 1
        volatility = returns.std() * np.sqrt(252)
        sharpe_ratio = annual_return / volatility if volatility > 0 else 0

        # 最大回撤
        cumulative = (1 + returns).cumprod()
        running_max = cumulative.expanding().max()
        drawdown = (cumulative - running_max) / running_max
        max_drawdown = drawdown.min()

        # 胜率
        win_rate = (returns > 0).mean()

        # 盈亏比
        positive_returns = returns[returns > 0]
        negative_returns = returns[returns < 0]
        profit_loss_ratio = (positive_returns.mean() /
                           abs(negative_returns.mean())) if len(negative_returns) > 0 else 0

        metrics = {
            'total_return': total_return,
            'annual_return': annual_return,
            'volatility': volatility,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown': max_drawdown,
            'win_rate': win_rate,
            'profit_loss_ratio': profit_loss_ratio
        }

        # 相对基准指标
        if benchmark_returns is not None:
            benchmark_total = (1 + benchmark_returns).prod() - 1
            excess_return = total_return - benchmark_total

            # Alpha和Beta
            covariance = np.cov(returns, benchmark_returns)[0, 1]
            benchmark_variance = benchmark_returns.var()
            beta = covariance / benchmark_variance if benchmark_variance > 0 else 0

            alpha = excess_return - beta * ((1 + benchmark_returns).prod() - 1)

            metrics.update({
                'excess_return': excess_return,
                'alpha': alpha,
                'beta': beta
            })

        return metrics

    @staticmethod
    def generate_report(results: Dict[str, Any]) -> str:
        """生成性能报告"""
        report = f"""
策略性能报告
============
总收益率: {results['total_return']:.2%}
年化收益率: {results['annual_return']:.2%}
年化波动率: {results['volatility']:.2%}
夏普比率: {results['sharpe_ratio']:.2f}
最大回撤: {results['max_drawdown']:.2%}
胜率: {results['win_rate']:.2%}
盈亏比: {results['profit_loss_ratio']:.2f}
总交易次数: {results['total_trades']}
        """
        return report
```

## 策略使用示例

### 1. 完整策略运行示例

```python
def run_strategy_example():
    """运行策略示例"""
    # 准备数据
    from data_fetcher import DataManager
    data_manager = DataManager(AkshareDataFetcher())

    symbol = "000001.SZ"
    end_date = datetime.now().strftime('%Y-%m-%d')
    start_date = (datetime.now() - timedelta(days=365)).strftime('%Y-%m-%d')

    data = data_manager.get_stock_data(symbol, start_date, end_date)

    if data.empty:
        print("获取数据失败")
        return

    # 创建策略
    strategy = MACrossStrategy(short_window=5, long_window=20)

    # 运行回测
    backtester = Backtester(strategy, initial_capital=1000000)
    results = backtester.run(data)

    # 显示结果
    print(PerformanceAnalyzer.generate_report(results))

    # 绘制结果
    import matplotlib.pyplot as plt

    plt.figure(figsize=(12, 6))
    plt.plot(results['portfolio_values'].index, results['portfolio_values'])
    plt.title('策略净值曲线')
    plt.xlabel('日期')
    plt.ylabel('组合价值')
    plt.grid(True)
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    run_strategy_example()
```

## 最佳实践

### 1. 策略开发原则
- **简单有效**: 避免过度复杂的逻辑
- **鲁棒性强**: 在不同市场环境下都能表现良好
- **可解释性**: 能够清楚解释策略逻辑
- **风险控制**: 内置风险管理机制

### 2. 回测注意事项
- 避免前视偏差
- 考虑交易成本和滑点
- 使用充足的历史数据
- 进行样本外测试

### 3. 参数优化建议
- 避免过度拟合
- 使用交叉验证
- 考虑参数稳定性
- 定期重新优化

## 下一步

掌握策略开发后，您可以：
1. 学习[风险管理](07-风险管理.md)
2. 深入[回测系统](08-回测系统.md)
3. 探索[实盘交易](09-实盘交易.md)