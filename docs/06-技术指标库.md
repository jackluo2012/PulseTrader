# 技术指标库文档

## 技术指标概述

技术指标是量化交易的基础，通过对价格、成交量等市场数据的数学计算，帮助识别趋势、动量、超买超卖等市场状态。本技术指标库提供了常用技术指标的实现。

## 指标分类

### 1. 趋势指标
- 移动平均线 (MA, EMA)
- 布林带 (Bollinger Bands)
- MACD
- SAR抛物线指标

### 2. 动量指标
- RSI相对强弱指数
- KDJ随机指标
- CCI商品通道指数
- 威廉指标 (Williams %R)

### 3. 成交量指标
- OBV能量潮
- VWAP成交量加权平均价
- 量比指标
- 成交量移动平均

### 4. 波动率指标
- ATR平均真实波幅
- 历史波动率
- 布林带宽度

## 指标基类设计

```python
from abc import ABC, abstractmethod
import pandas as pd
import numpy as np
from typing import Union, Dict, Any, Optional

class Indicator(ABC):
    """技术指标基类"""

    def __init__(self, name: str, **params):
        self.name = name
        self.params = params

    @abstractmethod
    def calculate(self, data: pd.DataFrame) -> Union[pd.Series, Dict[str, pd.Series]]:
        """计算指标值"""
        pass

    @abstractmethod
    def validate_params(self) -> bool:
        """验证参数有效性"""
        pass

    def get_signals(self, data: pd.DataFrame) -> pd.DataFrame:
        """生成交易信号"""
        indicator_data = self.calculate(data)
        return self._generate_signals(indicator_data)

    @abstractmethod
    def _generate_signals(self, indicator_data: Union[pd.Series, Dict[str, pd.Series]]) -> pd.DataFrame:
        """生成具体信号（由子类实现）"""
        pass

class TrendIndicator(Indicator):
    """趋势指标基类"""
    pass

class MomentumIndicator(Indicator):
    """动量指标基类"""
    pass

class VolumeIndicator(Indicator):
    """成交量指标基类"""
    pass

class VolatilityIndicator(Indicator):
    """波动率指标基类"""
    pass
```

## 趋势指标实现

### 1. 移动平均线

```python
class MovingAverage(TrendIndicator):
    """移动平均线指标"""

    def __init__(self, window: int = 20, ma_type: str = 'sma'):
        super().__init__(f"MA_{window}_{ma_type}", window=window, ma_type=ma_type)

    def validate_params(self) -> bool:
        return self.params['window'] > 0 and self.params['ma_type'] in ['sma', 'ema', 'wma']

    def calculate(self, data: pd.DataFrame) -> pd.Series:
        """计算移动平均线"""
        close = data['close']
        window = self.params['window']
        ma_type = self.params['ma_type']

        if ma_type == 'sma':
            return close.rolling(window=window).mean()
        elif ma_type == 'ema':
            return close.ewm(span=window).mean()
        elif ma_type == 'wma':
            return self._calculate_wma(close, window)
        else:
            raise ValueError(f"不支持的MA类型: {ma_type}")

    def _calculate_wma(self, data: pd.Series, window: int) -> pd.Series:
        """计算加权移动平均线"""
        weights = np.arange(1, window + 1)
        return data.rolling(window).apply(lambda x: np.dot(x, weights) / weights.sum(), raw=True)

    def _generate_signals(self, indicator_data: pd.Series) -> pd.DataFrame:
        """生成交易信号"""
        signals = pd.DataFrame(index=indicator_data.index)
        signals['ma'] = indicator_data

        # 价格与均线的关系
        price = indicator_data.copy()
        price.name = 'price'
        signals['price'] = price

        # 价格上穿均线买入，下穿卖出
        signals['buy_signal'] = (price > indicator_data) & (price.shift(1) <= indicator_data.shift(1))
        signals['sell_signal'] = (price < indicator_data) & (price.shift(1) >= indicator_data.shift(1))

        signals['signal'] = 0
        signals.loc[signals['buy_signal'], 'signal'] = 1
        signals.loc[signals['sell_signal'], 'signal'] = -1

        return signals

class MACD(TrendIndicator):
    """MACD指标"""

    def __init__(self, fast_period: int = 12, slow_period: int = 26, signal_period: int = 9):
        super().__init__("MACD",
                        fast_period=fast_period,
                        slow_period=slow_period,
                        signal_period=signal_period)

    def validate_params(self) -> bool:
        return (self.params['fast_period'] > 0 and
                self.params['slow_period'] > self.params['fast_period'] and
                self.params['signal_period'] > 0)

    def calculate(self, data: pd.DataFrame) -> Dict[str, pd.Series]:
        """计算MACD指标"""
        close = data['close']
        fast = self.params['fast_period']
        slow = self.params['slow_period']
        signal = self.params['signal_period']

        # 计算快速和慢速EMA
        ema_fast = close.ewm(span=fast).mean()
        ema_slow = close.ewm(span=slow).mean()

        # MACD线
        macd_line = ema_fast - ema_slow

        # 信号线
        signal_line = macd_line.ewm(span=signal).mean()

        # MACD柱状图
        histogram = macd_line - signal_line

        return {
            'macd': macd_line,
            'signal': signal_line,
            'histogram': histogram
        }

    def _generate_signals(self, indicator_data: Dict[str, pd.Series]) -> pd.DataFrame:
        """生成MACD交易信号"""
        macd = indicator_data['macd']
        signal = indicator_data['signal']
        histogram = indicator_data['histogram']

        signals = pd.DataFrame(index=macd.index)
        signals['macd'] = macd
        signals['signal'] = signal
        signals['histogram'] = histogram

        # MACD金叉死叉
        signals['golden_cross'] = (macd > signal) & (macd.shift(1) <= signal.shift(1))
        signals['death_cross'] = (macd < signal) & (macd.shift(1) >= signal.shift(1))

        # MACD柱状图变化
        signals['histogram_increase'] = (histogram > histogram.shift(1)) & (histogram.shift(1) <= histogram.shift(2))
        signals['histogram_decrease'] = (histogram < histogram.shift(1)) & (histogram.shift(1) >= histogram.shift(2))

        # 合并信号
        signals['buy_signal'] = signals['golden_cross']
        signals['sell_signal'] = signals['death_cross']

        signals['trading_signal'] = 0
        signals.loc[signals['buy_signal'], 'trading_signal'] = 1
        signals.loc[signals['sell_signal'], 'trading_signal'] = -1

        return signals
```

### 2. 布林带

```python
class BollingerBands(TrendIndicator):
    """布林带指标"""

    def __init__(self, window: int = 20, num_std: float = 2.0):
        super().__init__("BollingerBands", window=window, num_std=num_std)

    def validate_params(self) -> bool:
        return self.params['window'] > 0 and self.params['num_std'] > 0

    def calculate(self, data: pd.DataFrame) -> Dict[str, pd.Series]:
        """计算布林带"""
        close = data['close']
        window = self.params['window']
        num_std = self.params['num_std']

        # 中轨（移动平均线）
        middle = close.rolling(window=window).mean()

        # 标准差
        std = close.rolling(window=window).std()

        # 上轨和下轨
        upper = middle + (std * num_std)
        lower = middle - (std * num_std)

        # 带宽
        bandwidth = (upper - lower) / middle

        # %B指标（价格在布林带中的位置）
        percent_b = (close - lower) / (upper - lower)

        return {
            'middle': middle,
            'upper': upper,
            'lower': lower,
            'bandwidth': bandwidth,
            'percent_b': percent_b
        }

    def _generate_signals(self, indicator_data: Dict[str, pd.Series]) -> pd.DataFrame:
        """生成布林带交易信号"""
        upper = indicator_data['upper']
        lower = indicator_data['lower']
        middle = indicator_data['middle']
        percent_b = indicator_data['percent_b']

        signals = pd.DataFrame(index=upper.index)
        signals['upper'] = upper
        signals['middle'] = middle
        signals['lower'] = lower
        signals['percent_b'] = percent_b

        # 价格突破信号
        signals['price_above_upper'] = percent_b > 1.0
        signals['price_below_lower'] = percent_b < 0.0
        signals['price_return_middle'] = (percent_b > 0.8) & (percent_b.shift(1) <= 0.8)

        # 收敛信号（带宽收窄）
        bandwidth_change = indicator_data['bandwidth'].pct_change()
        signals['bandwidth_narrowing'] = bandwidth_change < -0.1

        # 交易信号
        signals['buy_signal'] = signals['price_below_lower'] & (percent_b < 0.2)
        signals['sell_signal'] = signals['price_above_upper'] & (percent_b > 0.8)

        signals['trading_signal'] = 0
        signals.loc[signals['buy_signal'], 'trading_signal'] = 1
        signals.loc[signals['sell_signal'], 'trading_signal'] = -1

        return signals
```

## 动量指标实现

### 1. RSI相对强弱指数

```python
class RSI(MomentumIndicator):
    """相对强弱指数"""

    def __init__(self, window: int = 14):
        super().__init__("RSI", window=window)

    def validate_params(self) -> bool:
        return self.params['window'] > 1

    def calculate(self, data: pd.DataFrame) -> pd.Series:
        """计算RSI"""
        close = data['close']
        window = self.params['window']

        # 计算价格变化
        delta = close.diff()

        # 分离涨跌
        gain = delta.where(delta > 0, 0)
        loss = -delta.where(delta < 0, 0)

        # 计算平均涨跌幅
        avg_gain = gain.rolling(window=window).mean()
        avg_loss = loss.rolling(window=window).mean()

        # 计算RS和RSI
        rs = avg_gain / avg_loss
        rsi = 100 - (100 / (1 + rs))

        return rsi

    def _generate_signals(self, indicator_data: pd.Series) -> pd.DataFrame:
        """生成RSI交易信号"""
        rsi = indicator_data

        signals = pd.DataFrame(index=rsi.index)
        signals['rsi'] = rsi

        # 超买超卖区域
        signals['overbought'] = rsi > 70
        signals['oversold'] = rsi < 30
        signals['overbought_extreme'] = rsi > 80
        signals['oversold_extreme'] = rsi < 20

        # 背离信号
        signals['bullish_divergence'] = self._detect_bullish_divergence(rsi, signals.index)
        signals['bearish_divergence'] = self._detect_bearish_divergence(rsi, signals.index)

        # 交易信号
        signals['buy_signal'] = signals['oversold'] & (rsi > 30)
        signals['sell_signal'] = signals['overbought'] & (rsi < 70)

        signals['trading_signal'] = 0
        signals.loc[signals['buy_signal'], 'trading_signal'] = 1
        signals.loc[signals['sell_signal'], 'trading_signal'] = -1

        return signals

    def _detect_bullish_divergence(self, rsi: pd.Series, dates: pd.DatetimeIndex) -> pd.Series:
        """检测看涨背离"""
        divergence = pd.Series(False, index=rsi.index)

        # 简化的背离检测逻辑
        for i in range(20, len(rsi)):
            # 价格创新低，RSI没有创新低
            price_low = rsi.iloc[i-10:i].min()
            rsi_low = rsi.iloc[i-10:i].min()

            prev_price_low = rsi.iloc[i-20:i-10].min()
            prev_rsi_low = rsi.iloc[i-20:i-10].min()

            if (price_low < prev_price_low and
                rsi_low > prev_rsi_low and
                rsi_low < 50):
                divergence.iloc[i] = True

        return divergence

    def _detect_bearish_divergence(self, rsi: pd.Series, dates: pd.DatetimeIndex) -> pd.Series:
        """检测看跌背离"""
        divergence = pd.Series(False, index=rsi.index)

        for i in range(20, len(rsi)):
            # 价格创新高，RSI没有创新高
            price_high = rsi.iloc[i-10:i].max()
            rsi_high = rsi.iloc[i-10:i].max()

            prev_price_high = rsi.iloc[i-20:i-10].max()
            prev_rsi_high = rsi.iloc[i-20:i-10].max()

            if (price_high > prev_price_high and
                rsi_high < prev_rsi_high and
                rsi_high > 50):
                divergence.iloc[i] = True

        return divergence
```

### 2. KDJ随机指标

```python
class KDJ(MomentumIndicator):
    """KDJ随机指标"""

    def __init__(self, n_period: int = 9, m1_period: int = 3, m2_period: int = 3):
        super().__init__("KDJ",
                        n_period=n_period,
                        m1_period=m1_period,
                        m2_period=m2_period)

    def validate_params(self) -> bool:
        return all(p > 0 for p in self.params.values())

    def calculate(self, data: pd.DataFrame) -> Dict[str, pd.Series]:
        """计算KDJ指标"""
        high = data['high']
        low = data['low']
        close = data['close']

        n = self.params['n_period']
        m1 = self.params['m1_period']
        m2 = self.params['m2_period']

        # 计算RSV
        lowest_low = low.rolling(window=n).min()
        highest_high = high.rolling(window=n).max()
        rsv = (close - lowest_low) / (highest_high - lowest_low) * 100

        # 计算K值
        k_values = []
        k = 50  # 初始值
        for rsv_val in rsv:
            if pd.isna(rsv_val):
                k_values.append(k)
            else:
                k = (2/3) * k + (1/3) * rsv_val
                k_values.append(k)

        k_series = pd.Series(k_values, index=rsv.index)

        # 计算D值
        d_values = []
        d = 50  # 初始值
        for k_val in k_series:
            if pd.isna(k_val):
                d_values.append(d)
            else:
                d = (2/3) * d + (1/3) * k_val
                d_values.append(d)

        d_series = pd.Series(d_values, index=k_series.index)

        # 计算J值
        j_series = 3 * k_series - 2 * d_series

        return {
            'k': k_series,
            'd': d_series,
            'j': j_series,
            'rsv': rsv
        }

    def _generate_signals(self, indicator_data: Dict[str, pd.Series]) -> pd.DataFrame:
        """生成KDJ交易信号"""
        k = indicator_data['k']
        d = indicator_data['d']
        j = indicator_data['j']

        signals = pd.DataFrame(index=k.index)
        signals['k'] = k
        signals['d'] = d
        signals['j'] = j

        # 超买超卖
        signals['overbought'] = (k > 80) & (d > 80)
        signals['oversold'] = (k < 20) & (d < 20)

        # 金叉死叉
        signals['golden_cross'] = (k > d) & (k.shift(1) <= d.shift(1))
        signals['death_cross'] = (k < d) & (k.shift(1) >= d.shift(1))

        # J值信号
        signals['j_above_100'] = j > 100
        signals['j_below_0'] = j < 0

        # 交易信号
        signals['buy_signal'] = signals['golden_cross'] & (k < 50)
        signals['sell_signal'] = signals['death_cross'] & (k > 50)

        signals['trading_signal'] = 0
        signals.loc[signals['buy_signal'], 'trading_signal'] = 1
        signals.loc[signals['sell_signal'], 'trading_signal'] = -1

        return signals
```

## 成交量指标实现

### 1. OBV能量潮

```python
class OBV(VolumeIndicator):
    """能量潮指标"""

    def __init__(self):
        super().__init__("OBV")

    def validate_params(self) -> bool:
        return True

    def calculate(self, data: pd.DataFrame) -> pd.Series:
        """计算OBV指标"""
        close = data['close']
        volume = data['volume']

        # 计算价格变化方向
        price_change = close.diff()
        direction = np.where(price_change > 0, 1, np.where(price_change < 0, -1, 0))

        # 计算OBV
        obv_values = [0]
        for i in range(1, len(direction)):
            obv_values.append(obv_values[-1] + direction[i] * volume.iloc[i])

        return pd.Series(obv_values, index=close.index)

    def _generate_signals(self, indicator_data: pd.Series) -> pd.DataFrame:
        """生成OBV交易信号"""
        obv = indicator_data

        signals = pd.DataFrame(index=obv.index)
        signals['obv'] = obv

        # OBV移动平均线
        obv_ma = obv.rolling(window=10).mean()
        signals['obv_ma'] = obv_ma

        # OBV背离信号
        signals['obv_divergence'] = self._detect_obv_divergence(obv, signals.index)

        # OBV趋势信号
        signals['obv_uptrend'] = obv > obv_ma
        signals['obv_downtrend'] = obv < obv_ma

        # 交易信号
        signals['buy_signal'] = signals['obv_uptrend'] & signals['obv_divergence']
        signals['sell_signal'] = signals['obv_downtrend'] & signals['obv_divergence']

        signals['trading_signal'] = 0
        signals.loc[signals['buy_signal'], 'trading_signal'] = 1
        signals.loc[signals['sell_signal'], 'trading_signal'] = -1

        return signals

    def _detect_obv_divergence(self, obv: pd.Series, dates: pd.DatetimeIndex) -> pd.Series:
        """检测OBV背离"""
        divergence = pd.Series(False, index=obv.index)

        for i in range(20, len(obv)):
            # 价格上涨但OBV下跌
            price_trend = obv.iloc[i-10:i].mean() > obv.iloc[i-20:i-10].mean()
            obv_trend = obv.iloc[i-10:i].mean() < obv.iloc[i-20:i-10].mean()

            if price_trend and obv_trend:
                divergence.iloc[i] = True

        return divergence
```

### 2. VWAP成交量加权平均价

```python
class VWAP(VolumeIndicator):
    """成交量加权平均价"""

    def __init__(self):
        super().__init__("VWAP")

    def validate_params(self) -> bool:
        return True

    def calculate(self, data: pd.DataFrame) -> pd.Series:
        """计算VWAP"""
        typical_price = (data['high'] + data['low'] + data['close']) / 3
        volume = data['volume']

        # 计算累积成交量和累积成交额
        cumulative_volume = volume.cumsum()
        cumulative_value = (typical_price * volume).cumsum()

        # 计算VWAP
        vwap = cumulative_value / cumulative_volume

        return vwap

    def _generate_signals(self, indicator_data: pd.Series) -> pd.DataFrame:
        """生成VWAP交易信号"""
        vwap = indicator_data

        signals = pd.DataFrame(index=vwap.index)
        signals['vwap'] = vwap

        # 假设当前价格就是收盘价
        signals['price'] = vwap.copy()  # 这里应该用实际价格

        # 价格与VWAP的关系
        signals['price_above_vwap'] = signals['price'] > vwap
        signals['price_below_vwap'] = signals['price'] < vwap

        # VWAP趋势
        vwap_change = vwap.pct_change()
        signals['vwap_uptrend'] = vwap_change > 0
        signals['vwap_downtrend'] = vwap_change < 0

        # 交易信号
        signals['buy_signal'] = signals['price_above_vwap'] & signals['vwap_uptrend']
        signals['sell_signal'] = signals['price_below_vwap'] & signals['vwap_downtrend']

        signals['trading_signal'] = 0
        signals.loc[signals['buy_signal'], 'trading_signal'] = 1
        signals.loc[signals['sell_signal'], 'trading_signal'] = -1

        return signals
```

## 波动率指标实现

### 1. ATR平均真实波幅

```python
class ATR(VolatilityIndicator):
    """平均真实波幅"""

    def __init__(self, window: int = 14):
        super().__init__("ATR", window=window)

    def validate_params(self) -> bool:
        return self.params['window'] > 1

    def calculate(self, data: pd.DataFrame) -> pd.Series:
        """计算ATR"""
        high = data['high']
        low = data['low']
        close = data['close']
        window = self.params['window']

        # 计算真实波幅TR
        tr1 = high - low  # 当前最高价 - 最低价
        tr2 = abs(high - close.shift(1))  # 当前最高价 - 前收盘价
        tr3 = abs(low - close.shift(1))   # 当前最低价 - 前收盘价

        tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)

        # 计算ATR（TR的移动平均）
        atr = tr.rolling(window=window).mean()

        return atr

    def _generate_signals(self, indicator_data: pd.Series) -> pd.DataFrame:
        """生成ATR相关信号"""
        atr = indicator_data

        signals = pd.DataFrame(index=atr.index)
        signals['atr'] = atr

        # ATR移动平均线
        atr_ma = atr.rolling(window=10).mean()
        signals['atr_ma'] = atr_ma

        # 波动率状态
        signals['high_volatility'] = atr > atr_ma * 1.2
        signals['low_volatility'] = atr < atr_ma * 0.8

        # ATR变化率
        atr_change = atr.pct_change()
        signals['volatility_increasing'] = atr_change > 0.1
        signals['volatility_decreasing'] = atr_change < -0.1

        return signals
```

## 指标工厂和管理器

### 1. 指标工厂

```python
class IndicatorFactory:
    """技术指标工厂"""

    _indicators = {
        # 趋势指标
        'sma': MovingAverage,
        'ema': lambda **kwargs: MovingAverage(ma_type='ema', **kwargs),
        'wma': lambda **kwargs: MovingAverage(ma_type='wma', **kwargs),
        'macd': MACD,
        'bollinger': BollingerBands,

        # 动量指标
        'rsi': RSI,
        'kdj': KDJ,

        # 成交量指标
        'obv': OBV,
        'vwap': VWAP,

        # 波动率指标
        'atr': ATR,
    }

    @classmethod
    def create_indicator(cls, indicator_type: str, **params) -> Indicator:
        """创建技术指标实例"""
        if indicator_type not in cls._indicators:
            raise ValueError(f"不支持的指标类型: {indicator_type}")

        indicator_class = cls._indicators[indicator_type]

        if callable(indicator_class) and not isinstance(indicator_class, type):
            # 处理lambda函数
            return indicator_class(**params)
        else:
            return indicator_class(**params)

    @classmethod
    def get_available_indicators(cls) -> list:
        """获取可用的指标列表"""
        return list(cls._indicators.keys())

    @classmethod
    def register_indicator(cls, name: str, indicator_class: type):
        """注册新的指标类"""
        cls._indicators[name] = indicator_class
```

### 2. 指标管理器

```python
class IndicatorManager:
    """技术指标管理器"""

    def __init__(self):
        self.indicators = {}
        self.indicator_data = {}

    def add_indicator(self, name: str, indicator: Indicator):
        """添加指标"""
        self.indicators[name] = indicator

    def calculate_all(self, data: pd.DataFrame) -> Dict[str, Union[pd.Series, Dict[str, pd.Series]]]:
        """计算所有指标"""
        results = {}

        for name, indicator in self.indicators.items():
            try:
                if indicator.validate_params():
                    results[name] = indicator.calculate(data)
                    print(f"指标 {name} 计算成功")
                else:
                    print(f"指标 {name} 参数验证失败")
            except Exception as e:
                print(f"指标 {name} 计算失败: {e}")

        self.indicator_data = results
        return results

    def get_indicator(self, name: str) -> Union[pd.Series, Dict[str, pd.Series]]:
        """获取指定指标数据"""
        return self.indicator_data.get(name)

    def get_signals(self, data: pd.DataFrame) -> Dict[str, pd.DataFrame]:
        """获取所有指标的交易信号"""
        signals = {}

        for name, indicator in self.indicators.items():
            try:
                signals[name] = indicator.get_signals(data)
            except Exception as e:
                print(f"指标 {name} 生成信号失败: {e}")

        return signals

    def remove_indicator(self, name: str):
        """移除指标"""
        if name in self.indicators:
            del self.indicators[name]
        if name in self.indicator_data:
            del self.indicator_data[name]
```

## 使用示例

### 1. 单个指标使用

```python
def single_indicator_example():
    """单个指标使用示例"""
    # 准备数据
    from data_fetcher import DataManager
    data_manager = DataManager(AkshareDataFetcher())

    symbol = "000001.SZ"
    end_date = datetime.now().strftime('%Y-%m-%d')
    start_date = (datetime.now() - timedelta(days=365)).strftime('%Y-%m-%d')

    data = data_manager.get_stock_data(symbol, start_date, end_date)

    if data.empty:
        print("获取数据失败")
        return

    # 创建RSI指标
    rsi = IndicatorFactory.create_indicator('rsi', window=14)

    # 计算指标值
    rsi_values = rsi.calculate(data)

    # 生成交易信号
    signals = rsi.get_signals(data)

    print("RSI指标最后5个值:")
    print(rsi_values.tail())

    print("\n最近交易信号:")
    recent_signals = signals[signals['trading_signal'] != 0].tail(5)
    print(recent_signals[['rsi', 'trading_signal']])
```

### 2. 多指标组合使用

```python
def multi_indicator_example():
    """多指标组合使用示例"""
    # 准备数据
    from data_fetcher import DataManager
    data_manager = DataManager(AkshareDataFetcher())

    symbol = "000001.SZ"
    end_date = datetime.now().strftime('%Y-%m-%d')
    start_date = (datetime.now() - timedelta(days=365)).strftime('%Y-%m-%d')

    data = data_manager.get_stock_data(symbol, start_date, end_date)

    if data.empty:
        print("获取数据失败")
        return

    # 创建指标管理器
    manager = IndicatorManager()

    # 添加多个指标
    manager.add_indicator('ma20', IndicatorFactory.create_indicator('sma', window=20))
    manager.add_indicator('ma5', IndicatorFactory.create_indicator('sma', window=5))
    manager.add_indicator('rsi', IndicatorFactory.create_indicator('rsi', window=14))
    manager.add_indicator('macd', IndicatorFactory.create_indicator('macd'))
    manager.add_indicator('bollinger', IndicatorFactory.create_indicator('bollinger'))

    # 计算所有指标
    indicator_results = manager.calculate_all(data)

    # 获取所有交易信号
    all_signals = manager.get_signals(data)

    # 合并多个指标的信号
    combined_signals = pd.DataFrame(index=data.index)
    combined_signals['price'] = data['close']

    # 简单的信号合并逻辑
    for indicator_name, signals in all_signals.items():
        signal_col = f'{indicator_name}_signal'
        combined_signals[signal_col] = signals['trading_signal']

    # 综合信号（多数投票）
    signal_cols = [col for col in combined_signals.columns if col.endswith('_signal')]
    combined_signals['combined_signal'] = combined_signals[signal_cols].sum(axis=1)
    combined_signals['final_signal'] = np.sign(combined_signals['combined_signal'])

    print("综合信号统计:")
    print(combined_signals['final_signal'].value_counts())

    return combined_signals
```

### 3. 指标可视化

```python
def visualize_indicators(data: pd.DataFrame, indicators: Dict[str, Union[pd.Series, Dict[str, pd.Series]]]):
    """可视化技术指标"""
    import matplotlib.pyplot as plt

    fig, axes = plt.subplots(3, 1, figsize=(15, 12))

    # 价格图
    axes[0].plot(data.index, data['close'], label='Close Price', linewidth=1)

    # 添加移动平均线
    if 'ma20' in indicators:
        axes[0].plot(data.index, indicators['ma20'], label='MA20', alpha=0.7)
    if 'ma5' in indicators:
        axes[0].plot(data.index, indicators['ma5'], label='MA5', alpha=0.7)

    # 添加布林带
    if 'bollinger' in indicators:
        bb = indicators['bollinger']
        axes[0].plot(data.index, bb['upper'], '--', alpha=0.5, label='Upper BB')
        axes[0].plot(data.index, bb['lower'], '--', alpha=0.5, label='Lower BB')
        axes[0].fill_between(data.index, bb['upper'], bb['lower'], alpha=0.1)

    axes[0].set_title('Price and Trend Indicators')
    axes[0].legend()
    axes[0].grid(True, alpha=0.3)

    # RSI图
    if 'rsi' in indicators:
        axes[1].plot(data.index, indicators['rsi'], label='RSI', color='purple')
        axes[1].axhline(y=70, color='r', linestyle='--', alpha=0.5, label='Overbought')
        axes[1].axhline(y=30, color='g', linestyle='--', alpha=0.5, label='Oversold')
        axes[1].set_title('RSI Indicator')
        axes[1].legend()
        axes[1].grid(True, alpha=0.3)

    # MACD图
    if 'macd' in indicators:
        macd = indicators['macd']
        axes[2].plot(data.index, macd['macd'], label='MACD', linewidth=1)
        axes[2].plot(data.index, macd['signal'], label='Signal', linewidth=1)
        axes[2].bar(data.index, macd['histogram'], label='Histogram', alpha=0.7)
        axes[2].axhline(y=0, color='black', linestyle='-', alpha=0.3)
        axes[2].set_title('MACD Indicator')
        axes[2].legend()
        axes[2].grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()
```

## 指标性能优化

### 1. 缓存机制

```python
from functools import lru_cache
import hashlib

class CachedIndicator(Indicator):
    """带缓存的技术指标基类"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._cache = {}

    def _get_cache_key(self, data: pd.DataFrame) -> str:
        """生成缓存键"""
        # 使用数据的哈希值作为缓存键
        data_str = f"{data.index[0]}_{data.index[-1]}_{len(data)}"
        return hashlib.md5(data_str.encode()).hexdigest()

    def calculate(self, data: pd.DataFrame) -> Union[pd.Series, Dict[str, pd.Series]]:
        """带缓存计算"""
        cache_key = self._get_cache_key(data)

        if cache_key in self._cache:
            return self._cache[cache_key]

        result = super().calculate(data)
        self._cache[cache_key] = result
        return result

    def clear_cache(self):
        """清空缓存"""
        self._cache.clear()
```

### 2. 批量计算优化

```python
class OptimizedIndicatorManager(IndicatorManager):
    """优化的指标管理器"""

    def calculate_all_optimized(self, data: pd.DataFrame) -> Dict[str, Union[pd.Series, Dict[str, pd.Series]]]:
        """优化的批量计算"""
        results = {}

        # 预计算常用的中间结果
        common_calculations = {
            'price_change': data['close'].pct_change(),
            'volume_ma': data['volume'].rolling(window=20).mean(),
            'high_low_diff': data['high'] - data['low'],
            'typical_price': (data['high'] + data['low'] + data['close']) / 3
        }

        # 按类型分组计算指标
        trend_indicators = {}
        momentum_indicators = {}
        volume_indicators = {}

        for name, indicator in self.indicators.items():
            if isinstance(indicator, TrendIndicator):
                trend_indicators[name] = indicator
            elif isinstance(indicator, MomentumIndicator):
                momentum_indicators[name] = indicator
            elif isinstance(indicator, VolumeIndicator):
                volume_indicators[name] = indicator

        # 并行计算不同类型的指标
        results.update(self._calculate_indicators_batch(trend_indicators, data, common_calculations))
        results.update(self._calculate_indicators_batch(momentum_indicators, data, common_calculations))
        results.update(self._calculate_indicators_batch(volume_indicators, data, common_calculations))

        self.indicator_data = results
        return results

    def _calculate_indicators_batch(self, indicators: Dict[str, Indicator],
                                  data: pd.DataFrame,
                                  common_calculations: Dict[str, pd.Series]) -> Dict[str, Union[pd.Series, Dict[str, pd.Series]]]:
        """批量计算同类型指标"""
        results = {}

        for name, indicator in indicators.items():
            try:
                if indicator.validate_params():
                    # 将常用计算结果传递给指标（如果指标支持）
                    if hasattr(indicator, 'set_common_calculations'):
                        indicator.set_common_calculations(common_calculations)

                    results[name] = indicator.calculate(data)
                else:
                    print(f"指标 {name} 参数验证失败")
            except Exception as e:
                print(f"指标 {name} 计算失败: {e}")

        return results
```

## 最佳实践

### 1. 指标选择原则
- **理解原理**: 深入理解每个指标的计算原理和适用场景
- **避免冗余**: 不要使用过多相关性很高的指标
- **组合使用**: 结合不同类型的指标进行确认
- **参数优化**: 根据不同品种和时间周期调整参数

### 2. 信号过滤
- **多时间框架**: 结合不同时间周期的信号
- **信号确认**: 使用多个指标确认交易信号
- **避免噪音**: 过滤掉过于频繁的信号
- **考虑市场环境**: 根据市场状态调整策略

### 3. 性能考虑
- **计算效率**: 优化指标计算算法
- **缓存机制**: 避免重复计算
- **批量处理**: 一次性计算多个指标
- **内存管理**: 及时清理不需要的数据

## 下一步

掌握技术指标后，您可以：
1. 学习[风险管理](07-风险管理.md)
2. 深入[策略开发](05-策略开发.md)
3. 探索[回测系统](08-回测系统.md)