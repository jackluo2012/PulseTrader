# ç¬¬äºŒé˜¶æ®µï¼šåŸºç¡€æ¡†æ¶æ­å»º

> **ç›®æ ‡**: å»ºç«‹ Rust+Python æ··åˆæ¶æ„çš„æ ¸å¿ƒæ¡†æ¶
> **é¢„è®¡æ—¶é—´**: 3-4å¤©
> **æäº¤æ ‡è®°**: `framework-complete`
> **å‰ç½®æ¡ä»¶**: å·²å®Œæˆ[ç¬¬ä¸€é˜¶æ®µç¯å¢ƒæ­å»º](./11-ç¬¬ä¸€é˜¶æ®µ-ç¯å¢ƒæ­å»º.md)

## ğŸ“‹ æ­¥éª¤æ¦‚è§ˆ

1. [âœ…] Rust æ ¸å¿ƒæ•°æ®ç»“æ„è®¾è®¡
2. [ ] Python FFI æ¥å£å®ç°
3. [ ] é”™è¯¯å¤„ç†ç³»ç»Ÿ
4. [ ] æ—¥å¿—ç³»ç»Ÿé…ç½®
5. [ ] å•å…ƒæµ‹è¯•æ¡†æ¶
6. [ ] åŸºç¡€å·¥å…·å‡½æ•°

---

## æ­¥éª¤ 1: Rust æ ¸å¿ƒæ•°æ®ç»“æ„è®¾è®¡

### 1.1 åŸºç¡€æ•°æ®ç±»å‹å®šä¹‰

ç¼–è¾‘ `engine/src/lib.rs`:

```rust
// engine/src/lib.rs

pub mod data;
pub mod indicators;
pub mod risk;
pub mod utils;
pub mod ffi;

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// äº¤æ˜“æ•°æ®ç±»å‹
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DataType {
    /// æ—¥Kçº¿æ•°æ®
    Daily,
    /// åˆ†é’ŸKçº¿æ•°æ®
    Minute1,
    Minute5,
    Minute15,
    Minute30,
    Minute60,
    /// Tickæ•°æ®
    Tick,
}

/// Kçº¿æ•°æ®ç»“æ„
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KlineData {
    /// ä»£ç 
    pub symbol: String,
    /// æ—¶é—´æˆ³
    pub timestamp: DateTime<Utc>,
    /// å¼€ç›˜ä»·
    pub open: f64,
    /// æœ€é«˜ä»·
    pub high: f64,
    /// æœ€ä½ä»·
    pub low: f64,
    /// æ”¶ç›˜ä»·
    pub close: f64,
    /// æˆäº¤é‡
    pub volume: f64,
    /// æˆäº¤é¢
    pub amount: f64,
    /// æ¶¨è·Œå¹…
    pub change_pct: f64,
}

impl KlineData {
    /// åˆ›å»ºæ–°çš„Kçº¿æ•°æ®
    pub fn new(
        symbol: String,
        timestamp: DateTime<Utc>,
        open: f64,
        high: f64,
        low: f64,
        close: f64,
        volume: f64,
        amount: f64,
    ) -> Self {
        let change_pct = if open > 0.0 { (close - open) / open } else { 0.0 };
        Self {
            symbol,
            timestamp,
            open,
            high,
            low,
            close,
            volume,
            amount,
            change_pct,
        }
    }

    /// éªŒè¯æ•°æ®æœ‰æ•ˆæ€§
    pub fn is_valid(&self) -> bool {
        self.open > 0.0
            && self.high > 0.0
            && self.low > 0.0
            && self.close > 0.0
            && self.high >= self.low
            && self.high >= self.open
            && self.high >= self.close
            && self.low <= self.open
            && self.low <= self.close
            && self.volume >= 0.0
            && self.amount >= 0.0
    }
}

/// Tickæ•°æ®ç»“æ„
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TickData {
    /// ä»£ç 
    pub symbol: String,
    /// æ—¶é—´æˆ³
    pub timestamp: DateTime<Utc>,
    /// æœ€æ–°ä»·
    pub price: f64,
    /// æˆäº¤é‡
    pub volume: f64,
    /// ä¹°ä¸€ä»·
    pub bid1: f64,
    /// ä¹°ä¸€é‡
    pub bid1_size: f64,
    /// å–ä¸€ä»·
    pub ask1: f64,
    /// å–ä¸€é‡
    pub ask1_size: f64,
}

/// æŠ€æœ¯æŒ‡æ ‡æ•°æ®
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IndicatorData {
    /// æ—¶é—´æˆ³
    pub timestamp: DateTime<Utc>,
    /// æŒ‡æ ‡å€¼å­—å…¸
    pub values: HashMap<String, f64>,
}

/// é”™è¯¯ç±»å‹å®šä¹‰
#[derive(Debug, thiserror::Error)]
pub enum PulseTraderError {
    #[error("æ•°æ®é”™è¯¯: {message}")]
    DataError { message: String },

    #[error("è®¡ç®—é”™è¯¯: {message}")]
    CalculationError { message: String },

    #[error("ç½‘ç»œé”™è¯¯: {source}")]
    NetworkError { #[from] source: reqwest::Error },

    #[error("IOé”™è¯¯: {source}")]
    IoError { #[from] source: std::io::Error },

    #[error("JSONè§£æé”™è¯¯: {source}")]
    JsonError { #[from] source: serde_json::Error },

    #[error("æ—¶é—´è§£æé”™è¯¯: {source}")]
    TimeError { #[from] source: chrono::ParseError },
}

pub type Result<T> = std::result::Result<T, PulseTraderError>;
```

### 1.2 æ•°æ®æºæŠ½è±¡æ¥å£

åˆ›å»º `engine/src/data/mod.rs`:

```rust
// engine/src/data/mod.rs

pub mod source;
pub mod storage;

pub use source::{DataSource, DataSourceConfig};
pub use storage::DataStorage;

use crate::{KlineData, TickData, DataType, Result};
use async_trait::async_trait;
use std::collections::HashMap;

/// æ•°æ®æºæŠ½è±¡æ¥å£
#[async_trait]
pub trait DataSource: Send + Sync {
    /// è·å–Kçº¿æ•°æ®
    async fn get_kline_data(
        &self,
        symbol: &str,
        data_type: DataType,
        start: chrono::DateTime<chrono::Utc>,
        end: chrono::DateTime<chrono::Utc>,
    ) -> Result<Vec<KlineData>>;

    /// è·å–å®æ—¶Tickæ•°æ®
    async fn get_tick_data(&self, symbol: &str) -> Result<Vec<TickData>>;

    /// è·å–è‚¡ç¥¨åˆ—è¡¨
    async fn get_stock_list(&self) -> Result<Vec<String>>;

    /// æ£€æŸ¥æ•°æ®æºæ˜¯å¦å¯ç”¨
    async fn health_check(&self) -> Result<bool>;
}

/// æ•°æ®æºé…ç½®
#[derive(Debug, Clone, serde::Deserialize)]
pub struct DataSourceConfig {
    /// æ•°æ®æºç±»å‹
    pub source_type: String,
    /// é…ç½®å‚æ•°
    pub params: HashMap<String, serde_json::Value>,
    /// è¯·æ±‚é™åˆ¶
    pub rate_limit: Option<u32>,
}
```

åˆ›å»º `engine/src/data/source.rs`:

```rust
// engine/src/data/source.rs

use super::{DataSource, DataSourceConfig};
use crate::{KlineData, TickData, DataType, Result};
use async_trait::async_trait;
use chrono::{DateTime, Utc};
use std::collections::HashMap;

/// æ¨¡æ‹Ÿæ•°æ®æºå®ç°ï¼ˆç”¨äºæµ‹è¯•ï¼‰
pub struct MockDataSource {
    config: DataSourceConfig,
}

impl MockDataSource {
    pub fn new(config: DataSourceConfig) -> Self {
        Self { config }
    }

    /// ç”Ÿæˆæ¨¡æ‹ŸKçº¿æ•°æ®
    fn generate_mock_kline(
        symbol: &str,
        start: DateTime<Utc>,
        end: DateTime<Utc>,
    ) -> Vec<KlineData> {
        let mut data = Vec::new();
        let mut current_time = start;
        let mut current_price = 100.0;

        while current_time <= end {
            // æ¨¡æ‹Ÿä»·æ ¼æ³¢åŠ¨
            let change = (rand::random::<f64>() - 0.5) * 2.0; // -1 åˆ° 1 çš„éšæœºå˜åŒ–
            let open = current_price;
            let close = current_price + change;
            let high = open.max(close) + rand::random::<f64>() * 0.5;
            let low = open.min(close) - rand::random::<f64>() * 0.5;
            let volume = rand::random::<f64>() * 1000000.0;
            let amount = volume * (open + high + low + close) / 4.0;

            data.push(KlineData::new(
                symbol.to_string(),
                current_time,
                open,
                high,
                low,
                close,
                volume,
                amount,
            ));

            current_price = close;
            current_time += chrono::Duration::days(1);
        }

        data
    }
}

#[async_trait]
impl DataSource for MockDataSource {
    async fn get_kline_data(
        &self,
        symbol: &str,
        _data_type: DataType,
        start: DateTime<Utc>,
        end: DateTime<Utc>,
    ) -> Result<Vec<KlineData>> {
        // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;

        let data = Self::generate_mock_kline(symbol, start, end);
        Ok(data)
    }

    async fn get_tick_data(&self, symbol: &str) -> Result<Vec<TickData>> {
        tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;

        // ç”Ÿæˆæ¨¡æ‹Ÿtickæ•°æ®
        let mut ticks = Vec::new();
        let now = Utc::now();

        for i in 0..10 {
            ticks.push(TickData {
                symbol: symbol.to_string(),
                timestamp: now + chrono::Duration::milliseconds(i * 100),
                price: 100.0 + (i as f64 * 0.01),
                volume: 1000.0,
                bid1: 99.99,
                bid1_size: 5000.0,
                ask1: 100.01,
                ask1_size: 5000.0,
            });
        }

        Ok(ticks)
    }

    async fn get_stock_list(&self) -> Result<Vec<String>> {
        tokio::time::sleep(tokio::time::Duration::from_millis(200)).await;

        Ok(vec![
            "000001.SZ".to_string(),
            "000002.SZ".to_string(),
            "600000.SH".to_string(),
            "600036.SH".to_string(),
        ])
    }

    async fn health_check(&self) -> Result<bool> {
        tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
        Ok(true)
    }
}
```

### 1.3 æ•°æ®å­˜å‚¨æ¨¡å—

åˆ›å»º `engine/src/data/storage.rs`:

```rust
// engine/src/data/storage.rs

use crate::{KlineData, TickData, Result};
use std::path::PathBuf;
use std::collections::HashMap;

/// æ•°æ®å­˜å‚¨æŠ½è±¡æ¥å£
pub trait DataStorage: Send + Sync {
    /// ä¿å­˜Kçº¿æ•°æ®
    fn save_kline_data(&self, data: &[KlineData]) -> Result<()>;

    /// è¯»å–Kçº¿æ•°æ®
    fn load_kline_data(
        &self,
        symbol: &str,
        start: chrono::DateTime<chrono::Utc>,
        end: chrono::DateTime<chrono::Utc>,
    ) -> Result<Vec<KlineData>>;

    /// ä¿å­˜Tickæ•°æ®
    fn save_tick_data(&self, data: &[TickData]) -> Result<()>;

    /// æ£€æŸ¥æ•°æ®æ˜¯å¦å­˜åœ¨
    fn data_exists(&self, symbol: &str, timestamp: chrono::DateTime<chrono::Utc>) -> Result<bool>;
}

/// æ–‡ä»¶ç³»ç»Ÿå­˜å‚¨å®ç°
pub struct FileStorage {
    base_path: PathBuf,
}

impl FileStorage {
    pub fn new(base_path: PathBuf) -> Self {
        Self { base_path }
    }

    fn get_data_path(&self, symbol: &str, data_type: &str) -> PathBuf {
        self.base_path
            .join("kline")
            .join(format!("{}.{}.csv", symbol, data_type))
    }
}

impl DataStorage for FileStorage {
    fn save_kline_data(&self, data: &[KlineData]) -> Result<()> {
        if data.is_empty() {
            return Ok(());
        }

        let symbol = &data[0].symbol;
        let path = self.get_data_path(symbol, "daily");

        // ç¡®ä¿ç›®å½•å­˜åœ¨
        if let Some(parent) = path.parent() {
            std::fs::create_dir_all(parent)?;
        }

        // ä½¿ç”¨CSVæ ¼å¼ä¿å­˜
        let mut wtr = csv::Writer::from_path(path)?;

        for kline in data {
            wtr.serialize(kline)?;
        }

        wtr.flush()?;
        Ok(())
    }

    fn load_kline_data(
        &self,
        symbol: &str,
        start: chrono::DateTime<chrono::Utc>,
        end: chrono::DateTime<chrono::Utc>,
    ) -> Result<Vec<KlineData>> {
        let path = self.get_data_path(symbol, "daily");

        if !path.exists() {
            return Ok(Vec::new());
        }

        let mut rdr = csv::Reader::from_path(path)?;
        let mut data = Vec::new();

        for result in rdr.deserialize() {
            let kline: KlineData = result?;
            if kline.timestamp >= start && kline.timestamp <= end {
                data.push(kline);
            }
        }

        Ok(data)
    }

    fn save_tick_data(&self, _data: &[TickData]) -> Result<()> {
        // TODO: å®ç°Tickæ•°æ®å­˜å‚¨
        Ok(())
    }

    fn data_exists(&self, _symbol: &str, _timestamp: chrono::DateTime<chrono::Utc>) -> Result<bool> {
        // TODO: å®ç°æ•°æ®å­˜åœ¨æ€§æ£€æŸ¥
        Ok(false)
    }
}
```

### 1.4 æ›´æ–° Cargo.toml ä¾èµ–

ç¼–è¾‘ `engine/Cargo.toml` æ·»åŠ æ–°çš„ä¾èµ–ï¼š

```toml
# åœ¨ [dependencies] éƒ¨åˆ†æ·»åŠ 
async-trait = "0.1"
csv = "1.3"
rand = "0.8"
```

---

## æ­¥éª¤ 2: Python FFI æ¥å£å®ç°

### 2.1 åˆ›å»º FFI æ¨¡å—

åˆ›å»º `engine/src/ffi/mod.rs`:

```rust
// engine/src/ffi/mod.rs

use crate::{KlineData, DataType, Result};
use pyo3::prelude::*;
use pyo3::types::{PyDateTime, PyDict};
use chrono::{DateTime, Utc, TimeZone};
use std::collections::HashMap;

/// å°† KlineData è½¬æ¢ä¸º Python å¯¹è±¡
#[pyclass]
pub struct PyKlineData {
    #[pyo3(get)]
    pub symbol: String,
    #[pyo3(get)]
    pub timestamp: Py<PyDateTime>,
    #[pyo3(get)]
    pub open: f64,
    #[pyo3(get)]
    pub high: f64,
    #[pyo3(get)]
    pub low: f64,
    #[pyo3(get)]
    pub close: f64,
    #[pyo3(get)]
    pub volume: f64,
    #[pyo3(get)]
    pub amount: f64,
    #[pyo3(get)]
    pub change_pct: f64,
}

impl From<KlineData> for PyKlineData {
    fn from(kline: KlineData) -> Self {
        Python::with_gil(|py| {
            let timestamp = PyDateTime::new_from_timestamp(
                py,
                kline.timestamp.timestamp(),
                Some(kline.timestamp.timestamp_subsec_nanos() as u32),
            ).unwrap();

            Self {
                symbol: kline.symbol,
                timestamp,
                open: kline.open,
                high: kline.high,
                low: kline.low,
                close: kline.close,
                volume: kline.volume,
                amount: kline.amount,
                change_pct: kline.change_pct,
            }
        })
    }
}

/// æ•°æ®å¼•æ“ Python æ¥å£
#[pyclass]
pub struct DataEngine {
    // è¿™é‡Œå°†æ¥ä¼šåŒ…å«å®é™…çš„æ•°æ®æº
    #[pyo3(get)]
    pub initialized: bool,
}

#[pymethods]
impl DataEngine {
    #[new]
    fn new() -> Self {
        Self {
            initialized: false,
        }
    }

    /// åˆå§‹åŒ–æ•°æ®å¼•æ“
    fn initialize(&mut self) -> Result<()> {
        // TODO: å®é™…çš„åˆå§‹åŒ–é€»è¾‘
        self.initialized = true;
        Ok(())
    }

    /// è·å–Kçº¿æ•°æ®
    fn get_kline_data(
        &self,
        py: Python,
        symbol: &str,
        start_date: &PyDateTime,
        end_date: &PyDateTime,
    ) -> Result<Vec<PyKlineData>> {
        // TODO: å®é™…çš„æ•°æ®è·å–é€»è¾‘
        // è¿™é‡Œè¿”å›æ¨¡æ‹Ÿæ•°æ®ç”¨äºæ¼”ç¤º

        let start_timestamp = start_date.timestamp();
        let end_timestamp = end_date.timestamp();

        let mut data = Vec::new();
        let mut current_time = Utc.timestamp_opt(start_timestamp, 0).unwrap();

        while current_time.timestamp() <= end_timestamp {
            let mock_kline = KlineData::new(
                symbol.to_string(),
                current_time,
                100.0,  // open
                102.0,  // high
                99.0,   // low
                101.0,  // close
                1000000.0,  // volume
                101000000.0, // amount
            );

            data.push(PyKlineData::from(mock_kline));
            current_time += chrono::Duration::days(1);
        }

        Ok(data)
    }

    /// æ£€æŸ¥å¼•æ“å¥åº·çŠ¶æ€
    fn health_check(&self) -> bool {
        self.initialized
    }
}

/// Python æ¨¡å—å®šä¹‰
#[pymodule]
fn pulse_trader_engine(_py: Python, m: &PyModule) -> PyResult<()> {
    m.add_class::<PyKlineData>()?;
    m.add_class::<DataEngine>()?;

    // æ·»åŠ ç‰ˆæœ¬ä¿¡æ¯
    m.add("__version__", env!("CARGO_PKG_VERSION"))?;

    Ok(())
}
```

### 2.2 é…ç½® Maturin æ„å»ºæ–‡ä»¶

åœ¨é¡¹ç›®æ ¹ç›®å½•åˆ›å»º `pyproject.toml`:

```toml
# pyproject.toml

[build-system]
requires = ["maturin>=1.4,<2.0"]
build-backend = "maturin"

[project]
name = "pulse-trader"
requires-python = ">=3.8"
classifiers = [
    "Programming Language :: Rust",
    "Programming Language :: Python :: Implementation :: CPython",
    "Programming Language :: Python :: Implementation :: PyPy",
]
dependencies = [
    "pandas>=2.1.0",
    "numpy>=1.24.0",
    "matplotlib>=3.7.0",
    "python-dotenv>=1.0.0",
    "pyyaml>=6.0.0",
]

[tool.maturin]
features = ["pyo3/extension-module"]
module-name = "pulse_trader_engine._pulse_trader_engine"
python-source = "python"
```

### 2.3 æ„å»º Python æ‰©å±•

```bash
# åœ¨é¡¹ç›®æ ¹ç›®å½•æ‰§è¡Œ
maturin develop

# å¦‚æœé‡åˆ°é”™è¯¯ï¼Œå¯èƒ½éœ€è¦å…ˆå®‰è£…ä¸€äº›ç³»ç»Ÿä¾èµ–
# Ubuntu/Debian: sudo apt install build-essential python3-dev
# macOS: xcode-select --install
```

### 2.4 åˆ›å»º Python åŒ…è£…å™¨

åˆ›å»º `python/pulse_trader/engine.py`:

```python
# python/pulse_trader/engine.py

"""
PulseTrader æ•°æ®å¼•æ“ Python æ¥å£
"""

from typing import List, Optional, Union
from datetime import datetime
import pandas as pd
from pulse_trader_engine import DataEngine, PyKlineData


class DataEngineWrapper:
    """æ•°æ®å¼•æ“ Python åŒ…è£…å™¨"""

    def __init__(self):
        self._engine = DataEngine()
        self._initialized = False

    def initialize(self) -> bool:
        """åˆå§‹åŒ–æ•°æ®å¼•æ“"""
        try:
            self._engine.initialize()
            self._initialized = True
            return True
        except Exception as e:
            print(f"åˆå§‹åŒ–å¤±è´¥: {e}")
            return False

    def get_kline_data(
        self,
        symbol: str,
        start_date: Union[datetime, str],
        end_date: Union[datetime, str],
    ) -> pd.DataFrame:
        """
        è·å–Kçº¿æ•°æ®

        Args:
            symbol: è‚¡ç¥¨ä»£ç 
            start_date: å¼€å§‹æ—¥æœŸ (datetime æˆ–å­—ç¬¦ä¸²)
            end_date: ç»“æŸæ—¥æœŸ (datetime æˆ–å­—ç¬¦ä¸²)

        Returns:
            åŒ…å«Kçº¿æ•°æ®çš„ DataFrame
        """
        if not self._initialized:
            raise RuntimeError("æ•°æ®å¼•æ“æœªåˆå§‹åŒ–ï¼Œè¯·å…ˆè°ƒç”¨ initialize()")

        # è½¬æ¢æ—¥æœŸæ ¼å¼
        if isinstance(start_date, str):
            start_date = pd.to_datetime(start_date).to_pydatetime()
        if isinstance(end_date, str):
            end_date = pd.to_datetime(end_date).to_pydatetime()

        # è°ƒç”¨ Rust å¼•æ“
        py_data = self._engine.get_kline_data(symbol, start_date, end_date)

        # è½¬æ¢ä¸º DataFrame
        if not py_data:
            return pd.DataFrame()

        # æå–æ•°æ®
        data_list = []
        for item in py_data:
            data_list.append({
                'symbol': item.symbol,
                'timestamp': item.timestamp,
                'open': item.open,
                'high': item.high,
                'low': item.low,
                'close': item.close,
                'volume': item.volume,
                'amount': item.amount,
                'change_pct': item.change_pct,
            })

        df = pd.DataFrame(data_list)
        df['timestamp'] = pd.to_datetime(df['timestamp'])
        df.set_index('timestamp', inplace=True)

        return df

    def health_check(self) -> bool:
        """æ£€æŸ¥å¼•æ“å¥åº·çŠ¶æ€"""
        return self._engine.health_check()


# å…¨å±€å®ä¾‹
_engine_instance = None

def get_engine() -> DataEngineWrapper:
    """è·å–å…¨å±€æ•°æ®å¼•æ“å®ä¾‹"""
    global _engine_instance
    if _engine_instance is None:
        _engine_instance = DataEngineWrapper()
    return _engine_instance
```

---

## æ­¥éª¤ 3: é”™è¯¯å¤„ç†ç³»ç»Ÿ

### 3.1 åˆ›å»º Python å¼‚å¸¸ç±»

åˆ›å»º `python/pulse_trader/exceptions.py`:

```python
# python/pulse_trader/exceptions.py

"""
PulseTrader å¼‚å¸¸å®šä¹‰
"""


class PulseTraderError(Exception):
    """åŸºç¡€å¼‚å¸¸ç±»"""
    pass


class DataError(PulseTraderError):
    """æ•°æ®ç›¸å…³å¼‚å¸¸"""
    pass


class NetworkError(PulseTraderError):
    """ç½‘ç»œç›¸å…³å¼‚å¸¸"""
    pass


class CalculationError(PulseTraderError):
    """è®¡ç®—ç›¸å…³å¼‚å¸¸"""
    pass


class ConfigError(PulseTraderError):
    """é…ç½®ç›¸å…³å¼‚å¸¸"""
    pass


class ValidationError(PulseTraderError):
    """æ•°æ®éªŒè¯å¼‚å¸¸"""
    pass
```

### 3.2 åˆ›å»ºå·¥å…·å‡½æ•°æ¨¡å—

åˆ›å»º `python/pulse_trader/utils/__init__.py`:

```python
# python/pulse_trader/utils/__init__.py

"""
å·¥å…·å‡½æ•°æ¨¡å—
"""

from .logger import get_logger, setup_logging
from .config import load_config, get_config
from .validation import validate_kline_data, validate_symbol

__all__ = [
    "get_logger",
    "setup_logging",
    "load_config",
    "get_config",
    "validate_kline_data",
    "validate_symbol",
]
```

åˆ›å»º `python/pulse_trader/utils/logger.py`:

```python
# python/pulse_trader/utils/logger.py

"""
æ—¥å¿—ç³»ç»Ÿé…ç½®
"""

import logging
import sys
from pathlib import Path
from typing import Optional
import yaml


def setup_logging(
    level: str = "INFO",
    log_file: Optional[str] = None,
    format_string: Optional[str] = None,
) -> None:
    """
    è®¾ç½®æ—¥å¿—ç³»ç»Ÿ

    Args:
        level: æ—¥å¿—çº§åˆ« (DEBUG, INFO, WARNING, ERROR, CRITICAL)
        log_file: æ—¥å¿—æ–‡ä»¶è·¯å¾„
        format_string: æ—¥å¿—æ ¼å¼å­—ç¬¦ä¸²
    """
    if format_string is None:
        format_string = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"

    # é…ç½®æ ¹æ—¥å¿—è®°å½•å™¨
    root_logger = logging.getLogger()
    root_logger.setLevel(getattr(logging, level.upper()))

    # æ¸…é™¤ç°æœ‰çš„å¤„ç†å™¨
    for handler in root_logger.handlers[:]:
        root_logger.removeHandler(handler)

    # åˆ›å»ºæ ¼å¼åŒ–å™¨
    formatter = logging.Formatter(format_string)

    # æ§åˆ¶å°å¤„ç†å™¨
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    root_logger.addHandler(console_handler)

    # æ–‡ä»¶å¤„ç†å™¨ (å¦‚æœæŒ‡å®šäº†æ–‡ä»¶è·¯å¾„)
    if log_file:
        log_path = Path(log_file)
        log_path.parent.mkdir(parents=True, exist_ok=True)

        file_handler = logging.FileHandler(log_path, encoding='utf-8')
        file_handler.setFormatter(formatter)
        root_logger.addHandler(file_handler)


def get_logger(name: str) -> logging.Logger:
    """
    è·å–æŒ‡å®šåç§°çš„æ—¥å¿—è®°å½•å™¨

    Args:
        name: æ—¥å¿—è®°å½•å™¨åç§°

    Returns:
        Logger å®ä¾‹
    """
    return logging.getLogger(name)
```

åˆ›å»º `python/pulse_trader/utils/config.py`:

```python
# python/pulse_trader/utils/config.py

"""
é…ç½®ç®¡ç†å·¥å…·
"""

import os
import yaml
from pathlib import Path
from typing import Any, Dict, Optional
from dotenv import load_dotenv
from ..exceptions import ConfigError


class Config:
    """é…ç½®ç®¡ç†ç±»"""

    def __init__(self, config_file: Optional[str] = None):
        self._config: Dict[str, Any] = {}
        self._config_file = config_file

        # åŠ è½½ç¯å¢ƒå˜é‡
        load_dotenv()

        # åŠ è½½é…ç½®æ–‡ä»¶
        if config_file:
            self.load_config(config_file)

    def load_config(self, config_file: str) -> None:
        """
        åŠ è½½é…ç½®æ–‡ä»¶

        Args:
            config_file: é…ç½®æ–‡ä»¶è·¯å¾„
        """
        config_path = Path(config_file)
        if not config_path.exists():
            raise ConfigError(f"é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: {config_file}")

        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                self._config = yaml.safe_load(f) or {}
        except yaml.YAMLError as e:
            raise ConfigError(f"é…ç½®æ–‡ä»¶è§£æå¤±è´¥: {e}")

    def get(self, key: str, default: Any = None) -> Any:
        """
        è·å–é…ç½®å€¼ï¼Œæ”¯æŒç‚¹åˆ†éš”çš„åµŒå¥—é”®

        Args:
            key: é…ç½®é”® (æ”¯æŒ "app.name" æ ¼å¼)
            default: é»˜è®¤å€¼

        Returns:
            é…ç½®å€¼
        """
        keys = key.split('.')
        value = self._config

        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]
            else:
                # å°è¯•ä»ç¯å¢ƒå˜é‡è·å–
                env_key = '_'.join(keys).upper()
                env_value = os.getenv(env_key)
                if env_value is not None:
                    return env_value
                return default

        # å¦‚æœå€¼æ˜¯å­—ç¬¦ä¸²ä¸”åŒ…å«ç¯å¢ƒå˜é‡å¼•ç”¨ï¼Œè¿›è¡Œæ›¿æ¢
        if isinstance(value, str) and '${' in value:
            import re
            pattern = r'\$\{([^}]+)\}'

            def replace_env_var(match):
                env_var = match.group(1)
                return os.getenv(env_var, match.group(0))

            value = re.sub(pattern, replace_env_var, value)

        return value

    def set(self, key: str, value: Any) -> None:
        """
        è®¾ç½®é…ç½®å€¼

        Args:
            key: é…ç½®é”®
            value: é…ç½®å€¼
        """
        keys = key.split('.')
        config = self._config

        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]

        config[keys[-1]] = value


# å…¨å±€é…ç½®å®ä¾‹
_config_instance = None

def load_config(config_file: Optional[str] = None) -> Config:
    """åŠ è½½é…ç½®æ–‡ä»¶"""
    global _config_instance
    if config_file is None:
        # å°è¯•æ‰¾åˆ°é»˜è®¤é…ç½®æ–‡ä»¶
        default_paths = [
            "config/config.yaml",
            "../config/config.yaml",
            "../../config/config.yaml",
        ]

        for path in default_paths:
            if Path(path).exists():
                config_file = path
                break

    _config_instance = Config(config_file)
    return _config_instance

def get_config() -> Config:
    """è·å–å…¨å±€é…ç½®å®ä¾‹"""
    global _config_instance
    if _config_instance is None:
        _config_instance = load_config()
    return _config_instance
```

åˆ›å»º `python/pulse_trader/utils/validation.py`:

```python
# python/pulse_trader/utils/validation.py

"""
æ•°æ®éªŒè¯å·¥å…·
"""

import pandas as pd
import re
from typing import List, Union
from ..exceptions import ValidationError


def validate_symbol(symbol: str) -> bool:
    """
    éªŒè¯è‚¡ç¥¨ä»£ç æ ¼å¼

    Args:
        symbol: è‚¡ç¥¨ä»£ç 

    Returns:
        æ˜¯å¦æœ‰æ•ˆ
    """
    if not isinstance(symbol, str):
        raise ValidationError("è‚¡ç¥¨ä»£ç å¿…é¡»æ˜¯å­—ç¬¦ä¸²")

    # Aè‚¡ä»£ç æ ¼å¼: 6ä½æ•°å­— + .äº¤æ˜“æ‰€ä»£ç 
    pattern = r'^\d{6}\.(SH|SZ|BJ)$'
    if not re.match(pattern, symbol):
        raise ValidationError(f"æ— æ•ˆçš„è‚¡ç¥¨ä»£ç æ ¼å¼: {symbol}")

    return True


def validate_kline_data(df: pd.DataFrame) -> bool:
    """
    éªŒè¯Kçº¿æ•°æ®çš„æœ‰æ•ˆæ€§

    Args:
        df: Kçº¿æ•°æ® DataFrame

    Returns:
        æ˜¯å¦æœ‰æ•ˆ
    """
    if df.empty:
        raise ValidationError("Kçº¿æ•°æ®ä¸ºç©º")

    required_columns = ['open', 'high', 'low', 'close', 'volume']
    missing_columns = [col for col in required_columns if col not in df.columns]

    if missing_columns:
        raise ValidationError(f"ç¼ºå°‘å¿…éœ€çš„åˆ—: {missing_columns}")

    # æ£€æŸ¥ä»·æ ¼æ•°æ®çš„åˆç†æ€§
    price_columns = ['open', 'high', 'low', 'close']

    for col in price_columns:
        if (df[col] <= 0).any():
            raise ValidationError(f"åˆ— {col} ä¸­å­˜åœ¨éæ­£æ•°ä»·æ ¼")

    # æ£€æŸ¥é«˜ä½ä»·å…³ç³»
    if (df['high'] < df['low']).any():
        raise ValidationError("æœ€é«˜ä»·ä¸èƒ½ä½äºæœ€ä½ä»·")

    # æ£€æŸ¥æˆäº¤é‡
    if (df['volume'] < 0).any():
        raise ValidationError("æˆäº¤é‡ä¸èƒ½ä¸ºè´Ÿæ•°")

    return True


def validate_date_range(start_date: str, end_date: str) -> bool:
    """
    éªŒè¯æ—¥æœŸèŒƒå›´

    Args:
        start_date: å¼€å§‹æ—¥æœŸ
        end_date: ç»“æŸæ—¥æœŸ

    Returns:
        æ˜¯å¦æœ‰æ•ˆ
    """
    try:
        start = pd.to_datetime(start_date)
        end = pd.to_datetime(end_date)

        if start >= end:
            raise ValidationError("å¼€å§‹æ—¥æœŸå¿…é¡»æ—©äºç»“æŸæ—¥æœŸ")

        return True
    except Exception as e:
        raise ValidationError(f"æ—¥æœŸæ ¼å¼é”™è¯¯: {e}")
```

---

## æ­¥éª¤ 4: åˆ›å»ºå•å…ƒæµ‹è¯•

### 4.1 Rust å•å…ƒæµ‹è¯•

åˆ›å»º `engine/src/lib.rs` çš„æµ‹è¯•æ¨¡å—ï¼š

```rust
// åœ¨ engine/src/lib.rs æœ«å°¾æ·»åŠ æµ‹è¯•

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::{Utc, Duration};

    #[test]
    fn test_kline_data_creation() {
        let timestamp = Utc::now();
        let kline = KlineData::new(
            "000001.SZ".to_string(),
            timestamp,
            10.0,
            11.0,
            9.5,
            10.5,
            1000000.0,
            10500000.0,
        );

        assert_eq!(kline.symbol, "000001.SZ");
        assert_eq!(kline.open, 10.0);
        assert_eq!(kline.close, 10.5);
        assert!(kline.is_valid());
    }

    #[test]
    fn test_kline_data_validation() {
        let timestamp = Utc::now();

        // æœ‰æ•ˆæ•°æ®
        let valid_kline = KlineData::new(
            "000001.SZ".to_string(),
            timestamp,
            10.0,
            11.0,
            9.5,
            10.5,
            1000000.0,
            10500000.0,
        );
        assert!(valid_kline.is_valid());

        // æ— æ•ˆæ•°æ® (high < low)
        let invalid_kline = KlineData::new(
            "000001.SZ".to_string(),
            timestamp,
            10.0,
            9.0,  // high < low
            9.5,
            10.5,
            1000000.0,
            10500000.0,
        );
        assert!(!invalid_kline.is_valid());
    }

    #[tokio::test]
    async fn test_mock_data_source() {
        use data::source::{MockDataSource, DataSourceConfig};
        use std::collections::HashMap;

        let config = DataSourceConfig {
            source_type: "mock".to_string(),
            params: HashMap::new(),
            rate_limit: None,
        };

        let source = MockDataSource::new(config);

        // æµ‹è¯•å¥åº·æ£€æŸ¥
        assert!(source.health_check().await.unwrap());

        // æµ‹è¯•è·å–è‚¡ç¥¨åˆ—è¡¨
        let stock_list = source.get_stock_list().await.unwrap();
        assert!(!stock_list.is_empty());

        // æµ‹è¯•è·å–Kçº¿æ•°æ®
        let end = Utc::now();
        let start = end - Duration::days(5);
        let kline_data = source
            .get_kline_data("000001.SZ", DataType::Daily, start, end)
            .await
            .unwrap();

        assert!(!kline_data.is_empty());
        for kline in &kline_data {
            assert!(kline.is_valid());
        }
    }
}
```

### 4.2 Python å•å…ƒæµ‹è¯•

åˆ›å»º `python/tests/test_engine.py`:

```python
# python/tests/test_engine.py

"""
æ•°æ®å¼•æ“æµ‹è¯•
"""

import pytest
from datetime import datetime, timedelta
import pandas as pd
from pulse_trader.engine import get_engine, DataEngineWrapper
from pulse_trader.exceptions import DataError


class TestDataEngine:
    """æ•°æ®å¼•æ“æµ‹è¯•ç±»"""

    def setup_method(self):
        """æ¯ä¸ªæµ‹è¯•æ–¹æ³•å‰çš„è®¾ç½®"""
        self.engine = DataEngineWrapper()

    def test_engine_initialization(self):
        """æµ‹è¯•å¼•æ“åˆå§‹åŒ–"""
        assert not self.engine._initialized

        result = self.engine.initialize()
        assert result is True
        assert self.engine._initialized

    def test_health_check(self):
        """æµ‹è¯•å¥åº·æ£€æŸ¥"""
        # æœªåˆå§‹åŒ–æ—¶
        assert not self.engine.health_check()

        # åˆå§‹åŒ–å
        self.engine.initialize()
        assert self.engine.health_check()

    def test_get_kline_data_uninitialized(self):
        """æµ‹è¯•æœªåˆå§‹åŒ–æ—¶è·å–æ•°æ®"""
        with pytest.raises(RuntimeError):
            self.engine.get_kline_data("000001.SZ", "2023-01-01", "2023-01-10")

    def test_get_kline_data_initialized(self):
        """æµ‹è¯•åˆå§‹åŒ–åè·å–æ•°æ®"""
        self.engine.initialize()

        df = self.engine.get_kline_data(
            "000001.SZ",
            "2023-01-01",
            "2023-01-10"
        )

        assert isinstance(df, pd.DataFrame)
        assert not df.empty
        assert 'open' in df.columns
        assert 'close' in df.columns
        assert 'volume' in df.columns

    def test_get_kline_data_with_datetime(self):
        """æµ‹è¯•ä½¿ç”¨ datetime å¯¹è±¡è·å–æ•°æ®"""
        self.engine.initialize()

        start_date = datetime(2023, 1, 1)
        end_date = datetime(2023, 1, 5)

        df = self.engine.get_kline_data("000001.SZ", start_date, end_date)

        assert isinstance(df, pd.DataFrame)
        assert not df.empty

    def test_global_engine_instance(self):
        """æµ‹è¯•å…¨å±€å¼•æ“å®ä¾‹"""
        engine1 = get_engine()
        engine2 = get_engine()

        # åº”è¯¥æ˜¯åŒä¸€ä¸ªå®ä¾‹
        assert engine1 is engine2


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
```

åˆ›å»º `python/tests/test_utils.py`:

```python
# python/tests/test_utils.py

"""
å·¥å…·å‡½æ•°æµ‹è¯•
"""

import pytest
import tempfile
import os
from pathlib import Path
from pulse_trader.utils.validation import validate_symbol, validate_kline_data, validate_date_range
from pulse_trader.utils.config import Config
from pulse_trader.exceptions import ValidationError, ConfigError


class TestValidation:
    """éªŒè¯å·¥å…·æµ‹è¯•ç±»"""

    def test_validate_symbol_valid(self):
        """æµ‹è¯•æœ‰æ•ˆè‚¡ç¥¨ä»£ç """
        valid_symbols = [
            "000001.SZ",
            "600000.SH",
            "872305.BJ",
        ]

        for symbol in valid_symbols:
            assert validate_symbol(symbol) is True

    def test_validate_symbol_invalid(self):
        """æµ‹è¯•æ— æ•ˆè‚¡ç¥¨ä»£ç """
        invalid_symbols = [
            "000001",  # ç¼ºå°‘äº¤æ˜“æ‰€
            "000001.S", # æ— æ•ˆäº¤æ˜“æ‰€
            "ABCDEF.SZ", # éæ•°å­—ä»£ç 
            123456,     # éå­—ç¬¦ä¸²
            "",         # ç©ºå­—ç¬¦ä¸²
        ]

        for symbol in invalid_symbols:
            with pytest.raises(ValidationError):
                validate_symbol(symbol)

    def test_validate_kline_data_valid(self):
        """æµ‹è¯•æœ‰æ•ˆKçº¿æ•°æ®"""
        import pandas as pd

        df = pd.DataFrame({
            'open': [10.0, 10.5, 11.0],
            'high': [10.5, 11.0, 11.5],
            'low': [9.5, 10.0, 10.5],
            'close': [10.5, 11.0, 11.5],
            'volume': [1000000, 1100000, 1200000],
        })

        assert validate_kline_data(df) is True

    def test_validate_kline_data_invalid(self):
        """æµ‹è¯•æ— æ•ˆKçº¿æ•°æ®"""
        import pandas as pd

        # ç¼ºå°‘å¿…éœ€åˆ—
        df_invalid = pd.DataFrame({
            'open': [10.0, 10.5],
            'close': [10.5, 11.0],
        })

        with pytest.raises(ValidationError):
            validate_kline_data(df_invalid)

        # ä»·æ ¼æ•°æ®ä¸åˆç†
        df_negative = pd.DataFrame({
            'open': [10.0, -10.5],  # è´Ÿä»·æ ¼
            'high': [10.5, 11.0],
            'low': [9.5, 10.0],
            'close': [10.5, 11.0],
            'volume': [1000000, 1100000],
        })

        with pytest.raises(ValidationError):
            validate_kline_data(df_negative)

    def test_validate_date_range_valid(self):
        """æµ‹è¯•æœ‰æ•ˆæ—¥æœŸèŒƒå›´"""
        assert validate_date_range("2023-01-01", "2023-01-10") is True
        assert validate_date_range("2023-01-01 00:00:00", "2023-01-10 23:59:59") is True

    def test_validate_date_range_invalid(self):
        """æµ‹è¯•æ— æ•ˆæ—¥æœŸèŒƒå›´"""
        # å¼€å§‹æ—¥æœŸæ™šäºç»“æŸæ—¥æœŸ
        with pytest.raises(ValidationError):
            validate_date_range("2023-01-10", "2023-01-01")

        # æ— æ•ˆæ—¥æœŸæ ¼å¼
        with pytest.raises(ValidationError):
            validate_date_range("invalid-date", "2023-01-01")


class TestConfig:
    """é…ç½®ç®¡ç†æµ‹è¯•ç±»"""

    def test_config_load_invalid_file(self):
        """æµ‹è¯•åŠ è½½æ— æ•ˆé…ç½®æ–‡ä»¶"""
        with pytest.raises(ConfigError):
            Config("nonexistent_file.yaml")

    def test_config_get_set(self):
        """æµ‹è¯•é…ç½®è·å–å’Œè®¾ç½®"""
        config = Config()

        # è®¾ç½®å€¼
        config.set("test.key", "test_value")

        # è·å–å€¼
        assert config.get("test.key") == "test_value"
        assert config.get("nonexistent.key", "default") == "default"

    def test_config_env_substitution(self):
        """æµ‹è¯•ç¯å¢ƒå˜é‡æ›¿æ¢"""
        config = Config()

        # è®¾ç½®ç¯å¢ƒå˜é‡
        os.environ["TEST_VAR"] = "env_value"

        # æ¨¡æ‹Ÿé…ç½®å€¼
        config._config = {
            "test": {
                "substitution": "${TEST_VAR}"
            }
        }

        assert config.get("test.substitution") == "env_value"

        # æ¸…ç†
        del os.environ["TEST_VAR"]


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
```

### 4.3 åˆ›å»ºæµ‹è¯•é…ç½®æ–‡ä»¶

åˆ›å»º `python/pytest.ini`:

```ini
[tool:pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts =
    -v
    --tb=short
    --strict-markers
    --disable-warnings
    --cov=pulse_trader
    --cov-report=html
    --cov-report=term-missing
markers =
    slow: marks tests as slow (deselect with '-m "not slow"')
    integration: marks tests as integration tests
    unit: marks tests as unit tests
```

---

## æ­¥éª¤ 5: è¿è¡Œæµ‹è¯•å’ŒéªŒè¯

### 5.1 Rust æµ‹è¯•

```bash
# åœ¨é¡¹ç›®æ ¹ç›®å½•
cd engine

# è¿è¡Œæ‰€æœ‰æµ‹è¯•
cargo test

# è¿è¡Œç‰¹å®šæµ‹è¯•
cargo test test_kline_data_creation

# æ˜¾ç¤ºæµ‹è¯•è¾“å‡º
cargo test -- --nocapture

cd ..
```

### 5.2 Python æµ‹è¯•

```bash
# ç¡®ä¿è™šæ‹Ÿç¯å¢ƒå·²æ¿€æ´»
source .venv/bin/activate

# é‡æ–°æ„å»º Python æ‰©å±•
maturin develop

# è¿è¡Œ Python æµ‹è¯•
cd python
python -m pytest tests/ -v

# è¿è¡Œç‰¹å®šæµ‹è¯•æ–‡ä»¶
python -m pytest tests/test_engine.py -v

# ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
python -m pytest tests/ --cov=pulse_trader --cov-report=html

cd ..
```

### 5.3 é›†æˆæµ‹è¯•

åˆ›å»º `tests/integration_test.py`:

```python
#!/usr/bin/env python3
"""
é›†æˆæµ‹è¯•è„šæœ¬
"""

import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'python'))

from pulse_trader.engine import get_engine
from pulse_trader.utils import setup_logging, get_logger
from datetime import datetime, timedelta


def test_basic_workflow():
    """æµ‹è¯•åŸºæœ¬å·¥ä½œæµç¨‹"""
    print("ğŸ§ª å¼€å§‹é›†æˆæµ‹è¯•...")

    # è®¾ç½®æ—¥å¿—
    setup_logging(level="INFO")
    logger = get_logger(__name__)

    try:
        # 1. è·å–æ•°æ®å¼•æ“
        logger.info("è·å–æ•°æ®å¼•æ“...")
        engine = get_engine()

        # 2. åˆå§‹åŒ–å¼•æ“
        logger.info("åˆå§‹åŒ–æ•°æ®å¼•æ“...")
        if not engine.initialize():
            raise Exception("å¼•æ“åˆå§‹åŒ–å¤±è´¥")

        # 3. å¥åº·æ£€æŸ¥
        logger.info("æ‰§è¡Œå¥åº·æ£€æŸ¥...")
        if not engine.health_check():
            raise Exception("å¥åº·æ£€æŸ¥å¤±è´¥")

        # 4. è·å–æµ‹è¯•æ•°æ®
        logger.info("è·å–æµ‹è¯•æ•°æ®...")
        end_date = datetime.now()
        start_date = end_date - timedelta(days=10)

        df = engine.get_kline_data("000001.SZ", start_date, end_date)

        if df.empty:
            raise Exception("è·å–æ•°æ®å¤±è´¥")

        logger.info(f"æˆåŠŸè·å– {len(df)} æ¡Kçº¿æ•°æ®")
        logger.info(f"æ•°æ®åˆ—: {list(df.columns)}")
        logger.info(f"æ•°æ®ç¤ºä¾‹:\n{df.head()}")

        print("âœ… é›†æˆæµ‹è¯•é€šè¿‡ï¼")
        return True

    except Exception as e:
        logger.error(f"é›†æˆæµ‹è¯•å¤±è´¥: {e}")
        print(f"âŒ é›†æˆæµ‹è¯•å¤±è´¥: {e}")
        return False


if __name__ == "__main__":
    success = test_basic_workflow()
    sys.exit(0 if success else 1)
```

è¿è¡Œé›†æˆæµ‹è¯•ï¼š

```bash
# åœ¨é¡¹ç›®æ ¹ç›®å½•
python tests/integration_test.py
```

---

## âœ… å®Œæˆæ£€æŸ¥æ¸…å•

### ä»£ç å®ç°
- [ ] Rust æ ¸å¿ƒæ•°æ®ç»“æ„å·²å®ç°
- [ ] Python FFI æ¥å£å·²åˆ›å»º
- [ ] é”™è¯¯å¤„ç†ç³»ç»Ÿå·²é…ç½®
- [ ] æ—¥å¿—ç³»ç»Ÿå·²å®ç°
- [ ] å·¥å…·å‡½æ•°æ¨¡å—å·²å®Œæˆ

### æµ‹è¯•è¦†ç›–
- [ ] Rust å•å…ƒæµ‹è¯•å…¨éƒ¨é€šè¿‡
- [ ] Python å•å…ƒæµ‹è¯•å…¨éƒ¨é€šè¿‡
- [ ] é›†æˆæµ‹è¯•æˆåŠŸè¿è¡Œ
- [ ] ä»£ç è¦†ç›–ç‡æŠ¥å‘Šç”Ÿæˆ

### æ„å»ºéªŒè¯
- [ ] `maturin develop` æ„å»ºæˆåŠŸ
- [ ] Python æ¨¡å—å¯ä»¥æ­£å¸¸å¯¼å…¥
- [ ] æ‰€æœ‰åŠŸèƒ½å¯ä»¥æ­£å¸¸è°ƒç”¨

### æ–‡æ¡£æ›´æ–°
- [ ] API æ–‡æ¡£å·²æ›´æ–°
- [ ] ä½¿ç”¨ç¤ºä¾‹å·²åˆ›å»º
- [ ] æ•…éšœæ’é™¤æŒ‡å—å·²ç¼–å†™

---

## ğŸš¨ å¸¸è§é—®é¢˜è§£å†³

### é—®é¢˜ 1: Maturin æ„å»ºå¤±è´¥
**é”™è¯¯ä¿¡æ¯**: `error: linking with `link.exe` failed`
**è§£å†³æ–¹æ¡ˆ**:
```bash
# Windows: å®‰è£… Visual Studio Build Tools
# æˆ–ä½¿ç”¨ rustup å®‰è£… MSVC å·¥å…·é“¾
rustup toolchain install stable-x86_64-pc-windows-msvc
rustup default stable-x86_64-pc-windows-msvc
```

### é—®é¢˜ 2: PyO3 ç‰ˆæœ¬å†²çª
**é”™è¯¯ä¿¡æ¯**: `multiple versions of pyo3`
**è§£å†³æ–¹æ¡ˆ**:
```bash
# æ¸…ç†æ„å»ºç¼“å­˜
cargo clean
rm -rf python/build/
rm -rf python/target/

# é‡æ–°æ„å»º
maturin develop
```

### é—®é¢˜ 3: Python å¯¼å…¥é”™è¯¯
**é”™è¯¯ä¿¡æ¯**: `ModuleNotFoundError: No module named 'pulse_trader_engine'`
**è§£å†³æ–¹æ¡ˆ**:
```bash
# ç¡®ä¿åœ¨é¡¹ç›®æ ¹ç›®å½•
pwd

# é‡æ–°æ„å»º
maturin develop --release

# æ£€æŸ¥ Python è·¯å¾„
python -c "import sys; print(sys.path)"
```

---

## ğŸ“ å¼€å‘è®°å½•

**å®Œæˆæ—¶é—´**: ___________
**å®é™…è€—æ—¶**: ___________

### å®ç°çš„åŠŸèƒ½
1.
2.
3.

### é‡åˆ°çš„é—®é¢˜
1.
2.
3.

### è§£å†³æ–¹æ¡ˆ
1.
2.
3.

### æ€§èƒ½ä¼˜åŒ–
1.
2.
3.

---

## ğŸ¯ ä¸‹ä¸€æ­¥

ç¬¬äºŒé˜¶æ®µå®Œæˆåï¼Œæ‚¨å¯ä»¥ï¼š

1. **æäº¤ä»£ç **:
   ```bash
   git add .
   git commit -m "feat: å®Œæˆç¬¬äºŒé˜¶æ®µåŸºç¡€æ¡†æ¶æ­å»º

   - å®ç°Rustæ ¸å¿ƒæ•°æ®ç»“æ„
   - åˆ›å»ºPython FFIæ¥å£
   - é…ç½®é”™è¯¯å¤„ç†å’Œæ—¥å¿—ç³»ç»Ÿ
   - å»ºç«‹å•å…ƒæµ‹è¯•æ¡†æ¶
   - å®ŒæˆåŸºç¡€å·¥å…·å‡½æ•°"
   ```

2. **å¼€å§‹ç¬¬ä¸‰é˜¶æ®µ**:
   ```bash
   git checkout -b feature/third-phase
   ```

3. **é˜…è¯»ä¸‹ä¸€é˜¶æ®µæ–‡æ¡£**: [13-ç¬¬ä¸‰é˜¶æ®µ-æ•°æ®å±‚å¼€å‘.md](./13-ç¬¬ä¸‰é˜¶æ®µ-æ•°æ®å±‚å¼€å‘.md)

**æ­å–œå®Œæˆç¬¬äºŒé˜¶æ®µï¼** ğŸ‰ æ‚¨å·²ç»å»ºç«‹äº†å®Œæ•´çš„æ··åˆæ¶æ„æ¡†æ¶ï¼Œä¸ºæ•°æ®å±‚å¼€å‘å¥ å®šäº†åšå®åŸºç¡€ã€‚