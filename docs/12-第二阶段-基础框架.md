# 第二阶段：基础框架搭建

> **目标**: 建立 Rust+Python 混合架构的核心框架
> **预计时间**: 3-4天
> **提交标记**: `framework-complete`
> **前置条件**: 已完成[第一阶段环境搭建](./11-第一阶段-环境搭建.md)

## 📋 步骤概览

1. [✅] Rust 核心数据结构设计
2. [ ] Python FFI 接口实现
3. [ ] 错误处理系统
4. [ ] 日志系统配置
5. [ ] 单元测试框架
6. [ ] 基础工具函数

---

## 步骤 1: Rust 核心数据结构设计

### 1.1 基础数据类型定义

编辑 `engine/src/lib.rs`:

```rust
// engine/src/lib.rs

pub mod data;
pub mod indicators;
pub mod risk;
pub mod utils;
pub mod ffi;

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// 交易数据类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DataType {
    /// 日K线数据
    Daily,
    /// 分钟K线数据
    Minute1,
    Minute5,
    Minute15,
    Minute30,
    Minute60,
    /// Tick数据
    Tick,
}

/// K线数据结构
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KlineData {
    /// 代码
    pub symbol: String,
    /// 时间戳
    pub timestamp: DateTime<Utc>,
    /// 开盘价
    pub open: f64,
    /// 最高价
    pub high: f64,
    /// 最低价
    pub low: f64,
    /// 收盘价
    pub close: f64,
    /// 成交量
    pub volume: f64,
    /// 成交额
    pub amount: f64,
    /// 涨跌幅
    pub change_pct: f64,
}

impl KlineData {
    /// 创建新的K线数据
    pub fn new(
        symbol: String,
        timestamp: DateTime<Utc>,
        open: f64,
        high: f64,
        low: f64,
        close: f64,
        volume: f64,
        amount: f64,
    ) -> Self {
        let change_pct = if open > 0.0 { (close - open) / open } else { 0.0 };
        Self {
            symbol,
            timestamp,
            open,
            high,
            low,
            close,
            volume,
            amount,
            change_pct,
        }
    }

    /// 验证数据有效性
    pub fn is_valid(&self) -> bool {
        self.open > 0.0
            && self.high > 0.0
            && self.low > 0.0
            && self.close > 0.0
            && self.high >= self.low
            && self.high >= self.open
            && self.high >= self.close
            && self.low <= self.open
            && self.low <= self.close
            && self.volume >= 0.0
            && self.amount >= 0.0
    }
}

/// Tick数据结构
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TickData {
    /// 代码
    pub symbol: String,
    /// 时间戳
    pub timestamp: DateTime<Utc>,
    /// 最新价
    pub price: f64,
    /// 成交量
    pub volume: f64,
    /// 买一价
    pub bid1: f64,
    /// 买一量
    pub bid1_size: f64,
    /// 卖一价
    pub ask1: f64,
    /// 卖一量
    pub ask1_size: f64,
}

/// 技术指标数据
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IndicatorData {
    /// 时间戳
    pub timestamp: DateTime<Utc>,
    /// 指标值字典
    pub values: HashMap<String, f64>,
}

/// 错误类型定义
#[derive(Debug, thiserror::Error)]
pub enum PulseTraderError {
    #[error("数据错误: {message}")]
    DataError { message: String },

    #[error("计算错误: {message}")]
    CalculationError { message: String },

    #[error("网络错误: {source}")]
    NetworkError { #[from] source: reqwest::Error },

    #[error("IO错误: {source}")]
    IoError { #[from] source: std::io::Error },

    #[error("JSON解析错误: {source}")]
    JsonError { #[from] source: serde_json::Error },

    #[error("时间解析错误: {source}")]
    TimeError { #[from] source: chrono::ParseError },
}

pub type Result<T> = std::result::Result<T, PulseTraderError>;
```

### 1.2 数据源抽象接口

创建 `engine/src/data/mod.rs`:

```rust
// engine/src/data/mod.rs

pub mod source;
pub mod storage;

pub use source::{DataSource, DataSourceConfig};
pub use storage::DataStorage;

use crate::{KlineData, TickData, DataType, Result};
use async_trait::async_trait;
use std::collections::HashMap;

/// 数据源抽象接口
#[async_trait]
pub trait DataSource: Send + Sync {
    /// 获取K线数据
    async fn get_kline_data(
        &self,
        symbol: &str,
        data_type: DataType,
        start: chrono::DateTime<chrono::Utc>,
        end: chrono::DateTime<chrono::Utc>,
    ) -> Result<Vec<KlineData>>;

    /// 获取实时Tick数据
    async fn get_tick_data(&self, symbol: &str) -> Result<Vec<TickData>>;

    /// 获取股票列表
    async fn get_stock_list(&self) -> Result<Vec<String>>;

    /// 检查数据源是否可用
    async fn health_check(&self) -> Result<bool>;
}

/// 数据源配置
#[derive(Debug, Clone, serde::Deserialize)]
pub struct DataSourceConfig {
    /// 数据源类型
    pub source_type: String,
    /// 配置参数
    pub params: HashMap<String, serde_json::Value>,
    /// 请求限制
    pub rate_limit: Option<u32>,
}
```

创建 `engine/src/data/source.rs`:

```rust
// engine/src/data/source.rs

use super::{DataSource, DataSourceConfig};
use crate::{KlineData, TickData, DataType, Result};
use async_trait::async_trait;
use chrono::{DateTime, Utc};
use std::collections::HashMap;

/// 模拟数据源实现（用于测试）
pub struct MockDataSource {
    config: DataSourceConfig,
}

impl MockDataSource {
    pub fn new(config: DataSourceConfig) -> Self {
        Self { config }
    }

    /// 生成模拟K线数据
    fn generate_mock_kline(
        symbol: &str,
        start: DateTime<Utc>,
        end: DateTime<Utc>,
    ) -> Vec<KlineData> {
        let mut data = Vec::new();
        let mut current_time = start;
        let mut current_price = 100.0;

        while current_time <= end {
            // 模拟价格波动
            let change = (rand::random::<f64>() - 0.5) * 2.0; // -1 到 1 的随机变化
            let open = current_price;
            let close = current_price + change;
            let high = open.max(close) + rand::random::<f64>() * 0.5;
            let low = open.min(close) - rand::random::<f64>() * 0.5;
            let volume = rand::random::<f64>() * 1000000.0;
            let amount = volume * (open + high + low + close) / 4.0;

            data.push(KlineData::new(
                symbol.to_string(),
                current_time,
                open,
                high,
                low,
                close,
                volume,
                amount,
            ));

            current_price = close;
            current_time += chrono::Duration::days(1);
        }

        data
    }
}

#[async_trait]
impl DataSource for MockDataSource {
    async fn get_kline_data(
        &self,
        symbol: &str,
        _data_type: DataType,
        start: DateTime<Utc>,
        end: DateTime<Utc>,
    ) -> Result<Vec<KlineData>> {
        // 模拟网络延迟
        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;

        let data = Self::generate_mock_kline(symbol, start, end);
        Ok(data)
    }

    async fn get_tick_data(&self, symbol: &str) -> Result<Vec<TickData>> {
        tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;

        // 生成模拟tick数据
        let mut ticks = Vec::new();
        let now = Utc::now();

        for i in 0..10 {
            ticks.push(TickData {
                symbol: symbol.to_string(),
                timestamp: now + chrono::Duration::milliseconds(i * 100),
                price: 100.0 + (i as f64 * 0.01),
                volume: 1000.0,
                bid1: 99.99,
                bid1_size: 5000.0,
                ask1: 100.01,
                ask1_size: 5000.0,
            });
        }

        Ok(ticks)
    }

    async fn get_stock_list(&self) -> Result<Vec<String>> {
        tokio::time::sleep(tokio::time::Duration::from_millis(200)).await;

        Ok(vec![
            "000001.SZ".to_string(),
            "000002.SZ".to_string(),
            "600000.SH".to_string(),
            "600036.SH".to_string(),
        ])
    }

    async fn health_check(&self) -> Result<bool> {
        tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
        Ok(true)
    }
}
```

### 1.3 数据存储模块

创建 `engine/src/data/storage.rs`:

```rust
// engine/src/data/storage.rs

use crate::{KlineData, TickData, Result};
use std::path::PathBuf;
use std::collections::HashMap;

/// 数据存储抽象接口
pub trait DataStorage: Send + Sync {
    /// 保存K线数据
    fn save_kline_data(&self, data: &[KlineData]) -> Result<()>;

    /// 读取K线数据
    fn load_kline_data(
        &self,
        symbol: &str,
        start: chrono::DateTime<chrono::Utc>,
        end: chrono::DateTime<chrono::Utc>,
    ) -> Result<Vec<KlineData>>;

    /// 保存Tick数据
    fn save_tick_data(&self, data: &[TickData]) -> Result<()>;

    /// 检查数据是否存在
    fn data_exists(&self, symbol: &str, timestamp: chrono::DateTime<chrono::Utc>) -> Result<bool>;
}

/// 文件系统存储实现
pub struct FileStorage {
    base_path: PathBuf,
}

impl FileStorage {
    pub fn new(base_path: PathBuf) -> Self {
        Self { base_path }
    }

    fn get_data_path(&self, symbol: &str, data_type: &str) -> PathBuf {
        self.base_path
            .join("kline")
            .join(format!("{}.{}.csv", symbol, data_type))
    }
}

impl DataStorage for FileStorage {
    fn save_kline_data(&self, data: &[KlineData]) -> Result<()> {
        if data.is_empty() {
            return Ok(());
        }

        let symbol = &data[0].symbol;
        let path = self.get_data_path(symbol, "daily");

        // 确保目录存在
        if let Some(parent) = path.parent() {
            std::fs::create_dir_all(parent)?;
        }

        // 使用CSV格式保存
        let mut wtr = csv::Writer::from_path(path)?;

        for kline in data {
            wtr.serialize(kline)?;
        }

        wtr.flush()?;
        Ok(())
    }

    fn load_kline_data(
        &self,
        symbol: &str,
        start: chrono::DateTime<chrono::Utc>,
        end: chrono::DateTime<chrono::Utc>,
    ) -> Result<Vec<KlineData>> {
        let path = self.get_data_path(symbol, "daily");

        if !path.exists() {
            return Ok(Vec::new());
        }

        let mut rdr = csv::Reader::from_path(path)?;
        let mut data = Vec::new();

        for result in rdr.deserialize() {
            let kline: KlineData = result?;
            if kline.timestamp >= start && kline.timestamp <= end {
                data.push(kline);
            }
        }

        Ok(data)
    }

    fn save_tick_data(&self, _data: &[TickData]) -> Result<()> {
        // TODO: 实现Tick数据存储
        Ok(())
    }

    fn data_exists(&self, _symbol: &str, _timestamp: chrono::DateTime<chrono::Utc>) -> Result<bool> {
        // TODO: 实现数据存在性检查
        Ok(false)
    }
}
```

### 1.4 更新 Cargo.toml 依赖

编辑 `engine/Cargo.toml` 添加新的依赖：

```toml
# 在 [dependencies] 部分添加
async-trait = "0.1"
csv = "1.3"
rand = "0.8"
```

---

## 步骤 2: Python FFI 接口实现

### 2.1 创建 FFI 模块

创建 `engine/src/ffi/mod.rs`:

```rust
// engine/src/ffi/mod.rs

use crate::{KlineData, DataType, Result};
use pyo3::prelude::*;
use pyo3::types::{PyDateTime, PyDict};
use chrono::{DateTime, Utc, TimeZone};
use std::collections::HashMap;

/// 将 KlineData 转换为 Python 对象
#[pyclass]
pub struct PyKlineData {
    #[pyo3(get)]
    pub symbol: String,
    #[pyo3(get)]
    pub timestamp: Py<PyDateTime>,
    #[pyo3(get)]
    pub open: f64,
    #[pyo3(get)]
    pub high: f64,
    #[pyo3(get)]
    pub low: f64,
    #[pyo3(get)]
    pub close: f64,
    #[pyo3(get)]
    pub volume: f64,
    #[pyo3(get)]
    pub amount: f64,
    #[pyo3(get)]
    pub change_pct: f64,
}

impl From<KlineData> for PyKlineData {
    fn from(kline: KlineData) -> Self {
        Python::with_gil(|py| {
            let timestamp = PyDateTime::new_from_timestamp(
                py,
                kline.timestamp.timestamp(),
                Some(kline.timestamp.timestamp_subsec_nanos() as u32),
            ).unwrap();

            Self {
                symbol: kline.symbol,
                timestamp,
                open: kline.open,
                high: kline.high,
                low: kline.low,
                close: kline.close,
                volume: kline.volume,
                amount: kline.amount,
                change_pct: kline.change_pct,
            }
        })
    }
}

/// 数据引擎 Python 接口
#[pyclass]
pub struct DataEngine {
    // 这里将来会包含实际的数据源
    #[pyo3(get)]
    pub initialized: bool,
}

#[pymethods]
impl DataEngine {
    #[new]
    fn new() -> Self {
        Self {
            initialized: false,
        }
    }

    /// 初始化数据引擎
    fn initialize(&mut self) -> Result<()> {
        // TODO: 实际的初始化逻辑
        self.initialized = true;
        Ok(())
    }

    /// 获取K线数据
    fn get_kline_data(
        &self,
        py: Python,
        symbol: &str,
        start_date: &PyDateTime,
        end_date: &PyDateTime,
    ) -> Result<Vec<PyKlineData>> {
        // TODO: 实际的数据获取逻辑
        // 这里返回模拟数据用于演示

        let start_timestamp = start_date.timestamp();
        let end_timestamp = end_date.timestamp();

        let mut data = Vec::new();
        let mut current_time = Utc.timestamp_opt(start_timestamp, 0).unwrap();

        while current_time.timestamp() <= end_timestamp {
            let mock_kline = KlineData::new(
                symbol.to_string(),
                current_time,
                100.0,  // open
                102.0,  // high
                99.0,   // low
                101.0,  // close
                1000000.0,  // volume
                101000000.0, // amount
            );

            data.push(PyKlineData::from(mock_kline));
            current_time += chrono::Duration::days(1);
        }

        Ok(data)
    }

    /// 检查引擎健康状态
    fn health_check(&self) -> bool {
        self.initialized
    }
}

/// Python 模块定义
#[pymodule]
fn pulse_trader_engine(_py: Python, m: &PyModule) -> PyResult<()> {
    m.add_class::<PyKlineData>()?;
    m.add_class::<DataEngine>()?;

    // 添加版本信息
    m.add("__version__", env!("CARGO_PKG_VERSION"))?;

    Ok(())
}
```

### 2.2 配置 Maturin 构建文件

在项目根目录创建 `pyproject.toml`:

```toml
# pyproject.toml

[build-system]
requires = ["maturin>=1.4,<2.0"]
build-backend = "maturin"

[project]
name = "pulse-trader"
requires-python = ">=3.8"
classifiers = [
    "Programming Language :: Rust",
    "Programming Language :: Python :: Implementation :: CPython",
    "Programming Language :: Python :: Implementation :: PyPy",
]
dependencies = [
    "pandas>=2.1.0",
    "numpy>=1.24.0",
    "matplotlib>=3.7.0",
    "python-dotenv>=1.0.0",
    "pyyaml>=6.0.0",
]

[tool.maturin]
features = ["pyo3/extension-module"]
module-name = "pulse_trader_engine._pulse_trader_engine"
python-source = "python"
```

### 2.3 构建 Python 扩展

```bash
# 在项目根目录执行
maturin develop

# 如果遇到错误，可能需要先安装一些系统依赖
# Ubuntu/Debian: sudo apt install build-essential python3-dev
# macOS: xcode-select --install
```

### 2.4 创建 Python 包装器

创建 `python/pulse_trader/engine.py`:

```python
# python/pulse_trader/engine.py

"""
PulseTrader 数据引擎 Python 接口
"""

from typing import List, Optional, Union
from datetime import datetime
import pandas as pd
from pulse_trader_engine import DataEngine, PyKlineData


class DataEngineWrapper:
    """数据引擎 Python 包装器"""

    def __init__(self):
        self._engine = DataEngine()
        self._initialized = False

    def initialize(self) -> bool:
        """初始化数据引擎"""
        try:
            self._engine.initialize()
            self._initialized = True
            return True
        except Exception as e:
            print(f"初始化失败: {e}")
            return False

    def get_kline_data(
        self,
        symbol: str,
        start_date: Union[datetime, str],
        end_date: Union[datetime, str],
    ) -> pd.DataFrame:
        """
        获取K线数据

        Args:
            symbol: 股票代码
            start_date: 开始日期 (datetime 或字符串)
            end_date: 结束日期 (datetime 或字符串)

        Returns:
            包含K线数据的 DataFrame
        """
        if not self._initialized:
            raise RuntimeError("数据引擎未初始化，请先调用 initialize()")

        # 转换日期格式
        if isinstance(start_date, str):
            start_date = pd.to_datetime(start_date).to_pydatetime()
        if isinstance(end_date, str):
            end_date = pd.to_datetime(end_date).to_pydatetime()

        # 调用 Rust 引擎
        py_data = self._engine.get_kline_data(symbol, start_date, end_date)

        # 转换为 DataFrame
        if not py_data:
            return pd.DataFrame()

        # 提取数据
        data_list = []
        for item in py_data:
            data_list.append({
                'symbol': item.symbol,
                'timestamp': item.timestamp,
                'open': item.open,
                'high': item.high,
                'low': item.low,
                'close': item.close,
                'volume': item.volume,
                'amount': item.amount,
                'change_pct': item.change_pct,
            })

        df = pd.DataFrame(data_list)
        df['timestamp'] = pd.to_datetime(df['timestamp'])
        df.set_index('timestamp', inplace=True)

        return df

    def health_check(self) -> bool:
        """检查引擎健康状态"""
        return self._engine.health_check()


# 全局实例
_engine_instance = None

def get_engine() -> DataEngineWrapper:
    """获取全局数据引擎实例"""
    global _engine_instance
    if _engine_instance is None:
        _engine_instance = DataEngineWrapper()
    return _engine_instance
```

---

## 步骤 3: 错误处理系统

### 3.1 创建 Python 异常类

创建 `python/pulse_trader/exceptions.py`:

```python
# python/pulse_trader/exceptions.py

"""
PulseTrader 异常定义
"""


class PulseTraderError(Exception):
    """基础异常类"""
    pass


class DataError(PulseTraderError):
    """数据相关异常"""
    pass


class NetworkError(PulseTraderError):
    """网络相关异常"""
    pass


class CalculationError(PulseTraderError):
    """计算相关异常"""
    pass


class ConfigError(PulseTraderError):
    """配置相关异常"""
    pass


class ValidationError(PulseTraderError):
    """数据验证异常"""
    pass
```

### 3.2 创建工具函数模块

创建 `python/pulse_trader/utils/__init__.py`:

```python
# python/pulse_trader/utils/__init__.py

"""
工具函数模块
"""

from .logger import get_logger, setup_logging
from .config import load_config, get_config
from .validation import validate_kline_data, validate_symbol

__all__ = [
    "get_logger",
    "setup_logging",
    "load_config",
    "get_config",
    "validate_kline_data",
    "validate_symbol",
]
```

创建 `python/pulse_trader/utils/logger.py`:

```python
# python/pulse_trader/utils/logger.py

"""
日志系统配置
"""

import logging
import sys
from pathlib import Path
from typing import Optional
import yaml


def setup_logging(
    level: str = "INFO",
    log_file: Optional[str] = None,
    format_string: Optional[str] = None,
) -> None:
    """
    设置日志系统

    Args:
        level: 日志级别 (DEBUG, INFO, WARNING, ERROR, CRITICAL)
        log_file: 日志文件路径
        format_string: 日志格式字符串
    """
    if format_string is None:
        format_string = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"

    # 配置根日志记录器
    root_logger = logging.getLogger()
    root_logger.setLevel(getattr(logging, level.upper()))

    # 清除现有的处理器
    for handler in root_logger.handlers[:]:
        root_logger.removeHandler(handler)

    # 创建格式化器
    formatter = logging.Formatter(format_string)

    # 控制台处理器
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    root_logger.addHandler(console_handler)

    # 文件处理器 (如果指定了文件路径)
    if log_file:
        log_path = Path(log_file)
        log_path.parent.mkdir(parents=True, exist_ok=True)

        file_handler = logging.FileHandler(log_path, encoding='utf-8')
        file_handler.setFormatter(formatter)
        root_logger.addHandler(file_handler)


def get_logger(name: str) -> logging.Logger:
    """
    获取指定名称的日志记录器

    Args:
        name: 日志记录器名称

    Returns:
        Logger 实例
    """
    return logging.getLogger(name)
```

创建 `python/pulse_trader/utils/config.py`:

```python
# python/pulse_trader/utils/config.py

"""
配置管理工具
"""

import os
import yaml
from pathlib import Path
from typing import Any, Dict, Optional
from dotenv import load_dotenv
from ..exceptions import ConfigError


class Config:
    """配置管理类"""

    def __init__(self, config_file: Optional[str] = None):
        self._config: Dict[str, Any] = {}
        self._config_file = config_file

        # 加载环境变量
        load_dotenv()

        # 加载配置文件
        if config_file:
            self.load_config(config_file)

    def load_config(self, config_file: str) -> None:
        """
        加载配置文件

        Args:
            config_file: 配置文件路径
        """
        config_path = Path(config_file)
        if not config_path.exists():
            raise ConfigError(f"配置文件不存在: {config_file}")

        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                self._config = yaml.safe_load(f) or {}
        except yaml.YAMLError as e:
            raise ConfigError(f"配置文件解析失败: {e}")

    def get(self, key: str, default: Any = None) -> Any:
        """
        获取配置值，支持点分隔的嵌套键

        Args:
            key: 配置键 (支持 "app.name" 格式)
            default: 默认值

        Returns:
            配置值
        """
        keys = key.split('.')
        value = self._config

        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]
            else:
                # 尝试从环境变量获取
                env_key = '_'.join(keys).upper()
                env_value = os.getenv(env_key)
                if env_value is not None:
                    return env_value
                return default

        # 如果值是字符串且包含环境变量引用，进行替换
        if isinstance(value, str) and '${' in value:
            import re
            pattern = r'\$\{([^}]+)\}'

            def replace_env_var(match):
                env_var = match.group(1)
                return os.getenv(env_var, match.group(0))

            value = re.sub(pattern, replace_env_var, value)

        return value

    def set(self, key: str, value: Any) -> None:
        """
        设置配置值

        Args:
            key: 配置键
            value: 配置值
        """
        keys = key.split('.')
        config = self._config

        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]

        config[keys[-1]] = value


# 全局配置实例
_config_instance = None

def load_config(config_file: Optional[str] = None) -> Config:
    """加载配置文件"""
    global _config_instance
    if config_file is None:
        # 尝试找到默认配置文件
        default_paths = [
            "config/config.yaml",
            "../config/config.yaml",
            "../../config/config.yaml",
        ]

        for path in default_paths:
            if Path(path).exists():
                config_file = path
                break

    _config_instance = Config(config_file)
    return _config_instance

def get_config() -> Config:
    """获取全局配置实例"""
    global _config_instance
    if _config_instance is None:
        _config_instance = load_config()
    return _config_instance
```

创建 `python/pulse_trader/utils/validation.py`:

```python
# python/pulse_trader/utils/validation.py

"""
数据验证工具
"""

import pandas as pd
import re
from typing import List, Union
from ..exceptions import ValidationError


def validate_symbol(symbol: str) -> bool:
    """
    验证股票代码格式

    Args:
        symbol: 股票代码

    Returns:
        是否有效
    """
    if not isinstance(symbol, str):
        raise ValidationError("股票代码必须是字符串")

    # A股代码格式: 6位数字 + .交易所代码
    pattern = r'^\d{6}\.(SH|SZ|BJ)$'
    if not re.match(pattern, symbol):
        raise ValidationError(f"无效的股票代码格式: {symbol}")

    return True


def validate_kline_data(df: pd.DataFrame) -> bool:
    """
    验证K线数据的有效性

    Args:
        df: K线数据 DataFrame

    Returns:
        是否有效
    """
    if df.empty:
        raise ValidationError("K线数据为空")

    required_columns = ['open', 'high', 'low', 'close', 'volume']
    missing_columns = [col for col in required_columns if col not in df.columns]

    if missing_columns:
        raise ValidationError(f"缺少必需的列: {missing_columns}")

    # 检查价格数据的合理性
    price_columns = ['open', 'high', 'low', 'close']

    for col in price_columns:
        if (df[col] <= 0).any():
            raise ValidationError(f"列 {col} 中存在非正数价格")

    # 检查高低价关系
    if (df['high'] < df['low']).any():
        raise ValidationError("最高价不能低于最低价")

    # 检查成交量
    if (df['volume'] < 0).any():
        raise ValidationError("成交量不能为负数")

    return True


def validate_date_range(start_date: str, end_date: str) -> bool:
    """
    验证日期范围

    Args:
        start_date: 开始日期
        end_date: 结束日期

    Returns:
        是否有效
    """
    try:
        start = pd.to_datetime(start_date)
        end = pd.to_datetime(end_date)

        if start >= end:
            raise ValidationError("开始日期必须早于结束日期")

        return True
    except Exception as e:
        raise ValidationError(f"日期格式错误: {e}")
```

---

## 步骤 4: 创建单元测试

### 4.1 Rust 单元测试

创建 `engine/src/lib.rs` 的测试模块：

```rust
// 在 engine/src/lib.rs 末尾添加测试

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::{Utc, Duration};

    #[test]
    fn test_kline_data_creation() {
        let timestamp = Utc::now();
        let kline = KlineData::new(
            "000001.SZ".to_string(),
            timestamp,
            10.0,
            11.0,
            9.5,
            10.5,
            1000000.0,
            10500000.0,
        );

        assert_eq!(kline.symbol, "000001.SZ");
        assert_eq!(kline.open, 10.0);
        assert_eq!(kline.close, 10.5);
        assert!(kline.is_valid());
    }

    #[test]
    fn test_kline_data_validation() {
        let timestamp = Utc::now();

        // 有效数据
        let valid_kline = KlineData::new(
            "000001.SZ".to_string(),
            timestamp,
            10.0,
            11.0,
            9.5,
            10.5,
            1000000.0,
            10500000.0,
        );
        assert!(valid_kline.is_valid());

        // 无效数据 (high < low)
        let invalid_kline = KlineData::new(
            "000001.SZ".to_string(),
            timestamp,
            10.0,
            9.0,  // high < low
            9.5,
            10.5,
            1000000.0,
            10500000.0,
        );
        assert!(!invalid_kline.is_valid());
    }

    #[tokio::test]
    async fn test_mock_data_source() {
        use data::source::{MockDataSource, DataSourceConfig};
        use std::collections::HashMap;

        let config = DataSourceConfig {
            source_type: "mock".to_string(),
            params: HashMap::new(),
            rate_limit: None,
        };

        let source = MockDataSource::new(config);

        // 测试健康检查
        assert!(source.health_check().await.unwrap());

        // 测试获取股票列表
        let stock_list = source.get_stock_list().await.unwrap();
        assert!(!stock_list.is_empty());

        // 测试获取K线数据
        let end = Utc::now();
        let start = end - Duration::days(5);
        let kline_data = source
            .get_kline_data("000001.SZ", DataType::Daily, start, end)
            .await
            .unwrap();

        assert!(!kline_data.is_empty());
        for kline in &kline_data {
            assert!(kline.is_valid());
        }
    }
}
```

### 4.2 Python 单元测试

创建 `python/tests/test_engine.py`:

```python
# python/tests/test_engine.py

"""
数据引擎测试
"""

import pytest
from datetime import datetime, timedelta
import pandas as pd
from pulse_trader.engine import get_engine, DataEngineWrapper
from pulse_trader.exceptions import DataError


class TestDataEngine:
    """数据引擎测试类"""

    def setup_method(self):
        """每个测试方法前的设置"""
        self.engine = DataEngineWrapper()

    def test_engine_initialization(self):
        """测试引擎初始化"""
        assert not self.engine._initialized

        result = self.engine.initialize()
        assert result is True
        assert self.engine._initialized

    def test_health_check(self):
        """测试健康检查"""
        # 未初始化时
        assert not self.engine.health_check()

        # 初始化后
        self.engine.initialize()
        assert self.engine.health_check()

    def test_get_kline_data_uninitialized(self):
        """测试未初始化时获取数据"""
        with pytest.raises(RuntimeError):
            self.engine.get_kline_data("000001.SZ", "2023-01-01", "2023-01-10")

    def test_get_kline_data_initialized(self):
        """测试初始化后获取数据"""
        self.engine.initialize()

        df = self.engine.get_kline_data(
            "000001.SZ",
            "2023-01-01",
            "2023-01-10"
        )

        assert isinstance(df, pd.DataFrame)
        assert not df.empty
        assert 'open' in df.columns
        assert 'close' in df.columns
        assert 'volume' in df.columns

    def test_get_kline_data_with_datetime(self):
        """测试使用 datetime 对象获取数据"""
        self.engine.initialize()

        start_date = datetime(2023, 1, 1)
        end_date = datetime(2023, 1, 5)

        df = self.engine.get_kline_data("000001.SZ", start_date, end_date)

        assert isinstance(df, pd.DataFrame)
        assert not df.empty

    def test_global_engine_instance(self):
        """测试全局引擎实例"""
        engine1 = get_engine()
        engine2 = get_engine()

        # 应该是同一个实例
        assert engine1 is engine2


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
```

创建 `python/tests/test_utils.py`:

```python
# python/tests/test_utils.py

"""
工具函数测试
"""

import pytest
import tempfile
import os
from pathlib import Path
from pulse_trader.utils.validation import validate_symbol, validate_kline_data, validate_date_range
from pulse_trader.utils.config import Config
from pulse_trader.exceptions import ValidationError, ConfigError


class TestValidation:
    """验证工具测试类"""

    def test_validate_symbol_valid(self):
        """测试有效股票代码"""
        valid_symbols = [
            "000001.SZ",
            "600000.SH",
            "872305.BJ",
        ]

        for symbol in valid_symbols:
            assert validate_symbol(symbol) is True

    def test_validate_symbol_invalid(self):
        """测试无效股票代码"""
        invalid_symbols = [
            "000001",  # 缺少交易所
            "000001.S", # 无效交易所
            "ABCDEF.SZ", # 非数字代码
            123456,     # 非字符串
            "",         # 空字符串
        ]

        for symbol in invalid_symbols:
            with pytest.raises(ValidationError):
                validate_symbol(symbol)

    def test_validate_kline_data_valid(self):
        """测试有效K线数据"""
        import pandas as pd

        df = pd.DataFrame({
            'open': [10.0, 10.5, 11.0],
            'high': [10.5, 11.0, 11.5],
            'low': [9.5, 10.0, 10.5],
            'close': [10.5, 11.0, 11.5],
            'volume': [1000000, 1100000, 1200000],
        })

        assert validate_kline_data(df) is True

    def test_validate_kline_data_invalid(self):
        """测试无效K线数据"""
        import pandas as pd

        # 缺少必需列
        df_invalid = pd.DataFrame({
            'open': [10.0, 10.5],
            'close': [10.5, 11.0],
        })

        with pytest.raises(ValidationError):
            validate_kline_data(df_invalid)

        # 价格数据不合理
        df_negative = pd.DataFrame({
            'open': [10.0, -10.5],  # 负价格
            'high': [10.5, 11.0],
            'low': [9.5, 10.0],
            'close': [10.5, 11.0],
            'volume': [1000000, 1100000],
        })

        with pytest.raises(ValidationError):
            validate_kline_data(df_negative)

    def test_validate_date_range_valid(self):
        """测试有效日期范围"""
        assert validate_date_range("2023-01-01", "2023-01-10") is True
        assert validate_date_range("2023-01-01 00:00:00", "2023-01-10 23:59:59") is True

    def test_validate_date_range_invalid(self):
        """测试无效日期范围"""
        # 开始日期晚于结束日期
        with pytest.raises(ValidationError):
            validate_date_range("2023-01-10", "2023-01-01")

        # 无效日期格式
        with pytest.raises(ValidationError):
            validate_date_range("invalid-date", "2023-01-01")


class TestConfig:
    """配置管理测试类"""

    def test_config_load_invalid_file(self):
        """测试加载无效配置文件"""
        with pytest.raises(ConfigError):
            Config("nonexistent_file.yaml")

    def test_config_get_set(self):
        """测试配置获取和设置"""
        config = Config()

        # 设置值
        config.set("test.key", "test_value")

        # 获取值
        assert config.get("test.key") == "test_value"
        assert config.get("nonexistent.key", "default") == "default"

    def test_config_env_substitution(self):
        """测试环境变量替换"""
        config = Config()

        # 设置环境变量
        os.environ["TEST_VAR"] = "env_value"

        # 模拟配置值
        config._config = {
            "test": {
                "substitution": "${TEST_VAR}"
            }
        }

        assert config.get("test.substitution") == "env_value"

        # 清理
        del os.environ["TEST_VAR"]


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
```

### 4.3 创建测试配置文件

创建 `python/pytest.ini`:

```ini
[tool:pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts =
    -v
    --tb=short
    --strict-markers
    --disable-warnings
    --cov=pulse_trader
    --cov-report=html
    --cov-report=term-missing
markers =
    slow: marks tests as slow (deselect with '-m "not slow"')
    integration: marks tests as integration tests
    unit: marks tests as unit tests
```

---

## 步骤 5: 运行测试和验证

### 5.1 Rust 测试

```bash
# 在项目根目录
cd engine

# 运行所有测试
cargo test

# 运行特定测试
cargo test test_kline_data_creation

# 显示测试输出
cargo test -- --nocapture

cd ..
```

### 5.2 Python 测试

```bash
# 确保虚拟环境已激活
source .venv/bin/activate

# 重新构建 Python 扩展
maturin develop

# 运行 Python 测试
cd python
python -m pytest tests/ -v

# 运行特定测试文件
python -m pytest tests/test_engine.py -v

# 生成覆盖率报告
python -m pytest tests/ --cov=pulse_trader --cov-report=html

cd ..
```

### 5.3 集成测试

创建 `tests/integration_test.py`:

```python
#!/usr/bin/env python3
"""
集成测试脚本
"""

import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'python'))

from pulse_trader.engine import get_engine
from pulse_trader.utils import setup_logging, get_logger
from datetime import datetime, timedelta


def test_basic_workflow():
    """测试基本工作流程"""
    print("🧪 开始集成测试...")

    # 设置日志
    setup_logging(level="INFO")
    logger = get_logger(__name__)

    try:
        # 1. 获取数据引擎
        logger.info("获取数据引擎...")
        engine = get_engine()

        # 2. 初始化引擎
        logger.info("初始化数据引擎...")
        if not engine.initialize():
            raise Exception("引擎初始化失败")

        # 3. 健康检查
        logger.info("执行健康检查...")
        if not engine.health_check():
            raise Exception("健康检查失败")

        # 4. 获取测试数据
        logger.info("获取测试数据...")
        end_date = datetime.now()
        start_date = end_date - timedelta(days=10)

        df = engine.get_kline_data("000001.SZ", start_date, end_date)

        if df.empty:
            raise Exception("获取数据失败")

        logger.info(f"成功获取 {len(df)} 条K线数据")
        logger.info(f"数据列: {list(df.columns)}")
        logger.info(f"数据示例:\n{df.head()}")

        print("✅ 集成测试通过！")
        return True

    except Exception as e:
        logger.error(f"集成测试失败: {e}")
        print(f"❌ 集成测试失败: {e}")
        return False


if __name__ == "__main__":
    success = test_basic_workflow()
    sys.exit(0 if success else 1)
```

运行集成测试：

```bash
# 在项目根目录
python tests/integration_test.py
```

---

## ✅ 完成检查清单

### 代码实现
- [ ] Rust 核心数据结构已实现
- [ ] Python FFI 接口已创建
- [ ] 错误处理系统已配置
- [ ] 日志系统已实现
- [ ] 工具函数模块已完成

### 测试覆盖
- [ ] Rust 单元测试全部通过
- [ ] Python 单元测试全部通过
- [ ] 集成测试成功运行
- [ ] 代码覆盖率报告生成

### 构建验证
- [ ] `maturin develop` 构建成功
- [ ] Python 模块可以正常导入
- [ ] 所有功能可以正常调用

### 文档更新
- [ ] API 文档已更新
- [ ] 使用示例已创建
- [ ] 故障排除指南已编写

---

## 🚨 常见问题解决

### 问题 1: Maturin 构建失败
**错误信息**: `error: linking with `link.exe` failed`
**解决方案**:
```bash
# Windows: 安装 Visual Studio Build Tools
# 或使用 rustup 安装 MSVC 工具链
rustup toolchain install stable-x86_64-pc-windows-msvc
rustup default stable-x86_64-pc-windows-msvc
```

### 问题 2: PyO3 版本冲突
**错误信息**: `multiple versions of pyo3`
**解决方案**:
```bash
# 清理构建缓存
cargo clean
rm -rf python/build/
rm -rf python/target/

# 重新构建
maturin develop
```

### 问题 3: Python 导入错误
**错误信息**: `ModuleNotFoundError: No module named 'pulse_trader_engine'`
**解决方案**:
```bash
# 确保在项目根目录
pwd

# 重新构建
maturin develop --release

# 检查 Python 路径
python -c "import sys; print(sys.path)"
```

---

## 📝 开发记录

**完成时间**: ___________
**实际耗时**: ___________

### 实现的功能
1.
2.
3.

### 遇到的问题
1.
2.
3.

### 解决方案
1.
2.
3.

### 性能优化
1.
2.
3.

---

## 🎯 下一步

第二阶段完成后，您可以：

1. **提交代码**:
   ```bash
   git add .
   git commit -m "feat: 完成第二阶段基础框架搭建

   - 实现Rust核心数据结构
   - 创建Python FFI接口
   - 配置错误处理和日志系统
   - 建立单元测试框架
   - 完成基础工具函数"
   ```

2. **开始第三阶段**:
   ```bash
   git checkout -b feature/third-phase
   ```

3. **阅读下一阶段文档**: [13-第三阶段-数据层开发.md](./13-第三阶段-数据层开发.md)

**恭喜完成第二阶段！** 🎉 您已经建立了完整的混合架构框架，为数据层开发奠定了坚实基础。